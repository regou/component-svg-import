{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///dist/index-with-deps.min.js","webpack:///webpack/bootstrap 80837e48f239fb4802dc?c7f0","webpack:///./src/index.js?9552","webpack:///./~/skatejs-web-components/dist/index.js?d957","webpack:///./~/skatejs/dist/index.js?6821","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js?18a5","webpack:///./~/window-or-global/lib/index.js?d7c1"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","_skatejs","React","createElement","customElements","_Component","_class","apply","arguments","jQuery","comp","$","url","src","cache","async","then","xml","$svg","find","svg","removeAttribute","width","height","setAttribute","wraper","shadowRoot","innerHTML","appendChild","name","oldValue","newValue","updateXml","defBoxStyle","h","role","className","prop","string","attribute","inner-style","Component","fixSafari","newAttachShadow","opts","sr","oldAttachShadow","mo","observe","moOpts","HTMLElement","attachShadow","childList","subtree","MutationObserver","muts","forEach","mut","tagName","nextSibling","parentNode","removeChild","insertBefore","_window","window","navigator","userAgent","safari","indexOf","safariVersion","match","safariVersions","map","v","concat","patch","default","eval","a","Map","j","o","Set","C","D","bind","f","F","enableFlush","s","g","k","test","q","Error","l","b","d","e","toLowerCase","u","n","getAttribute","__$CE_upgraded","localName","A","document","forcePolyfill","split","L","has","set","w","observedAttributes","K","resolve","delete","M","Promise","reject","N","takeRecords","childNodes","HTMLImports","whenReady","I","__$CE_observer","add","J","disconnect","type","removedNodes","addedNodes","H","nodeType","Node","ELEMENT_NODE","createTreeWalker","NodeFilter","SHOW_ELEMENT","G","currentNode","nextNode","__$CE_attached","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","host","rel","B","import","href","removeEventListener","addEventListener","console","assert","attributes","attributeOldValue","attributeFilter","hasAttribute","attributeName","attributeNamespace","CustomElementRegistry","whenDefined","flush","polyfilled","_observeRoot","_addImport","r","t","createElementNS","Element","importNode","CustomElements","isShadyRoot","obj","Boolean","__localName","matchesSelector","element","selector","matches","copyOwnProperty","source","pd","extend","n$","getOwnPropertyNames","extendAll","sources","len","mixin","patchPrototype","proto","hasOwnProperty","patchProto","__sourceProto","__patchProto","newSplice","index","removed","addedCount","getNativeProperty","descriptors","enqueue","callback","scheduled","promish","flush$1","flushList","push","flushCount","shift","isFlushedMaxed","flushMax","escapeReplace","escapeAttr","replace","escapeAttrRegExp","escapeData","escapeDataRegExp","makeSet","arr","getOuterHTML","node","composed","attr","attrs","voidElements","getInnerHTML","TEXT_NODE","data","plaintextParents","COMMENT_NODE","error","content","child","c$","filterMutations","mutations","targetRootNode","getRootNode","filter","mutation","mutationInScope","nodes","Array","from","patchNode","settings","inUse","isNodePatched","patchImpl","canPatchNode","tree","saveChildNodes","unpatchNode","unpatch","__patched","pathComposer","startNode","composedPath","current","startRoot","assignedSlot","retarget","refNode","path","ancestor","lastRoot","rootIdx","refNodePath","p$","mixinComposedFlag","Base","klazz","options","event","__composed","fireHandlers","phase","hs","__handlers","fn","__immediatePropagationStopped","retargetNonBubblingEvent","__propagationStopped","Event","AT_TARGET","lastFiredRoot","i$1","optionsOrCapture","this$1","capture","once","passive","__eventWrappers","wrapperFn","__target","__relatedTarget","relatedTarget","EventMixin","eventPhase","BUBBLING_PHASE","stopImmediatePropagation","nonBubblingEventsToRetarget","bubble","origAddEventListener","splice","origRemoveEventListener","idx","activateFocusEventOverrides","ev","ShadyDOM","hasNativeShadowDOM","force","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","common","cb","twiddle","createTextNode","observer","characterData","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","ArraySplice","calcEditDistances","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","j$1","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","calcSplices","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","splices","oldIndex","searchLength","index1","index2","count","calculateSplices","previous","currentValue","previousValue","nativeInsertBefore","nativeAppendChild","nativeRemoveChild","arrayCopyChildNodes","copy","firstChild","arrayCopyChildren","firstElementChild","nextElementSibling","arrayCopy","a$","Logical","Composed","hasParentNode","saveComposedData","__dom","hasChildNodes","getChildNodes","_getChildNodes","getFirstChild","getNextSibling","getParentNode","getLastChild","lastChild","getPreviousSibling","previousSibling","getFirstElementChild","_getFirstElementChild","getLastElementChild","_getLastElementChild","getNextElementSibling","_getNextElementSibling","getPreviousElementSibling","_getPreviousElementSibling","recordInsertBefore","container","ref_node","_linkNode","recordRemoveChild","$parentNode","$childNodes","$firstChild","$nextSibling","getComposedChildNodes","$lastChild","$previousSibling","lastElementChild","previousElementSibling","clearChildNodes","saveParentNode","newChild","refChild","_addChild","currentParent","_removeChild","isFrag","oldParent","NormalizedEvent","inType","params","createEvent","initEvent","bubbles","cancelable","Distributor","anonymous","insertionPointTag","getInsertionPoints","querySelectorAll","hasInsertionPoint","_insertionPoints","isInsertionPoint","distribute","distributePool","collectPool","pool","dirtyRoots","distributeInsertionPoint","shadyRoot","p$1","_assignedSlot","parent$1","insertionPoint","prevAssignedNodes","_assignedNodes","clearAssignedSlots","needsSlotChange","anyDistributed","matchesInsertionPoint","__prevAssignedSlot","distributeNodeInto","node$1","children","setDistributedNodesOnInsertionPoint","_fireSlotChange","slot","savePrevious","slotName","trim","_distributedNodes","d$","dispatchEvent","isFinalDestination","ShadyRoot","frag","createDocumentFragment","ShadyFragmentMixin","_init","ShadyMixin","_clean","_hasRendered","_distributor","update","distributionRoot","_findDistributionRoot","render","_elementNeedsDistribution","_skipUpdateInsertionPoints","updateInsertionPoints","compose","forceRender","i$","__insertionPoints","c$1","insertionPoints","_composeTree","_updateChildNodes","_composeNode","distributedNodes","distributedNode","s$1","next","n$1","getInsertionPointTag","DocumentFragment","list","mixinImpl","addNode","ownerRoot","ownerShadyRootForNode","__noInsertionPoint","ipAdded","_maybeAddInsertionPoint","handled","_maybeDistribute","removeNode","distributed","logicalParent","maybeDistributeParent","_removeDistributedChildren","_removeOwnerShadyRoot","_scheduleObserver","addedNode","removedNode","schedule","removeNodeFromParent","_hasCachedOwnerRoot","__ownerShadyRoot","documentElement","contains","fragContent","querySelector","wrappedContent","hasContent","needsDist","_nodeNeedsDistribution","added","np","na","hostNeedsDist","ip$","_contains","dc$","assignedNodes","flatten","firstComposedNode","clearNode","maybeDistributeAttributeChange","query","matcher","halter","_queryElements","elements","_queryElement","result","activeElementForNode","active","activeElement","isShadyRoot$$1","activeRoot","nativeCloneNode","cloneNode","nativeImportNode","Document","nativeSetAttribute","nativeRemoveAttribute","ShadyCSS","setElementClass","NodeMixin","parentElement","FragmentMixin","replaceChild","deep","nc","externalNode","doc","ownerDocument","isArray","textContent","tc","cn","join","text","ElementMixin","activeElementDescriptor","ActiveElementMixin","UnderActiveElementMixin","_activeElement","Mixins","Fragment","AsyncObserver","_scheduled","callbacks","observeChildren","_callback","_observer","_node","unobserveChildren","handle","size","patchedCount","log","head","hasPrototypeDescriptors","warn","mixinForObject","mixinForNode","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","isTrusted","__composedPath","currentTarget","__relatedTargetComposedPath","stopPropagation","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","isPatched","createRootAndEnsurePatched","parse","clean","parseCss","lex","cssText","RX","comments","port","start","end","OPEN_BRACE","rules","CLOSE_BRACE","substring","parsedCssText","ss","_expandUnicodeEscapes","multipleSpaces","lastIndexOf","parsedSelector","atRule","AT_START","MEDIA_START","types","MEDIA_RULE","keyframesRule","KEYFRAMES_RULE","keyframesName","pop","VAR_START","MIXIN_RULE","STYLE_RULE","r$","code","repeat","stringify","preserveProperties","_hasMixinRules","removeCustomProps","removeCustomPropAssignment","removeCustomPropApply","customProp","mixinProp","mixinApply","varApply","parseSettings","nativeCssVariables","shimcssproperties","nativeShadow","shimshadow","toCssText","forEachRule","rulesForStyle","style","__cssRules","isKeyframesSelector","rule","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","matchMedia","rx","MEDIA_MATCH","applyCss","moniker","contextNode","createScopeStyle","applyStyle$1","after","lastHeadApplyNode","applyStylePlaceHolder","placeHolder","createComment","scope","findMatchingParen","level","processVariableAndFallback","str","inner","prefix","suffix","comma","fallback","addToBitMask","bits","parseInt","enqueueDocumentValidation","enqueued","validateDocument","readyState","requestAnimationFrame","ShadyCSS$1","updateStyles","CustomStyle","Reflect","construct","customStyles","CSS","supports","nativeCssApply","WebComponents","flags","VAR_ASSIGN","MIXIN_MATCH","VAR_CONSUMED","ANIMATION_MATCH","IS_VAR","BRACKETED","HOST_PREFIX","HOST_SUFFIX","SCOPE_NAME","StyleTransformer","dom","shouldRemoveScope","__styleScoped","_transformDom","classList","_content","_element","remove","CLASS","elementStyles","styleRules","cssBuildType","__cssBuild","css","is","extends","ext","hostScope","_calcHostScope","_calcElementScope","isScoped","CSS_CLASS_PREFIX","_rule","_transformRule","_transformComplexSelector","transformer","transformedSelector","_transformRuleCss","COMPLEX_SELECTOR_SEP","_this","stop","NTH","SLOTTED_START","HOST","SIMPLE_SELECTOR_SEP","info","_transformCompoundSelector","combinator","slottedIndex","SLOTTED","_transformHostSelector","_transformSimpleSelector","slotted","SLOTTED_PAREN","paren","DIR_PAREN","before","dir","PSEUDO_PREFIX","HOST_PAREN","SIMPLE_SELECTOR_PREFIX","typeSelector","SELECTOR_NO_MATCH","documentRule","normalizeRootSelector","_transformDocumentSelector","ROOT","SCOPE_DOC_SELECTOR","RegExp","classCallCheck","createClass","toConsumableArray","arr2","StyleInfo","ast","placeholder","ownStylePropertyNames","elementName","typeExtension","cssBuild","overrideStyleProperties","styleProperties","scopeSelector","customStyle","__styleInfo","styleInfo","IS_IE","StyleProperties","decorateStyles","keyframes","ruleIndex","decorateRule","collectPropertiesInCssText","propertyInfo","_keyframes","names","properties","hasProperties","collectProperties","collectCssText","rx$$1","any","exec","assign","collectConsumingCssText","reify","valueForProperty","valueForProperties","propertyValue","_p","parts","lastIndex","colon","pp","slice","applyProperties","output","applyKeyframeTransforms","keyframeTransforms","hasAnimations","transform","keyframeNamesToTransform","keyframe","propertyDataFromStyles","selectorToMatch","whenHostOrRootRule","isRoot","isHost","hostAndRootPropertiesForScope","hostProps","rootProps","transformStyles","hostSelector","rxHostSelector","hostRx","_elementKeyframeTransforms","_scopeSelector","keyframesRules","_scopeKeyframes","_keyframesRuleTransformer","keyframesNameRx","transformedKeyframesName","scopeId","_p2","applyElementScopeSelector","XSCOPE_NAME","applyElementStyle","_useCount","applyCustomStyle","templateMap","placeholderMap","ce","origDefine","clazz","StyleCache","typeMax","cacheEntry","ownPropertyNames","pn","tagname","styleElement","entry","_validate","APPLY_NAME_CLEAN","INITIAL_INHERIT","MIXIN_VAR_SEP","MixinMap","_map","dependants","ApplyShim","_currentTemplate","_measureElement","_separator","_boundProduceCssProperties","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","transformRules","_this2","transformRule","__applyShimInvalid","transformCssText","_consumeCssProperties","all","getComputedStyle","getPropertyValue","mixinName","applyPos","afterApplyPos","textBeforeApply","textAfterApply","defaults$$1","_cssTextToMap","replacement","_atApplyToCssProperties","fallbacks","vars","mixinEntry","_getInitialValueForProperty","sp","out","_replaceInitialOrInherit","_this3","mixinAsProperties","mixinValues","combinedProps","oldProps","needToInvalidate","_invalidateMixinEntry","applyShim","handler","mxns","x","mxn","_i","_n","classIdx","_scope","startState","body","styleCache","scopeCounter","nativeCss","_documentOwner","_documentOwnerStyleInfo","_generateScopeSelector","getStyleAst","styleAstToString","_gatherStyles","template","styles","_getCssBuild","prepareTemplate","_prepared","_styleAst","_generateStaticStyle","_style","_ownPropertyNames","shadowroot","_prepareHost","_cssBuild","applyStyle","overrideProps","CS","_documentDirty","findStyles","_revalidateApplyShim","_updateProperties","applyStyles","_updateNativeProperties","_applyStyleProperties","_isRootOwner","_applyToDescendants","_styleOwnerForNode","fetch","cachedScopeSelector","cachedStyle","oldScopeSelector","store","owner","ownerStyleInfo","ownerProperties","hostAndRootProps","propertyData","propertiesMatchingHost","_mixinOverrideStyles","overrides","removeProperty","setProperty","_transformCustomStyleForDocument","_applyCustomStyleToDocument","getComputedStyleValue","classString","_element$classList","_styleInfoForNode","hookFn","processHook","_customStyles","_findStyle","_applyStyle","__appliedElement","global","incrementalDom","keys","_ref","_ref$enumOnly","enumOnly","listOfKeys","getOwnPropertySymbols","def","_len","args","_key","unshift","enter","saved","exit","applyEvent","elem","ename","newFunc","events","$currentEventHandlers","resolveTagName","name$$1","elementOpenStart","tag","statics","overrideArgs","elementOpenEnd","newElementOpen","wrapIdomFunc","func","tnameFuncHandler","noop","wrap","stackCurrentHelper","stackChren","elementOpen$1","skips","$skip","elementClose","skip","_elem","ref$$1","ref$1","newAttr","_len2","_key2","$stackCurrentHelperProps","stackOpen","tname","props$$1","_len3","_key3","stackClose","chren","elemOrFn","newElementVoid","_len4","_key4","newElementClose","atype","_typeof","_len5","_key5","newElementOpenStart","newElementOpenEnd","ch","ctype","newText","sch","builder","_len6","tags","_key6","_len7","_key7","_len8","_key8","createSymbol","description","Symbol","microtaskDebounce","cbFunc","cbArgs","taskDebounce","setTimeout","setCtorNativeProperty","Ctor","propName","getPropsMap","ctorPropsMap","propsMap","reduce","propNameOrSymbol","get$2","set$2","newProps","renderer$1","getDefaultValue","getInitialValue","initial","getPropData","elemData","syncFirstTimeProp","propData","syncAttrValue","lastAssignedValue","empty","serialize","syncingAttribute","syncExistingProp","settingAttribute","internalValue","serializedValue","currentAttrValue","serializedIsEmpty","attributeChanged","shouldRemoveAttribute","syncPropToAttr","isFirstSync","createNativePropertyDefinition","created","dashCase","initialValue","deserialize","coerce","changeData","rendererDebounced","connected","preventDoubleCalling","_prevName","_prevOldValue","_prevNewValue","syncPropsToAttrs","ensurePropertyFunctions","descriptorName","initProps","ensurePropertyDefinitions","createInitProps","hasPropBeforeUpgrading","valueBeforeUpgrading","uniqueId","rand","random","toString","createCustomEvent","detail","initCustomEvent","getValue","checked","arg","val","alwaysUndefinedIfNotANumberOrNumber","isNaN","Number","alwaysUndefinedIfEmptyOrString","String","array","JSON","boolean","number","freeze","created$1","ctorCreateInitProps","ctorObservedAttributes","ctorProps","rendering","updated$1","symbols$1","propContext","iterator","AwaitValue","AsyncGenerator","gen","send","request","back","front","resume","settle","done","err","_invoke","return","asyncIterator","throw","await","get$1","inherits","possibleConstructorReturn","applyDefault","symbols","attributesContext","applyProp","disabled","ref","firstChar","eventName","toUpperCase","elementOpen","vdom","elementVoid","namespace","__SKATE_DATA","one","two","dash","nativeHints","native","hint","debounce","getOwnPropertyDescriptors","prev","curr","props$1","HTMLElement$1","_class2","_HTMLElement","propConfigsCount","renderCallback","readyCallbacks","attrsOnCtor","attrsFromLinkedProps","item","attached","detached","propOpts","newPropVal","updated","rendered","renderer","rendererCallback","renderedCallback","updatedCallback","definition","_Base","prot","allKeys","mode","patchInner","possibleFn","TheEvent","emit","link","localTarget","firstPart","ready","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMap","keyMapValid","Context","notifications","nodesCreated","deleted","nodesDeleted","initData","getData","getNamespace","applyAttr","el","attrNS","setAttributeNS","elStyle","applyAttributeTyped","updateAttribute","mutator","getNamespaceForTag","namespaceURI","createText","createKeyMap","getKeyMap","getChild","registerChild","markCreated","markDeleted","notifyChanges","context","patchFactory","run","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","enterNode","exitNode","patchOuter","alignWithDOM","clearUnvisitedDOM","coreElementOpen","coreElementClose","coreText","currentElement","ATTRIBUTES_OFFSET","argsBuilder","const_args","attrsChanged","_attr","elementPlaceholder","formatted"],"mappings":"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","file":"dist/index-with-deps.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"componentSvgImport\"] = factory();\n\telse\n\t\troot[\"componentSvgImport\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"componentSvgImport\"] = factory();\n\telse\n\t\troot[\"componentSvgImport\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\t__webpack_require__(1);\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar React = { createElement: _skatejs.h };\n\t\n\tcustomElements.define('svg-import', function (_Component) {\n\t\t_inherits(_class, _Component);\n\t\n\t\tfunction _class() {\n\t\t\t_classCallCheck(this, _class);\n\t\n\t\t\treturn _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));\n\t\t}\n\t\n\t\t_createClass(_class, [{\n\t\t\tkey: 'updateXml',\n\t\t\tvalue: function updateXml() {\n\t\t\t\tif (!jQuery) {\n\t\t\t\t\tthrow new TypeError('svg-import require jQuery to work!');\n\t\t\t\t}\n\t\t\t\tvar comp = this;\n\t\n\t\t\t\tvar $ = jQuery;\n\t\n\t\t\t\t$.get({ url: this.src, cache: true, async: true }).then(function (xml) {\n\t\n\t\t\t\t\tvar $svg = $(xml).find('svg');\n\t\t\t\t\tvar svg = $svg.get(0);\n\t\t\t\t\tsvg.removeAttribute('xmlns:a');\n\t\t\t\t\tif (comp.width && comp.height) {\n\t\t\t\t\t\t// svg.hasAttribute('viewBox') ? svg.setAttribute('viewBox', '0 0 ' + comp.height + ' ' + comp.width) : '';\n\t\t\t\t\t\tsvg.setAttribute('width', '100%');\n\t\t\t\t\t\tsvg.setAttribute('height', '100%');\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// comp.xmlData = $svg.clone().wrap('<div/>').parent().html();\n\t\t\t\t\tvar wraper = $(comp.shadowRoot).find('.svg-import-wrap').get(0);\n\t\n\t\t\t\t\twraper.innerHTML = '';\n\t\t\t\t\twraper.appendChild(svg);\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'connectedCallback',\n\t\t\tvalue: function connectedCallback() {\n\t\t\t\t// Ensure we call the parent.\n\t\t\t\t_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);\n\t\t\t\t//this.updateXml();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'attributeChangedCallback',\n\t\t\tvalue: function attributeChangedCallback(name, oldValue, newValue) {\n\t\t\t\t_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'attributeChangedCallback', this).call(this, name, oldValue, newValue);\n\t\t\t\tif (name == 'src') {\n\t\t\t\t\tthis.updateXml();\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'disconnectedCallback',\n\t\t\tvalue: function disconnectedCallback() {\n\t\t\t\t// Ensure we callback the parent.\n\t\t\t\t_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this).call(this);\n\t\n\t\t\t\t// If we didn't clean up after ourselves, we'd continue to render\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'renderCallback',\n\t\t\tvalue: function renderCallback() {\n\t\t\t\t// By separating the strings (and not using template literals or string\n\t\t\t\t// concatenation) it ensures the strings are diffed indepenedently. If\n\t\t\t\t// you select \"Count\" with your mouse, it will not deselect whenr endered.\n\t\t\t\tvar comp = this;\n\t\n\t\t\t\tvar defBoxStyle = '\\n\\t\\t\\t:host{display:inline-block;}\\n\\t\\t\\t.svg-import-wrap{\\n\\t\\t\\t\\toverflow:hidden;\\n\\t\\t\\t\\tmargin:0;\\n\\t\\t\\t\\tpadding:0;\\n\\t\\t\\t\\twidth:100%;\\n\\t\\t\\t\\theight:100%;\\n\\t\\t\\t\\tmin-width:5px;\\n\\t\\t\\t\\tmin-height:5px;\\n\\t\\t\\t\\tdisplay:block;\\n\\t\\t\\t}\\n\\t\\t\\tsvg{\\n\\t\\t\\t\\twidth:100%;\\n\\t\\t\\t\\theight:100%;\\n\\t\\t\\t}\\n\\t\\t';\n\t\n\t\t\t\treturn [(0, _skatejs.h)('style', defBoxStyle + comp['inner-style']), React.createElement('figure', { role: 'image', className: 'svg-import-wrap' })];\n\t\t\t}\n\t\t}], [{\n\t\t\tkey: 'props',\n\t\t\tget: function get() {\n\t\t\t\treturn {\n\t\t\t\t\t// By declaring the property an attribute, we can now pass an initial value\n\t\t\t\t\t// for the count as part of the HTML.\n\t\t\t\t\tsrc: _skatejs.prop.string({ attribute: true }),\n\t\t\t\t\t'inner-style': _skatejs.prop.string({ attribute: true })\n\t\t\t\t};\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn _class;\n\t}(_skatejs.Component));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"skatejsWebComponents\"] = factory();\n\t\telse\n\t\t\troot[\"skatejsWebComponents\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\t\n\t\t// We load the Safari fix first because the custom element polyfill overrides\n\t\t// attachShadow() to observe the shadow root.\n\t\t__webpack_require__(1);\n\t\t\n\t\t// We have to include this first so that it can patch native.\n\t\t__webpack_require__(2);\n\t\t\n\t\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t\t// ShadyDOM polyfill be loaded first.\n\t\t__webpack_require__(3);\n\t\t__webpack_require__(4);\n\t\t__webpack_require__(5);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\tvar _window = window,\n\t\t    HTMLElement = _window.HTMLElement,\n\t\t    MutationObserver = _window.MutationObserver,\n\t\t    navigator = _window.navigator;\n\t\tvar userAgent = navigator.userAgent;\n\t\t\n\t\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\t\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\t\tvar safariVersions = [0, 1].map(function (v) {\n\t\t  return '10.0.' + v;\n\t\t}).concat(['10.0']);\n\t\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\t\n\t\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\t\tfunction fixSafari() {\n\t\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\t\n\t\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t\t  // element as this is the only scenario where styles aren't recalculated.\n\t\t  var moOpts = { childList: true, subtree: true };\n\t\t  var mo = new MutationObserver(function (muts) {\n\t\t    muts.forEach(function (mut) {\n\t\t      var target = mut.target;\n\t\t\n\t\t      if (target.tagName === 'STYLE') {\n\t\t        var nextSibling = target.nextSibling,\n\t\t            parentNode = target.parentNode;\n\t\t\n\t\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t\t        // as it seems that doesn't trigger a recalc.\n\t\t\n\t\t        parentNode.removeChild(target);\n\t\t        parentNode.insertBefore(target, nextSibling);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t\n\t\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t\t  function newAttachShadow(opts) {\n\t\t    var sr = oldAttachShadow.call(this, opts);\n\t\t    mo.observe(sr, moOpts);\n\t\t    return sr;\n\t\t  }\n\t\t\n\t\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t\t    // Ensure polyfills can override it (hoping they call it back).\n\t\t    configurable: true,\n\t\t    enumerable: true,\n\t\t    value: newAttachShadow,\n\t\t    writable: true\n\t\t  });\n\t\t}\n\t\t\n\t\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t\t// fixes the bug.\n\t\tif (patch) {\n\t\t  fixSafari();\n\t\t}\n\t\t\n\t\texports.default = patch;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t\n\t\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\t/*\n\t\t\n\t\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\t Code distributed by Google as part of the polymer project is also\n\t\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\t\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\t\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\t\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\t\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\t\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\t\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\t\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\t\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\t\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\t\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\t\n\t\t//# sourceMappingURL=custom-elements.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar settings = window.ShadyDOM || {};\n\t\t\n\t\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\t\n\t\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\t\n\t\tfunction isShadyRoot(obj) {\n\t\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t\t}\n\t\t\n\t\tvar p = Element.prototype;\n\t\tvar matches = p.matches || p.matchesSelector ||\n\t\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tfunction matchesSelector(element, selector) {\n\t\t  return matches.call(element, selector);\n\t\t}\n\t\t\n\t\tfunction copyOwnProperty(name, source, target) {\n\t\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t\t  if (pd) {\n\t\t    Object.defineProperty(target, name, pd);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction extend(target, source) {\n\t\t  if (target && source) {\n\t\t    var n$ = Object.getOwnPropertyNames(source);\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t\t      copyOwnProperty(n, source, target);\n\t\t    }\n\t\t  }\n\t\t  return target || source;\n\t\t}\n\t\t\n\t\tfunction extendAll(target) {\n\t\t  var sources = [], len = arguments.length - 1;\n\t\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\t\n\t\t  for (var i=0; i < sources.length; i++) {\n\t\t    extend(target, sources[i]);\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tfunction mixin(target, source) {\n\t\t  for (var i in source) {\n\t\t    target[i] = source[i];\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t\t  obj.__proto__ = proto;\n\t\t  return obj;\n\t\t}\n\t\t\n\t\tfunction patchPrototype(obj, mixin) {\n\t\t  var proto = Object.getPrototypeOf(obj);\n\t\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t\t    var patchProto = Object.create(proto);\n\t\t    patchProto.__sourceProto = proto;\n\t\t    extend(patchProto, mixin);\n\t\t    proto.__patchProto = patchProto;\n\t\t  }\n\t\t  setPrototypeOf(obj, proto.__patchProto);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvar common = {};\n\t\t\n\t\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\t\tvar promish;\n\t\tif (window.Promise) {\n\t\t  promish = Promise.resolve();\n\t\t} else {\n\t\t  promish = {\n\t\t    then: function(cb) {\n\t\t      var twiddle = document.createTextNode('');\n\t\t      var observer = new MutationObserver(function() {\n\t\t        observer.disconnect();\n\t\t        cb();\n\t\t      });\n\t\t      observer.observe(twiddle, {characterData: true});\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction newSplice(index, removed, addedCount) {\n\t\t  return {\n\t\t    index: index,\n\t\t    removed: removed,\n\t\t    addedCount: addedCount\n\t\t  };\n\t\t}\n\t\t\n\t\tvar EDIT_LEAVE = 0;\n\t\tvar EDIT_UPDATE = 1;\n\t\tvar EDIT_ADD = 2;\n\t\tvar EDIT_DELETE = 3;\n\t\t\n\t\tvar ArraySplice = {\n\t\t\n\t\t  // Note: This function is *based* on the computation of the Levenshtein\n\t\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t\t  // edits - not one. With Array splices, an update is really a delete\n\t\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t\t  // maximum array items in the original array. For example:\n\t\t  //\n\t\t  //   'xxxx123' -> '123yyyy'\n\t\t  //\n\t\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t\t  // leaves the substring '123' intact.\n\t\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t\t                              old, oldStart, oldEnd) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // \"Deletion\" columns\n\t\t    var rowCount = oldEnd - oldStart + 1;\n\t\t    var columnCount = currentEnd - currentStart + 1;\n\t\t    var distances = new Array(rowCount);\n\t\t\n\t\t    // \"Addition\" rows. Initialize null column.\n\t\t    for (var i = 0; i < rowCount; i++) {\n\t\t      distances[i] = new Array(columnCount);\n\t\t      distances[i][0] = i;\n\t\t    }\n\t\t\n\t\t    // Initialize null row\n\t\t    for (var j = 0; j < columnCount; j++)\n\t\t      distances[0][j] = j;\n\t\t\n\t\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t\t        else {\n\t\t          var north = distances[i$1 - 1][j$1] + 1;\n\t\t          var west = distances[i$1][j$1 - 1] + 1;\n\t\t          distances[i$1][j$1] = north < west ? north : west;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t\n\t\t    return distances;\n\t\t  },\n\t\t\n\t\t  // This starts at the final weight, and walks \"backward\" by finding\n\t\t  // the minimum previous weight recursively until the origin of the weight\n\t\t  // matrix.\n\t\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t\t    var i = distances.length - 1;\n\t\t    var j = distances[0].length - 1;\n\t\t    var current = distances[i][j];\n\t\t    var edits = [];\n\t\t    while (i > 0 || j > 0) {\n\t\t      if (i == 0) {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        continue;\n\t\t      }\n\t\t      if (j == 0) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        continue;\n\t\t      }\n\t\t      var northWest = distances[i - 1][j - 1];\n\t\t      var west = distances[i - 1][j];\n\t\t      var north = distances[i][j - 1];\n\t\t\n\t\t      var min;\n\t\t      if (west < north)\n\t\t        min = west < northWest ? west : northWest;\n\t\t      else\n\t\t        min = north < northWest ? north : northWest;\n\t\t\n\t\t      if (min == northWest) {\n\t\t        if (northWest == current) {\n\t\t          edits.push(EDIT_LEAVE);\n\t\t        } else {\n\t\t          edits.push(EDIT_UPDATE);\n\t\t          current = northWest;\n\t\t        }\n\t\t        i--;\n\t\t        j--;\n\t\t      } else if (min == west) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        current = west;\n\t\t      } else {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        current = north;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    edits.reverse();\n\t\t    return edits;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t   * Splice Projection functions:\n\t\t   *\n\t\t   * A splice map is a representation of how a previous array of items\n\t\t   * was transformed into a new array of items. Conceptually it is a list of\n\t\t   * tuples of\n\t\t   *\n\t\t   *   <index, removed, addedCount>\n\t\t   *\n\t\t   * which are kept in ascending index order of. The tuple represents that at\n\t\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t\t   * from |index|, |addedCount| items were added.\n\t\t   */\n\t\t\n\t\t  /**\n\t\t   * Lacking individual splice mutation information, the minimal set of\n\t\t   * splices can be synthesized given the previous state and final state of an\n\t\t   * array. The basic approach is to calculate the edit distance matrix and\n\t\t   * choose the shortest path through it.\n\t\t   *\n\t\t   * Complexity: O(l * p)\n\t\t   *   l: The length of the current array\n\t\t   *   p: The length of the old array\n\t\t   */\n\t\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t\t                        old, oldStart, oldEnd) {\n\t\t    var prefixCount = 0;\n\t\t    var suffixCount = 0;\n\t\t    var splice;\n\t\t\n\t\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t\t    if (currentStart == 0 && oldStart == 0)\n\t\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\t\n\t\t    if (currentEnd == current.length && oldEnd == old.length)\n\t\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\t\n\t\t    currentStart += prefixCount;\n\t\t    oldStart += prefixCount;\n\t\t    currentEnd -= suffixCount;\n\t\t    oldEnd -= suffixCount;\n\t\t\n\t\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t\t      return [];\n\t\t\n\t\t    if (currentStart == currentEnd) {\n\t\t      splice = newSplice(currentStart, [], 0);\n\t\t      while (oldStart < oldEnd)\n\t\t        splice.removed.push(old[oldStart++]);\n\t\t\n\t\t      return [ splice ];\n\t\t    } else if (oldStart == oldEnd)\n\t\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\t\n\t\t    var ops = this.spliceOperationsFromEditDistances(\n\t\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t\t                               old, oldStart, oldEnd));\n\t\t\n\t\t    splice = undefined;\n\t\t    var splices = [];\n\t\t    var index = currentStart;\n\t\t    var oldIndex = oldStart;\n\t\t    for (var i = 0; i < ops.length; i++) {\n\t\t      switch(ops[i]) {\n\t\t        case EDIT_LEAVE:\n\t\t          if (splice) {\n\t\t            splices.push(splice);\n\t\t            splice = undefined;\n\t\t          }\n\t\t\n\t\t          index++;\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_UPDATE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_ADD:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t          break;\n\t\t        case EDIT_DELETE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    if (splice) {\n\t\t      splices.push(splice);\n\t\t    }\n\t\t    return splices;\n\t\t  },\n\t\t\n\t\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i = 0; i < searchLength; i++)\n\t\t      if (!this$1.equals(current[i], old[i]))\n\t\t        return i;\n\t\t    return searchLength;\n\t\t  },\n\t\t\n\t\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t\t    var index1 = current.length;\n\t\t    var index2 = old.length;\n\t\t    var count = 0;\n\t\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t\t      count++;\n\t\t\n\t\t    return count;\n\t\t  },\n\t\t\n\t\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t\t                            previous.length);\n\t\t  },\n\t\t\n\t\t  equals: function equals(currentValue, previousValue) {\n\t\t    return currentValue === previousValue;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t\t// for now this is stuck on `utils`\n\t\t//import {patchNode} from './patch'\n\t\t// native add/remove\n\t\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\t\tvar nativeAppendChild = Element.prototype.appendChild;\n\t\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\t\n\t\t/**\n\t\t * `tree` is a dom manipulation library used by ShadyDom to\n\t\t * manipulate composed and logical trees.\n\t\t */\n\t\tvar tree = {\n\t\t\n\t\t  // sad but faster than slice...\n\t\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopy: function arrayCopy(a$) {\n\t\t    var l = a$.length;\n\t\t    var copy = new Array(l);\n\t\t    for (var i=0; i < l; i++) {\n\t\t      copy[i] = a$[i];\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes(node) {\n\t\t    tree.Logical.saveChildNodes(node);\n\t\t    if (!tree.Composed.hasParentNode(node)) {\n\t\t      tree.Composed.saveComposedData(node);\n\t\t      //tree.Composed.saveParentNode(node);\n\t\t    }\n\t\t    tree.Composed.saveChildNodes(node);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\ttree.Logical = {\n\t\t\n\t\t  hasParentNode: function hasParentNode(node) {\n\t\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes(node) {\n\t\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes(node) {\n\t\t    // note: we're distinguishing here between undefined and false-y:\n\t\t    // hasChildNodes uses undefined check to see if this element has logical\n\t\t    // children; the false-y check indicates whether or not we should rebuild\n\t\t    // the cached childNodes array.\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      tree.Composed.getChildNodes(node);\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes(node) {\n\t\t    if (!node.__dom.childNodes) {\n\t\t      node.__dom.childNodes = [];\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        node.__dom.childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.childNodes;\n\t\t  },\n\t\t\n\t\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t\t  // element will store firstChild/lastChild, and in case (2), the element\n\t\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t\t  // the mere existence of __dom is not enough to know if the requested\n\t\t  // logical data is available and instead we do an explicit undefined check.\n\t\t  getParentNode: function getParentNode(node) {\n\t\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      this._getFirstElementChild(node) :\n\t\t      tree.Composed.getFirstElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t\t    var n = node.__dom.firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t\t      this._getLastElementChild(node) :\n\t\t      tree.Composed.getLastElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild(node) {\n\t\t    var n = node.__dom.lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t\t      this._getNextElementSibling(node) :\n\t\t      tree.Composed.getNextElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t\t      this._getPreviousElementSibling(node) :\n\t\t      tree.Composed.getPreviousElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  // Capture the list of light children. It's important to do this before we\n\t\t  // start transforming the DOM into \"rendered\" state.\n\t\t  // Children may be added to this list dynamically. It will be treated as the\n\t\t  // source of truth for the light children of the element. This element's\n\t\t  // actual children will be treated as the rendered state once this function\n\t\t  // has been called.\n\t\t  saveChildNodes: function saveChildNodes$1(node) {\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.firstChild;\n\t\t      node.__dom.lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        n.__dom = n.__dom || {};\n\t\t        n.__dom.parentNode = node;\n\t\t        n.__dom.nextSibling = c$[i+1] || null;\n\t\t        n.__dom.previousSibling = c$[i-1] || null;\n\t\t        common.patchNode(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t\t  // already been distributed.\n\t\t  // NOTE: ensure `node` is patched...\n\t\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var c$ = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1._linkNode(c$[i], container, ref_node);\n\t\t      }\n\t\t      // cleanup logical dom in doc fragment.\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t\t      node.__dom.childNodes = null;\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t\t    common.patchNode(node);\n\t\t    ref_node = ref_node || null;\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t\t      container.__dom.lastChild;\n\t\t    if (node.__dom.previousSibling) {\n\t\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.nextSibling = ref_node;\n\t\t    if (node.__dom.nextSibling) {\n\t\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.lastChild = node;\n\t\t      if (!container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.firstChild) {\n\t\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.lastChild) {\n\t\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.previousSibling;\n\t\t    var n = node.__dom.nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.previousSibling = p;\n\t\t    }\n\t\t    // When an element is removed, logical data is no longer tracked.\n\t\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t\t    // from `null` which is set if info is null.\n\t\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t\t      node.__dom.nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\t\n\t\t// TODO(sorvell): composed tree manipulation is made available\n\t\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t\t// to the tree for optional patching pluggability.\n\t\ttree.Composed = {\n\t\t\n\t\t  hasParentNode: function hasParentNode$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes$1(node) {\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes$1(node) {\n\t\t    if (!node.__dom.$childNodes) {\n\t\t      node.__dom.$childNodes = [];\n\t\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t\t        node.__dom.$childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getParentNode: function getParentNode$1(node) {\n\t\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t\t      (!node.__patched && node.parentNode);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t\t    return node.__patched ? this._getFirstElementChild(node) :\n\t\t      node.firstElementChild;\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t\t    var n = node.__dom.$firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild$1(node) {\n\t\t    return node.__patched ? this._getLastElementChild(node) :\n\t\t      node.lastElementChild;\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t\t    var n = node.__dom.$lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t\t    return node.__patched ? this._getNextElementSibling(node) :\n\t\t      node.nextElementSibling;\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t\t      node.previousElementSibling;\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes$2(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.$firstChild = node.firstChild;\n\t\t      node.__dom.$lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        this$1.saveComposedData(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveComposedData: function saveComposedData(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    if (node.__dom.$parentNode === undefined) {\n\t\t      node.__dom.$parentNode = node.parentNode;\n\t\t    }\n\t\t    if (node.__dom.$nextSibling === undefined) {\n\t\t      node.__dom.$nextSibling = node.nextSibling;\n\t\t    }\n\t\t    if (node.__dom.$previousSibling === undefined) {\n\t\t      node.__dom.$previousSibling = node.previousSibling;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.$childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      // TODO(sorvell): remember this for patching:\n\t\t      // the act of setting this info can affect patched nodes\n\t\t      // getters; therefore capture childNodes before patching.\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        this$1._linkNode(n, container, ref_node);\n\t\t      }\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t\t      container.__dom.$lastChild;\n\t\t    if (node.__dom.$previousSibling) {\n\t\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.$nextSibling = ref_node;\n\t\t    if (node.__dom.$nextSibling) {\n\t\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.$parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.$lastChild = node;\n\t\t      if (!container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.$firstChild) {\n\t\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.$lastChild) {\n\t\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.$previousSibling;\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.$nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.$previousSibling = p;\n\t\t    }\n\t\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t\t      node.__dom.$nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  clearChildNodes: function clearChildNodes(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = this.getChildNodes(node);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      this$1.recordRemoveChild(c, node);\n\t\t      nativeRemoveChild.call(node, c)\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveParentNode: function saveParentNode(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    node.__dom.$parentNode = node.parentNode;\n\t\t  },\n\t\t\n\t\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    // remove from current location.\n\t\t    this._addChild(parentNode, newChild, refChild);\n\t\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t\t  },\n\t\t\n\t\t  appendChild: function appendChild(parentNode, newChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._addChild(parentNode, newChild);\n\t\t    return nativeAppendChild.call(parentNode, newChild);\n\t\t  },\n\t\t\n\t\t  removeChild: function removeChild(parentNode, node) {\n\t\t    var currentParent = this.getParentNode(node);\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._removeChild(parentNode, node);\n\t\t    if (currentParent === parentNode) {\n\t\t      return nativeRemoveChild.call(parentNode, node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var oldParent = this.getParentNode(newChild);\n\t\t    if (oldParent) {\n\t\t      this._removeChild(oldParent, newChild);\n\t\t    }\n\t\t    if (isFrag) {\n\t\t      var c$ = this.getChildNodes(newChild);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        var c = c$[i];\n\t\t        // unlink document fragment children\n\t\t        this$1._removeChild(newChild, c);\n\t\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t\t      }\n\t\t    } else {\n\t\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeChild: function _removeChild(parentNode, node) {\n\t\t    this.recordRemoveChild(node, parentNode);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\t// for testing...\n\t\tvar descriptors = {};\n\t\tfunction getNativeProperty(element, property) {\n\t\t  if (!descriptors[property]) {\n\t\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t\t      HTMLElement.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Element.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Node.prototype, property);\n\t\t  }\n\t\t  return descriptors[property].get.call(element);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// NOTE: normalize event contruction where necessary (IE11)\n\t\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t\t  function(inType, params) {\n\t\t    params = params || {};\n\t\t    var e = document.createEvent('Event');\n\t\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t\t    return e;\n\t\t  };\n\t\t\n\t\tvar Distributor = (function () {\n\t\t  function anonymous(root) {\n\t\t    this.root = root;\n\t\t    this.insertionPointTag = 'slot';\n\t\t  }\n\t\t\n\t\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t\t    return Boolean(this.root._insertionPoints &&\n\t\t      this.root._insertionPoints.length);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t\t    return node.localName && node.localName == this.insertionPointTag;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distribute = function distribute () {\n\t\t    if (this.hasInsertionPoint()) {\n\t\t      return this.distributePool(this.root, this.collectPool());\n\t\t    }\n\t\t    return [];\n\t\t  };\n\t\t\n\t\t  // Gather the pool of nodes that should be distributed. We will combine\n\t\t  // these with the \"content root\" to arrive at the composed tree.\n\t\t  anonymous.prototype.collectPool = function collectPool () {\n\t\t    return tree.arrayCopy(\n\t\t      tree.Logical.getChildNodes(this.root.host));\n\t\t  };\n\t\t\n\t\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t\t  // instead elements are distributed into storage\n\t\t  // array where applicable.\n\t\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var dirtyRoots = [];\n\t\t    var p$ = this.root._insertionPoints;\n\t\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t\t      this$1.distributeInsertionPoint(p, pool);\n\t\t      // provoke redistribution on insertion point parents\n\t\t      // must do this on all candidate hosts since distribution in this\n\t\t      // scope invalidates their distribution.\n\t\t      // only get logical parent.\n\t\t      var parent = tree.Logical.getParentNode(p);\n\t\t      if (parent && parent.shadyRoot &&\n\t\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t\t        dirtyRoots.push(parent.shadyRoot);\n\t\t      }\n\t\t    }\n\t\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t\t      var p$1 = pool[i$1];\n\t\t      if (p$1) {\n\t\t        p$1._assignedSlot = undefined;\n\t\t        // remove undistributed elements from physical dom.\n\t\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t\t        if (parent$1) {\n\t\t          tree.Composed.removeChild(parent$1, p$1);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return dirtyRoots;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t\t    if (prevAssignedNodes) {\n\t\t      this.clearAssignedSlots(insertionPoint, true);\n\t\t    }\n\t\t    insertionPoint._assignedNodes = [];\n\t\t    var needsSlotChange = false;\n\t\t    // distribute nodes from the pool that this selector matches\n\t\t    var anyDistributed = false;\n\t\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t\t      node=pool[i];\n\t\t      // skip nodes that were already used\n\t\t      if (!node) {\n\t\t        continue;\n\t\t      }\n\t\t      // distribute this node if it matches\n\t\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node, insertionPoint)\n\t\t        // remove this node from the pool\n\t\t        pool[i] = undefined;\n\t\t        // since at least one node matched, we won't need fallback content\n\t\t        anyDistributed = true;\n\t\t      }\n\t\t    }\n\t\t    // Fallback content if nothing was distributed here\n\t\t    if (!anyDistributed) {\n\t\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t\t      for (var j = 0, node$1; j < children.length; j++) {\n\t\t        node$1 = children[j];\n\t\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t\t      }\n\t\t    }\n\t\t    // we're already dirty if a node was newly added to the slot\n\t\t    // and we're also dirty if the assigned count decreased.\n\t\t    if (prevAssignedNodes) {\n\t\t      // TODO(sorvell): the tracking of previously assigned slots\n\t\t      // could instead by done with a Set and then we could\n\t\t      // avoid needing to iterate here to clear the info.\n\t\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t\t      }\n\t\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t\t        needsSlotChange = true;\n\t\t      }\n\t\t    }\n\t\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t\t    if (needsSlotChange) {\n\t\t      this._fireSlotChange(insertionPoint);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t\t    var n$ = slot._assignedNodes;\n\t\t    if (n$) {\n\t\t      for (var i=0; i < n$.length; i++) {\n\t\t        var n = n$[i];\n\t\t        if (savePrevious) {\n\t\t          n.__prevAssignedSlot = n._assignedSlot;\n\t\t        }\n\t\t        // only clear if it was previously set to this slot;\n\t\t        // this helps ensure that if the node has otherwise been distributed\n\t\t        // ignore it.\n\t\t        if (n._assignedSlot === slot) {\n\t\t          n._assignedSlot = null;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t\t    var slotName = insertionPoint.getAttribute('name');\n\t\t    slotName = slotName ? slotName.trim() : '';\n\t\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t\t    slot = slot ? slot.trim() : '';\n\t\t    return (slot == slotName);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t\t    insertionPoint._assignedNodes.push(child);\n\t\t    child._assignedSlot = insertionPoint;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n$ = insertionPoint._assignedNodes;\n\t\t    insertionPoint._distributedNodes = [];\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t\t      if (this$1.isInsertionPoint(n)) {\n\t\t        var d$ = n._distributedNodes;\n\t\t        if (d$) {\n\t\t          for (var j=0; j < d$.length; j++) {\n\t\t            insertionPoint._distributedNodes.push(d$[j]);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        insertionPoint._distributedNodes.push(n$[i]);\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t\t    // Safari tech preview does not bubble but chrome does\n\t\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t\t    if (insertionPoint._assignedSlot) {\n\t\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t\t    return !(insertionPoint._assignedSlot);\n\t\t  };\n\t\t\n\t\t  return anonymous;\n\t\t}())\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t\t  polyfill across browsers.\n\t\t*/\n\t\tvar ShadyRoot = function ShadyRoot(host) {\n\t\t  if (!host) {\n\t\t    throw 'Must provide a host';\n\t\t  }\n\t\t  // NOTE: this strange construction is necessary because\n\t\t  // DocumentFragment cannot be subclassed on older browsers.\n\t\t  var frag = document.createDocumentFragment();\n\t\t  frag.__proto__ = ShadyFragmentMixin;\n\t\t  frag._init(host);\n\t\t  return frag;\n\t\t};\n\t\t\n\t\tvar ShadyMixin = {\n\t\t\n\t\t  _init: function _init(host) {\n\t\t    // NOTE: set a fake local name so this element can be\n\t\t    // distinguished from a DocumentFragment when patching.\n\t\t    // FF doesn't allow this to be `localName`\n\t\t    this.__localName = 'ShadyRoot';\n\t\t    // root <=> host\n\t\t    host.shadyRoot = this;\n\t\t    this.host = host;\n\t\t    // logical dom setup\n\t\t    tree.Logical.saveChildNodes(host);\n\t\t    tree.Logical.saveChildNodes(this);\n\t\t    // state flags\n\t\t    this._clean = true;\n\t\t    this._hasRendered = false;\n\t\t    this._distributor = new Distributor(this);\n\t\t    this.update();\n\t\t  },\n\t\t\n\t\t  // async render the \"top\" distributor (this is all that is needed to\n\t\t  // distribute this host).\n\t\t  update: function update() {\n\t\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t\t    if (distributionRoot._clean) {\n\t\t      distributionRoot._clean = false;\n\t\t      enqueue(function() {\n\t\t        distributionRoot.render();\n\t\t      });\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t\t  // this should only return a shadowRoot.\n\t\t  // returns the host that's the top of this host's distribution tree\n\t\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t\t    var root = element.shadyRoot;\n\t\t    while (element && this._elementNeedsDistribution(element)) {\n\t\t      root = element.getRootNode();\n\t\t      element = root && root.host;\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  // Return true if a host's children includes\n\t\t  // an insertion point that selects selectively\n\t\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = tree.Logical.getChildNodes(element);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t\t        return element.getRootNode();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  render: function render() {\n\t\t    if (!this._clean) {\n\t\t      this._clean = true;\n\t\t      if (!this._skipUpdateInsertionPoints) {\n\t\t        this.updateInsertionPoints();\n\t\t      } else if (!this._hasRendered) {\n\t\t        this._insertionPoints = [];\n\t\t      }\n\t\t      this._skipUpdateInsertionPoints = false;\n\t\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t\t      // that would avoid distribution for initial render if\n\t\t      // no insertion points exist. We cannot currently do this because\n\t\t      // it relies on elements being in the physical shadowRoot element\n\t\t      // so that native methods will be used. The current append code\n\t\t      // simply provokes distribution in this case and does not put the\n\t\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t\t      // consider if the special processing is worth the perf gain.\n\t\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t\t      //   tree.Composed.clearChildNodes(this.host);\n\t\t      //   tree.Composed.appendChild(this.host, this);\n\t\t      // } else {\n\t\t      // logical\n\t\t      this.distribute();\n\t\t      // physical\n\t\t      this.compose();\n\t\t      this._hasRendered = true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  forceRender: function forceRender() {\n\t\t    this._clean = false;\n\t\t    this.render();\n\t\t  },\n\t\t\n\t\t  distribute: function distribute() {\n\t\t    var dirtyRoots = this._distributor.distribute();\n\t\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t\t      dirtyRoots[i].forceRender();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  updateInsertionPoints: function updateInsertionPoints() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var i$ = this.__insertionPoints;\n\t\t    // if any insertion points have been removed, clear their distribution info\n\t\t    if (i$) {\n\t\t      for (var i=0, c; i < i$.length; i++) {\n\t\t        c = i$[i];\n\t\t        if (c.getRootNode() !== this$1) {\n\t\t          this$1._distributor.clearAssignedSlots(c);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t\t    // ensure insertionPoints's and their parents have logical dom info.\n\t\t    // save logical tree info\n\t\t    // a. for shadyRoot\n\t\t    // b. for insertion points (fallback)\n\t\t    // c. for parents of insertion points\n\t\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t\t      c$1 = i$[i$1];\n\t\t      tree.Logical.saveChildNodes(c$1);\n\t\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  get _insertionPoints() {\n\t\t    if (!this.__insertionPoints) {\n\t\t      this.updateInsertionPoints();\n\t\t    }\n\t\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t\t  },\n\t\t\n\t\t  set _insertionPoints(insertionPoints) {\n\t\t    this.__insertionPoints = insertionPoints;\n\t\t  },\n\t\t\n\t\t  hasInsertionPoint: function hasInsertionPoint() {\n\t\t    return this._distributor.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  compose: function compose() {\n\t\t    // compose self\n\t\t    // note: it's important to mark this clean before distribution\n\t\t    // so that attachment that provokes additional distribution (e.g.\n\t\t    // adding something to your parentNode) works\n\t\t    this._composeTree();\n\t\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t\t    // (these seem unnecessary)\n\t\t  },\n\t\t\n\t\t  // Reify dom such that it is at its correct rendering position\n\t\t  // based on logical distribution.\n\t\t  _composeTree: function _composeTree() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t\t    var p$ = this._insertionPoints || [];\n\t\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t\t      parent = tree.Logical.getParentNode(p);\n\t\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // Returns the list of nodes which should be rendered inside `node`.\n\t\t  _composeNode: function _composeNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var children = [];\n\t\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t\t    for (var i = 0; i < c$.length; i++) {\n\t\t      var child = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t\t        var distributedNodes = child._distributedNodes ||\n\t\t          (child._distributedNodes = []);\n\t\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t\t          var distributedNode = distributedNodes[j];\n\t\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t\t            children.push(distributedNode);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        children.push(child);\n\t\t      }\n\t\t    }\n\t\t    return children;\n\t\t  },\n\t\t\n\t\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t\t    return this._distributor.isFinalDestination(\n\t\t      insertionPoint, node);\n\t\t  },\n\t\t\n\t\t  // Ensures that the rendered node list inside `container` is `children`.\n\t\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t\t    var composed = tree.Composed.getChildNodes(container);\n\t\t    var splices = calculateSplices(children, composed);\n\t\t    // process removals\n\t\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t\t        // check if the node is still where we expect it is before trying\n\t\t        // to remove it; this can happen if we move a node and\n\t\t        // then schedule its previous host for distribution resulting in\n\t\t        // the node being removed here.\n\t\t        if (tree.Composed.getParentNode(n) === container) {\n\t\t          tree.Composed.removeChild(container, n);\n\t\t        }\n\t\t        composed.splice(s.index + d, 1);\n\t\t      }\n\t\t      d -= s.addedCount;\n\t\t    }\n\t\t    // process adds\n\t\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t\t      next = composed[s$1.index];\n\t\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t\t        n$1 = children[j$1];\n\t\t        tree.Composed.insertBefore(container, n$1, next);\n\t\t        // TODO(sorvell): is this splice strictly needed?\n\t\t        composed.splice(j$1, 0, n$1);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  getInsertionPointTag: function getInsertionPointTag() {\n\t\t    return this._distributor.insertionPointTag;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\t\textend(ShadyFragmentMixin, ShadyMixin);\n\t\t\n\t\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\t\n\t\t// function upgradeLogicalChildren(children) {\n\t\t//   if (needsUpgrade && children) {\n\t\t//     for (let i=0; i < children.length; i++) {\n\t\t//       CustomElements.upgrade(children[i]);\n\t\t//     }\n\t\t//   }\n\t\t// }\n\t\t\n\t\t// render enqueuer/flusher\n\t\tvar customElements = window.customElements;\n\t\tvar flushList = [];\n\t\tvar scheduled;\n\t\tvar flushCount = 0;\n\t\tvar flushMax = 100;\n\t\tfunction enqueue(callback) {\n\t\t  if (!scheduled) {\n\t\t    scheduled = true;\n\t\t    promish.then(flush$1);\n\t\t  }\n\t\t  flushList.push(callback);\n\t\t}\n\t\t\n\t\tfunction flush$1() {\n\t\t  scheduled = false;\n\t\t  flushCount++;\n\t\t  while (flushList.length) {\n\t\t    flushList.shift()();\n\t\t  }\n\t\t  if (customElements && customElements.flush) {\n\t\t    customElements.flush();\n\t\t  }\n\t\t  // continue flushing after elements are upgraded...\n\t\t  var isFlushedMaxed = (flushCount > flushMax);\n\t\t  if (flushList.length && !isFlushedMaxed) {\n\t\t      flush$1();\n\t\t  }\n\t\t  flushCount = 0;\n\t\t  if (isFlushedMaxed) {\n\t\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t\t  }\n\t\t}\n\t\t\n\t\tflush$1.list = flushList;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// Cribbed from ShadowDOM polyfill\n\t\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t\t/////////////////////////////////////////////////////////////////////////////\n\t\t// innerHTML and outerHTML\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\t\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\t\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\t\n\t\tfunction escapeReplace(c) {\n\t\t  switch (c) {\n\t\t    case '&':\n\t\t      return '&amp;';\n\t\t    case '<':\n\t\t      return '&lt;';\n\t\t    case '>':\n\t\t      return '&gt;';\n\t\t    case '\"':\n\t\t      return '&quot;';\n\t\t    case '\\u00A0':\n\t\t      return '&nbsp;';\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction escapeAttr(s) {\n\t\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction escapeData(s) {\n\t\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction makeSet(arr) {\n\t\t  var set = {};\n\t\t  for (var i = 0; i < arr.length; i++) {\n\t\t    set[arr[i]] = true;\n\t\t  }\n\t\t  return set;\n\t\t}\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\t\tvar voidElements = makeSet([\n\t\t  'area',\n\t\t  'base',\n\t\t  'br',\n\t\t  'col',\n\t\t  'command',\n\t\t  'embed',\n\t\t  'hr',\n\t\t  'img',\n\t\t  'input',\n\t\t  'keygen',\n\t\t  'link',\n\t\t  'meta',\n\t\t  'param',\n\t\t  'source',\n\t\t  'track',\n\t\t  'wbr'\n\t\t]);\n\t\t\n\t\tvar plaintextParents = makeSet([\n\t\t  'style',\n\t\t  'script',\n\t\t  'xmp',\n\t\t  'iframe',\n\t\t  'noembed',\n\t\t  'noframes',\n\t\t  'plaintext',\n\t\t  'noscript'\n\t\t]);\n\t\t\n\t\tfunction getOuterHTML(node, parentNode, composed) {\n\t\t  switch (node.nodeType) {\n\t\t    case Node.ELEMENT_NODE: {\n\t\t      var tagName = node.localName;\n\t\t      var s = '<' + tagName;\n\t\t      var attrs = node.attributes;\n\t\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t\t      }\n\t\t      s += '>';\n\t\t      if (voidElements[tagName]) {\n\t\t        return s;\n\t\t      }\n\t\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t\t    }\n\t\t    case Node.TEXT_NODE: {\n\t\t      var data = node.data;\n\t\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t\t        return data;\n\t\t      }\n\t\t      return escapeData(data);\n\t\t    }\n\t\t    case Node.COMMENT_NODE: {\n\t\t      return '<!--' + node.data + '-->';\n\t\t    }\n\t\t    default: {\n\t\t      window.console.error(node);\n\t\t      throw new Error('not implemented');\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction getInnerHTML(node, composed) {\n\t\t  if (node.localName === 'template') {\n\t\t    node = node.content;\n\t\t  }\n\t\t  var s = '';\n\t\t  var c$ = composed ? composed(node) : node.childNodes;\n\t\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t\t    s += getOuterHTML(child, node, composed);\n\t\t  }\n\t\t  return s;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar mixinImpl = {\n\t\t\n\t\t  // Try to add node. Record logical info, track insertion points, perform\n\t\t  // distribution iff needed. Return true if the add is handled.\n\t\t  addNode: function addNode(container, node, ref_node) {\n\t\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t\t    if (ownerRoot) {\n\t\t      // optimization: special insertion point tracking\n\t\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t\t      }\n\t\t      // note: we always need to see if an insertion point is added\n\t\t      // since this saves logical tree info; however, invalidation state\n\t\t      // needs\n\t\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t\t      // invalidate insertion points IFF not already invalid!\n\t\t      if (ipAdded) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t      }\n\t\t    }\n\t\t    if (tree.Logical.hasChildNodes(container)) {\n\t\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t\t    }\n\t\t    // if not distributing and not adding to host, do a fast path addition\n\t\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t\t      container.shadyRoot;\n\t\t    return handled;\n\t\t  },\n\t\t\n\t\t  // Try to remove node: update logical info and perform distribution iff\n\t\t  // needed. Return true if the removal has been handled.\n\t\t  // note that it's possible for both the node's host and its parent\n\t\t  // to require distribution... both cases are handled here.\n\t\t  removeNode: function removeNode(node) {\n\t\t    // important that we want to do this only if the node has a logical parent\n\t\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t\t      tree.Logical.getParentNode(node);\n\t\t    var distributed;\n\t\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t\t    if (logicalParent) {\n\t\t      // distribute node's parent iff needed\n\t\t      distributed = this.maybeDistributeParent(node);\n\t\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t\t      // remove node from root and distribute it iff needed\n\t\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    this._removeOwnerShadyRoot(node);\n\t\t    return distributed;\n\t\t  },\n\t\t\n\t\t\n\t\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t\t    var observer = node.__dom && node.__dom.observer;\n\t\t    if (observer) {\n\t\t      if (addedNode) {\n\t\t        observer.addedNodes.push(addedNode);\n\t\t      }\n\t\t      if (removedNode) {\n\t\t        observer.removedNodes.push(removedNode);\n\t\t      }\n\t\t      observer.schedule();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t\t    if (parent) {\n\t\t      this._scheduleObserver(parent, null, node);\n\t\t      this.removeNode(node);\n\t\t    } else {\n\t\t      this._removeOwnerShadyRoot(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t\t  },\n\t\t\n\t\t  getRootNode: function getRootNode$1(node) {\n\t\t    if (!node || !node.nodeType) {\n\t\t      return;\n\t\t    }\n\t\t    var root = node.__ownerShadyRoot;\n\t\t    if (root === undefined) {\n\t\t      if (isShadyRoot(node)) {\n\t\t        root = node;\n\t\t      } else {\n\t\t        var parent = tree.Logical.getParentNode(node);\n\t\t        root = parent ? this.getRootNode(parent) : node;\n\t\t      }\n\t\t      // memo-ize result for performance but only memo-ize\n\t\t      // result if node is in the document. This avoids a problem where a root\n\t\t      // can be cached while an element is inside a fragment.\n\t\t      // If this happens and we cache the result, the value can become stale\n\t\t      // because for perf we avoid processing the subtree of added fragments.\n\t\t      if (document.documentElement.contains(node)) {\n\t\t        node.__ownerShadyRoot = root;\n\t\t      }\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t\t    var root = this.getRootNode(node);\n\t\t    if (isShadyRoot(root)) {\n\t\t      return root;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t\t    // <content> children but since this case is assumed to be exceedingly\n\t\t    // rare, we avoid the cost and will address with some specific api\n\t\t    // when the need arises.  For now, the user must call\n\t\t    // distributeContent(true), which updates insertion points manually\n\t\t    // and forces distribution.\n\t\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t\t      !node.__noInsertionPoint &&\n\t\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t\t    var wrappedContent = fragContent &&\n\t\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t\t    // There are 3 possible cases where a distribution may need to occur:\n\t\t    // 1. <content> being inserted (the host of the shady root where\n\t\t    //    content is inserted needs distribution)\n\t\t    // 2. children being inserted into parent with a shady root (parent\n\t\t    //    needs distribution)\n\t\t    // 3. container is an insertionPoint\n\t\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t\t      if (ownerRoot) {\n\t\t        // note, insertion point list update is handled after node\n\t\t        // mutations are complete\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    var needsDist = this._nodeNeedsDistribution(container);\n\t\t    if (needsDist) {\n\t\t      container.shadyRoot.update();\n\t\t    }\n\t\t    // Return true when distribution will fully handle the composition\n\t\t    // Note that if a content was being inserted that was wrapped by a node,\n\t\t    // and the parent does not need distribution, return false to allow\n\t\t    // the nodes to be added directly, after which children may be\n\t\t    // distributed and composed into the wrapping node(s)\n\t\t    return needsDist || (hasContent && !wrappedContent);\n\t\t  },\n\t\t\n\t\t  /* note: parent argument is required since node may have an out\n\t\t  of date parent at this point; returns true if a <content> is being added */\n\t\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var added;\n\t\t    var insertionPointTag = root.getInsertionPointTag();\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t\t      !node.__noInsertionPoint) {\n\t\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        np = tree.Logical.getParentNode(n);\n\t\t        // don't allow node's parent to be fragment itself\n\t\t        if (np === node) {\n\t\t          np = parent;\n\t\t        }\n\t\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t\t        added = added || na;\n\t\t      }\n\t\t    } else if (node.localName === insertionPointTag) {\n\t\t      tree.Logical.saveChildNodes(parent);\n\t\t      tree.Logical.saveChildNodes(node);\n\t\t      added = true;\n\t\t    }\n\t\t    return added;\n\t\t  },\n\t\t\n\t\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t\t    return node && node.shadyRoot &&\n\t\t      node.shadyRoot.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var hostNeedsDist;\n\t\t    var ip$ = root._insertionPoints;\n\t\t    for (var i=0; i<ip$.length; i++) {\n\t\t      var insertionPoint = ip$[i];\n\t\t      if (this$1._contains(container, insertionPoint)) {\n\t\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t\t        for (var j=0; j<dc$.length; j++) {\n\t\t          hostNeedsDist = true;\n\t\t          var node = dc$[j];\n\t\t          var parent = tree.Composed.getParentNode(node);\n\t\t          if (parent) {\n\t\t            tree.Composed.removeChild(parent, node);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return hostNeedsDist;\n\t\t  },\n\t\t\n\t\t  _contains: function _contains(container, node) {\n\t\t    while (node) {\n\t\t      if (node == container) {\n\t\t        return true;\n\t\t      }\n\t\t      node = tree.Logical.getParentNode(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // optimization: only reset the tree if node is actually in a root\n\t\t    if (this._hasCachedOwnerRoot(node)) {\n\t\t      var c$ = tree.Logical.getChildNodes(node);\n\t\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t\t        this$1._removeOwnerShadyRoot(n);\n\t\t      }\n\t\t    }\n\t\t    node.__ownerShadyRoot = undefined;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): This will fail if distribution that affects this\n\t\t  // question is pending; this is expected to be exceedingly rare, but if\n\t\t  // the issue comes up, we can force a flush in this case.\n\t\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t\t    var root = this.getRootNode(insertionPoint);\n\t\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t\t      // means that we're composed to this spot.\n\t\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t\t        return n;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  clearNode: function clearNode(node) {\n\t\t    while (node.firstChild) {\n\t\t      node.removeChild(node.firstChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t\t    var parent = tree.Logical.getParentNode(node);\n\t\t    if (this._nodeNeedsDistribution(parent)) {\n\t\t      parent.shadyRoot.update();\n\t\t      return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t\t    if (name === 'slot') {\n\t\t      this.maybeDistributeParent(node);\n\t\t    } else if (node.localName === 'slot' && name === 'name') {\n\t\t      var root = this.ownerShadyRootForNode(node);\n\t\t      if (root) {\n\t\t        root.update();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t\t  // but it's also generally useful to recurse through the element tree\n\t\t  // and is used by Polymer's styling system.\n\t\t  query: function query(node, matcher, halter) {\n\t\t    var list = [];\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t    return list;\n\t\t  },\n\t\t\n\t\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t\t          this$1._queryElement(c, matcher, halter, list)) {\n\t\t        return true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t\t    var result = matcher(node);\n\t\t    if (result) {\n\t\t      list.push(node);\n\t\t    }\n\t\t    if (halter && halter(result)) {\n\t\t      return result;\n\t\t    }\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t  },\n\t\t\n\t\t  activeElementForNode: function activeElementForNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var active = document.activeElement;\n\t\t    if (!active) {\n\t\t      return null;\n\t\t    }\n\t\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t\t    if (node !== document) {\n\t\t      // If this node isn't a document or shady root, then it doesn't have\n\t\t      // an active element.\n\t\t      if (!isShadyRoot$$1) {\n\t\t        return null;\n\t\t      }\n\t\t      // If this shady root's host is the active element or the active\n\t\t      // element is not a descendant of the host (in the composed tree),\n\t\t      // then it doesn't have an active element.\n\t\t      if (node.host === active ||\n\t\t          !node.host.contains(active)) {\n\t\t        return null;\n\t\t      }\n\t\t    }\n\t\t    // This node is either the document or a shady root of which the active\n\t\t    // element is a (composed) descendant of its host; iterate upwards to\n\t\t    // find the active element's most shallow host within it.\n\t\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t\t    while (activeRoot && activeRoot !== node) {\n\t\t      active = activeRoot.host;\n\t\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t\t    }\n\t\t    if (node === document) {\n\t\t      // This node is the document, so activeRoot should be null.\n\t\t      return activeRoot ? null : active;\n\t\t    } else {\n\t\t      // This node is a non-document shady root, and it should be\n\t\t      // activeRoot.\n\t\t      return activeRoot === node ? active : null;\n\t\t    }\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar nativeCloneNode = Element.prototype.cloneNode;\n\t\tvar nativeImportNode = Document.prototype.importNode;\n\t\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\t\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\t\n\t\tvar setAttribute = function(attr, value) {\n\t\t  if (window.ShadyCSS && attr === 'class') {\n\t\t    window.ShadyCSS.setElementClass(this, value);\n\t\t  } else {\n\t\t    nativeSetAttribute.call(this, attr, value);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar NodeMixin = {};\n\t\t\n\t\tObject.defineProperties(NodeMixin, {\n\t\t\n\t\t  parentElement: {\n\t\t    get: function get() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  parentNode: {\n\t\t    get: function get$1() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextSibling: {\n\t\t    get: function get$2() {\n\t\t      return tree.Logical.getNextSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousSibling: {\n\t\t    get: function get$3() {\n\t\t      return tree.Logical.getPreviousSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextElementSibling: {\n\t\t    get: function get$4() {\n\t\t      return tree.Logical.getNextElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousElementSibling: {\n\t\t    get: function get$5() {\n\t\t      return tree.Logical.getPreviousElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  assignedSlot: {\n\t\t    get: function get$6() {\n\t\t      return this._assignedSlot;\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tvar FragmentMixin = {\n\t\t\n\t\t  appendChild: function appendChild(node) {\n\t\t    return this.insertBefore(node);\n\t\t  },\n\t\t\n\t\t  // cases in which we may not be able to just do standard native call\n\t\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t\t  // has an insertion point)\n\t\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t\t  // container to container.host.\n\t\t  // 3. node is <content> (host of container needs distribution)\n\t\t  insertBefore: function insertBefore(node, ref_node) {\n\t\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t\t        'of this node');\n\t\t    }\n\t\t    // remove node from its current position iff it's in a tree.\n\t\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var parent = tree.Logical.getParentNode(node);\n\t\t      mixinImpl.removeNodeFromParent(node, parent);\n\t\t    }\n\t\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t\t      if (ref_node) {\n\t\t        // if ref_node is an insertion point replace with first distributed node\n\t\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t\t        if (root) {\n\t\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t\t        }\n\t\t      }\n\t\t      // if adding to a shadyRoot, add to host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host : this;\n\t\t      if (ref_node) {\n\t\t        tree.Composed.insertBefore(container, node, ref_node);\n\t\t      } else {\n\t\t        tree.Composed.appendChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t    Removes the given `node` from the element's `lightChildren`.\n\t\t    This method also performs dom composition.\n\t\t  */\n\t\t  removeChild: function removeChild(node) {\n\t\t    if (tree.Logical.getParentNode(node) !== this) {\n\t\t      throw Error('The node to be removed is not a child of this node: ' +\n\t\t        node);\n\t\t    }\n\t\t    if (!mixinImpl.removeNode(node)) {\n\t\t      // if removing from a shadyRoot, remove form host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host :\n\t\t        this;\n\t\t      // not guaranteed to physically be in container; e.g.\n\t\t      // undistributed nodes.\n\t\t      var parent = tree.Composed.getParentNode(node);\n\t\t      if (container === parent) {\n\t\t        tree.Composed.removeChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, null, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  replaceChild: function replaceChild(node, ref_node) {\n\t\t    this.insertBefore(node, ref_node);\n\t\t    this.removeChild(ref_node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t\t  querySelector: function querySelector(selector) {\n\t\t    // match selector and halt on first result.\n\t\t    var result = mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    }, function(n) {\n\t\t      return Boolean(n);\n\t\t    })[0];\n\t\t    return result || null;\n\t\t  },\n\t\t\n\t\t  querySelectorAll: function querySelectorAll(selector) {\n\t\t    return mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    });\n\t\t  },\n\t\t\n\t\t  cloneNode: function cloneNode(deep) {\n\t\t    if (this.localName == 'template') {\n\t\t      return nativeCloneNode.call(this, deep);\n\t\t    } else {\n\t\t      var n = nativeCloneNode.call(this, false);\n\t\t      if (deep) {\n\t\t        var c$ = this.childNodes;\n\t\t        for (var i=0, nc; i < c$.length; i++) {\n\t\t          nc = c$[i].cloneNode(true);\n\t\t          n.appendChild(nc);\n\t\t        }\n\t\t      }\n\t\t      return n;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  importNode: function importNode(externalNode, deep) {\n\t\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t\t    var doc = this instanceof Document ? this :\n\t\t      this.ownerDocument;\n\t\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t\t    if (deep) {\n\t\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t\t      common.patchNode(n);\n\t\t      for (var i=0, nc; i < c$.length; i++) {\n\t\t        nc = doc.importNode(c$[i], true);\n\t\t        n.appendChild(nc);\n\t\t      }\n\t\t    }\n\t\t    return n;\n\t\t  }\n\t\t};\n\t\t\n\t\tObject.defineProperties(FragmentMixin, {\n\t\t\n\t\t  childNodes: {\n\t\t    get: function get$7() {\n\t\t      var c$ = tree.Logical.getChildNodes(this);\n\t\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  children: {\n\t\t    get: function get$8() {\n\t\t      if (tree.Logical.hasChildNodes(this)) {\n\t\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t\t        });\n\t\t      } else {\n\t\t        return tree.arrayCopyChildren(this);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstChild: {\n\t\t    get: function get$9() {\n\t\t      return tree.Logical.getFirstChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastChild: {\n\t\t    get: function get$10() {\n\t\t      return tree.Logical.getLastChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstElementChild: {\n\t\t    get: function get$11() {\n\t\t      return tree.Logical.getFirstElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastElementChild: {\n\t\t    get: function get$12() {\n\t\t      return tree.Logical.getLastElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t\t  // textContent / innerHTML\n\t\t  textContent: {\n\t\t    get: function get$13() {\n\t\t      if (this.childNodes) {\n\t\t        var tc = [];\n\t\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t\t            tc.push(c.textContent);\n\t\t          }\n\t\t        }\n\t\t        return tc.join('');\n\t\t      }\n\t\t      return '';\n\t\t    },\n\t\t    set: function set(text) {\n\t\t      mixinImpl.clearNode(this);\n\t\t      if (text) {\n\t\t        this.appendChild(document.createTextNode(text));\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  innerHTML: {\n\t\t    get: function get$14() {\n\t\t      return getInnerHTML(this);\n\t\t    },\n\t\t    set: function set$1(text) {\n\t\t      var this$1 = this;\n\t\t\n\t\t      mixinImpl.clearNode(this);\n\t\t      var d = document.createElement('div');\n\t\t      d.innerHTML = text;\n\t\t      // here, appendChild may move nodes async so we cannot rely\n\t\t      // on node position when copying\n\t\t      var c$ = tree.arrayCopyChildNodes(d);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1.appendChild(c$[i]);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar ElementMixin = {\n\t\t\n\t\t  // TODO(sorvell): should only exist on <slot>\n\t\t  assignedNodes: function assignedNodes(options) {\n\t\t    return (options && options.flatten ? this._distributedNodes :\n\t\t      this._assignedNodes) || [];\n\t\t  },\n\t\t\n\t\t\n\t\t  setAttribute: function setAttribute$1(name, value) {\n\t\t    setAttribute.call(this, name, value);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  },\n\t\t\n\t\t  removeAttribute: function removeAttribute(name) {\n\t\t    nativeRemoveAttribute.call(this, name);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tObject.defineProperties(ElementMixin, {\n\t\t\n\t\t  shadowRoot: {\n\t\t    get: function get$15() {\n\t\t      return this.shadyRoot;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  slot: {\n\t\t    get: function get$16() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set$2(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar activeElementDescriptor = {\n\t\t  get: function get$17() {\n\t\t    return mixinImpl.activeElementForNode(this);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar ActiveElementMixin = {};\n\t\tObject.defineProperties(ActiveElementMixin, {\n\t\t  activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar UnderActiveElementMixin = {};\n\t\tObject.defineProperties(UnderActiveElementMixin, {\n\t\t  _activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar Mixins = {\n\t\t\n\t\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\t\n\t\t  Fragment: extendAll({__patched: 'Fragment'},\n\t\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\t\n\t\t  Element: extendAll({__patched: 'Element'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\t\n\t\t  // Note: activeElement cannot be patched on document!\n\t\t  Document: extendAll({__patched: 'Document'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\t\n\t\t};\n\t\t\n\t\tvar getRootNode = function(node) {\n\t\t  return mixinImpl.getRootNode(node);\n\t\t}\n\t\t\n\t\tfunction filterMutations(mutations, target) {\n\t\t  var targetRootNode = getRootNode(target);\n\t\t  return mutations.filter(function(mutation) {\n\t\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t\t    if (mutationInScope && mutation.addedNodes) {\n\t\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t\t        return (targetRootNode === getRootNode(n));\n\t\t      });\n\t\t      Object.defineProperty(mutation, 'addedNodes', {\n\t\t        value: nodes,\n\t\t        configurable: true\n\t\t      });\n\t\t    }\n\t\t    return mutationInScope &&\n\t\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t\t  });\n\t\t}\n\t\t\n\t\t// const promise = Promise.resolve();\n\t\t\n\t\tvar AsyncObserver = function AsyncObserver() {\n\t\t  this._scheduled = false;\n\t\t  this.addedNodes = [];\n\t\t  this.removedNodes = [];\n\t\t  this.callbacks = new Set();\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.schedule = function schedule () {\n\t\t    var this$1 = this;\n\t\t\n\t\t  if (!this._scheduled) {\n\t\t    this._scheduled = true;\n\t\t    promish.then(function () {\n\t\t      this$1.flush();\n\t\t    });\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.flush = function flush () {\n\t\t  if (this._scheduled) {\n\t\t    this._scheduled = false;\n\t\t    var mutations = this.takeRecords();\n\t\t    if (mutations.length) {\n\t\t      this.callbacks.forEach(function(cb) {\n\t\t        cb(mutations);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t\t    var mutations = [{\n\t\t      addedNodes: this.addedNodes,\n\t\t      removedNodes: this.removedNodes\n\t\t    }];\n\t\t    this.addedNodes = [];\n\t\t    this.removedNodes = [];\n\t\t    return mutations;\n\t\t  }\n\t\t  return [];\n\t\t};\n\t\t\n\t\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t\t// directly so that users do not have to fork their code.\n\t\t// Supporting the entire api may be challenging: e.g. filtering out\n\t\t// removed nodes in the wrong scope and seeing non-distributing\n\t\t// subtree child mutations.\n\t\tvar observeChildren = function(node, callback) {\n\t\t  common.patchNode(node);\n\t\t  if (!node.__dom.observer) {\n\t\t    node.__dom.observer = new AsyncObserver();\n\t\t  }\n\t\t  node.__dom.observer.callbacks.add(callback);\n\t\t  var observer = node.__dom.observer;\n\t\t  return {\n\t\t    _callback: callback,\n\t\t    _observer: observer,\n\t\t    _node: node,\n\t\t    takeRecords: function takeRecords() {\n\t\t      return observer.takeRecords()\n\t\t    }\n\t\t  };\n\t\t}\n\t\t\n\t\tvar unobserveChildren = function(handle) {\n\t\t  var observer = handle && handle._observer;\n\t\t  if (observer) {\n\t\t    observer.callbacks.delete(handle._callback);\n\t\t    if (!observer.callbacks.size) {\n\t\t      handle._node.__dom.observer = null;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tvar patchedCount = 0;\n\t\t\n\t\tvar log = false;\n\t\t\n\t\tvar patchImpl = {\n\t\t\n\t\t  canPatchNode: function(node) {\n\t\t    switch (node) {\n\t\t      case document.head:\n\t\t      case document.documentElement:\n\t\t        return false;\n\t\t      default:\n\t\t        return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t\t    window.Node.prototype, 'textContent')),\n\t\t\n\t\t  patch: function(node) {\n\t\t    patchedCount++;\n\t\t    log && window.console.warn('patch node', node);\n\t\t    if (this.hasPrototypeDescriptors) {\n\t\t      patchPrototype(node, this.mixinForObject(node));\n\t\t    } else {\n\t\t      window.console.warn('Patching instance rather than prototype', node);\n\t\t      extend(node, this.mixinForNode(node));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  mixinForObject: function(obj) {\n\t\t    switch (obj.nodeType) {\n\t\t      case Node.ELEMENT_NODE:\n\t\t        return Mixins.Element;\n\t\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t\t        return Mixins.Fragment;\n\t\t      case Node.DOCUMENT_NODE:\n\t\t        return Mixins.Document;\n\t\t      case Node.TEXT_NODE:\n\t\t      case Node.COMMENT_NODE:\n\t\t        return Mixins.Node;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  unpatch: function(obj) {\n\t\t    if (obj.__sourceProto) {\n\t\t      obj.__proto__ = obj.__sourceProto;\n\t\t\n\t\t    }\n\t\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction patchNode(node) {\n\t\t  if (!settings.inUse) {\n\t\t    return;\n\t\t  }\n\t\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t\t    tree.saveChildNodes(node);\n\t\t    patchImpl.patch(node);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction unpatchNode(node) {\n\t\t  patchImpl.unpatch(node);\n\t\t}\n\t\t\n\t\tfunction isNodePatched(node) {\n\t\t  return Boolean(node.__patched);\n\t\t}\n\t\t\n\t\t// TODO(sorvell): fake export\n\t\tcommon.patchNode = patchNode;\n\t\tcommon.isNodePatched = isNodePatched;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar origAddEventListener = Element.prototype.addEventListener;\n\t\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\t\n\t\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\t\tvar alwaysComposed = {\n\t\t  blur: true,\n\t\t  focus: true,\n\t\t  focusin: true,\n\t\t  focusout: true,\n\t\t  click: true,\n\t\t  dblclick: true,\n\t\t  mousedown: true,\n\t\t  mouseenter: true,\n\t\t  mouseleave: true,\n\t\t  mousemove: true,\n\t\t  mouseout: true,\n\t\t  mouseover: true,\n\t\t  mouseup: true,\n\t\t  wheel: true,\n\t\t  beforeinput: true,\n\t\t  input: true,\n\t\t  keydown: true,\n\t\t  keyup: true,\n\t\t  compositionstart: true,\n\t\t  compositionupdate: true,\n\t\t  compositionend: true,\n\t\t  touchstart: true,\n\t\t  touchend: true,\n\t\t  touchmove: true,\n\t\t  touchcancel: true,\n\t\t  pointerover: true,\n\t\t  pointerenter: true,\n\t\t  pointerdown: true,\n\t\t  pointermove: true,\n\t\t  pointerup: true,\n\t\t  pointercancel: true,\n\t\t  pointerout: true,\n\t\t  pointerleave: true,\n\t\t  gotpointercapture: true,\n\t\t  lostpointercapture: true,\n\t\t  dragstart: true,\n\t\t  drag: true,\n\t\t  dragenter: true,\n\t\t  dragleave: true,\n\t\t  dragover: true,\n\t\t  drop: true,\n\t\t  dragend: true,\n\t\t  DOMActivate: true,\n\t\t  DOMFocusIn: true,\n\t\t  DOMFocusOut: true,\n\t\t  keypress: true\n\t\t};\n\t\t\n\t\tfunction pathComposer(startNode, composed) {\n\t\t  var composedPath = [];\n\t\t  var current = startNode;\n\t\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t\t  while (current) {\n\t\t    composedPath.push(current);\n\t\t    if (current.assignedSlot) {\n\t\t      current = current.assignedSlot;\n\t\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t\t      current = current.host;\n\t\t    } else {\n\t\t      current = current.parentNode;\n\t\t    }\n\t\t  }\n\t\t  // event composedPath includes window when startNode's ownerRoot is document\n\t\t  if (composedPath[composedPath.length - 1] === document) {\n\t\t    composedPath.push(window);\n\t\t  }\n\t\t  return composedPath;\n\t\t}\n\t\t\n\t\tfunction retarget(refNode, path) {\n\t\t  if (!isShadyRoot) {\n\t\t    return refNode;\n\t\t  }\n\t\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t\t  var refNodePath = pathComposer(refNode, true);\n\t\t  var p$ = path;\n\t\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t\t    ancestor = p$[i];\n\t\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t\t    if (root !== lastRoot) {\n\t\t      rootIdx = refNodePath.indexOf(root);\n\t\t      lastRoot = root;\n\t\t    }\n\t\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t\t      return ancestor;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tvar EventMixin = {\n\t\t\n\t\t  __patched: 'Event',\n\t\t\n\t\t  get composed() {\n\t\t    if (this.isTrusted && this.__composed === undefined) {\n\t\t      this.__composed = alwaysComposed[this.type];\n\t\t    }\n\t\t    return this.__composed || false;\n\t\t  },\n\t\t\n\t\t  composedPath: function composedPath() {\n\t\t    if (!this.__composedPath) {\n\t\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t\t    }\n\t\t    return this.__composedPath;\n\t\t  },\n\t\t\n\t\t  get target() {\n\t\t    return retarget(this.currentTarget, this.composedPath());\n\t\t  },\n\t\t\n\t\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t\t  get relatedTarget() {\n\t\t    if (!this.__relatedTarget) {\n\t\t      return null;\n\t\t    }\n\t\t    if (!this.__relatedTargetComposedPath) {\n\t\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t\t    }\n\t\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t\t  },\n\t\t  stopPropagation: function stopPropagation() {\n\t\t    Event.prototype.stopPropagation.call(this);\n\t\t    this.__propagationStopped = true;\n\t\t  },\n\t\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t\t    Event.prototype.stopImmediatePropagation.call(this);\n\t\t    this.__immediatePropagationStopped = true;\n\t\t    this.__propagationStopped = true;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction mixinComposedFlag(Base) {\n\t\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t\t  // try to do `Base.call` with a dom construtor.\n\t\t  var klazz = function(type, options) {\n\t\t    var event = new Base(type, options);\n\t\t    event.__composed = options && Boolean(options.composed);\n\t\t    return event;\n\t\t  }\n\t\t  // put constructor properties on subclass\n\t\t  mixin(klazz, Base);\n\t\t  klazz.prototype = Base.prototype;\n\t\t  return klazz;\n\t\t}\n\t\t\n\t\tvar nonBubblingEventsToRetarget = {\n\t\t  focus: true,\n\t\t  blur: true\n\t\t};\n\t\t\n\t\tfunction fireHandlers(event, node, phase) {\n\t\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t\t    node.__handlers[event.type][phase];\n\t\t  if (hs) {\n\t\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t\t      fn.call(node, event);\n\t\t      if (event.__immediatePropagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction retargetNonBubblingEvent(e) {\n\t\t  var path = e.composedPath();\n\t\t  var node;\n\t\t  // override `currentTarget` to let patched `target` calculate correctly\n\t\t  Object.defineProperty(e, 'currentTarget', {\n\t\t    get: function() {\n\t\t      return node;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t  for (var i = path.length - 1; i >= 0; i--) {\n\t\t    node = path[i];\n\t\t    // capture phase fires all capture handlers\n\t\t    fireHandlers(e, node, 'capture');\n\t\t    if (e.__propagationStopped) {\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t\n\t\t  // set the event phase to `AT_TARGET` as in spec\n\t\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\t\n\t\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t\t  // keep track of the last seen owner root\n\t\t  var lastFiredRoot;\n\t\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t\t    node = path[i$1];\n\t\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t\t      fireHandlers(e, node, 'bubble');\n\t\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t\t      if (node !== window) {\n\t\t        lastFiredRoot = node.getRootNode();\n\t\t      }\n\t\t      if (e.__propagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t\t  // It's more efficient to store the node/type/options information as Array in\n\t\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  if (fn.__eventWrappers) {\n\t\t    // Stop if the wrapper function has already been created.\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  } else {\n\t\t    fn.__eventWrappers = [];\n\t\t  }\n\t\t\n\t\t  var wrapperFn = function(e) {\n\t\t    // Support `once` option.\n\t\t    if (once) {\n\t\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t\t    }\n\t\t    if (!e.__target) {\n\t\t      e.__target = e.target;\n\t\t      e.__relatedTarget = e.relatedTarget;\n\t\t      patchPrototype(e, EventMixin);\n\t\t    }\n\t\t    // There are two critera that should stop events from firing on this node\n\t\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t\t        if (e.target === e.relatedTarget) {\n\t\t          e.stopImmediatePropagation();\n\t\t          return;\n\t\t        }\n\t\t      }\n\t\t      return fn(e);\n\t\t    }\n\t\t  };\n\t\t  // Store the wrapper information.\n\t\t  fn.__eventWrappers.push({\n\t\t    node: this,\n\t\t    type: type,\n\t\t    capture: capture,\n\t\t    once: once,\n\t\t    passive: passive,\n\t\t    wrapperFn: wrapperFn\n\t\t  });\n\t\t\n\t\t  if (nonBubblingEventsToRetarget[type]) {\n\t\t    this.__handlers = this.__handlers || {};\n\t\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t\t  } else {\n\t\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  // Search the wrapped function.\n\t\t  var wrapperFn = undefined;\n\t\t  if (fn.__eventWrappers) {\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t\t        // Cleanup.\n\t\t        if (!fn.__eventWrappers.length) {\n\t\t          fn.__eventWrappers = undefined;\n\t\t        }\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t\n\t\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t\t      this.__handlers && this.__handlers[type]) {\n\t\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t\t    var idx = arr.indexOf(wrapperFn);\n\t\t    if (idx > -1) {\n\t\t      arr.splice(idx, 1);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction activateFocusEventOverrides() {\n\t\t  for (var ev in nonBubblingEventsToRetarget) {\n\t\t    window.addEventListener(ev, function(e) {\n\t\t      if (!e.__target) {\n\t\t        e.__target = e.target;\n\t\t        e.__relatedTarget = e.relatedTarget;\n\t\t        patchPrototype(e, EventMixin);\n\t\t        retargetNonBubblingEvent(e);\n\t\t        e.stopImmediatePropagation();\n\t\t      }\n\t\t    }, true);\n\t\t  }\n\t\t}\n\t\t\n\t\t\n\t\tvar PatchedEvent = mixinComposedFlag(Event);\n\t\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\t\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tif (settings.inUse) {\n\t\t\n\t\t  window.ShadyDOM = {\n\t\t    tree: tree,\n\t\t    getNativeProperty: getNativeProperty,\n\t\t    patch: patchNode,\n\t\t    isPatched: isNodePatched,\n\t\t    unpatch: unpatchNode,\n\t\t    isShadyRoot: isShadyRoot,\n\t\t    enqueue: enqueue,\n\t\t    flush: flush$1,\n\t\t    inUse: settings.inUse,\n\t\t    filterMutations: filterMutations,\n\t\t    observeChildren: observeChildren,\n\t\t    unobserveChildren: unobserveChildren\n\t\t  };\n\t\t\n\t\t  var createRootAndEnsurePatched = function(node) {\n\t\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t\t    // a timing problem with gathering composed children.\n\t\t    // (1) currently the child list is crawled and patched when patching occurs\n\t\t    // (this needs to change)\n\t\t    // (2) we can only patch when an element has received its parsed children\n\t\t    // because we cannot detect them when inserted by parser.\n\t\t    // let ancestor = node;\n\t\t    // while (ancestor) {\n\t\t    //   patchNode(ancestor);\n\t\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t\t    // }\n\t\t    patchNode(node);\n\t\t    var root = new ShadyRoot(node);\n\t\t    patchNode(root);\n\t\t    return root;\n\t\t  }\n\t\t\n\t\t  Element.prototype.attachShadow = function() {\n\t\t    return createRootAndEnsurePatched(this);\n\t\t  }\n\t\t\n\t\t  Node.prototype.addEventListener = addEventListener;\n\t\t  Node.prototype.removeEventListener = removeEventListener;\n\t\t  Event = PatchedEvent;\n\t\t  CustomEvent = PatchedCustomEvent;\n\t\t  MouseEvent = PatchedMouseEvent;\n\t\t  activateFocusEventOverrides();\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t\t    get: function get() {\n\t\t      return document.documentElement.contains(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Node.prototype.getRootNode = function(options) {\n\t\t    return getRootNode(this, options);\n\t\t  }\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'slot', {\n\t\t    get: function get$1() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t\t    get: function get$2() {\n\t\t      return this._assignedSlot || null;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Element.prototype.setAttribute = setAttribute;\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'className', {\n\t\t    get: function get$3() {\n\t\t      return this.getAttribute('class');\n\t\t    },\n\t\t    set: function set$1(value) {\n\t\t      this.setAttribute('class', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t\t  // via appendChild. This either needs to be expanded or contracted.\n\t\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t\t  //   patchNode(this);\n\t\t  //   return this.appendChild(node);\n\t\t  // }\n\t\t\n\t\t}\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadydom.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tExtremely simple css parser. Intended to be not more than what we need\n\t\tand definitely not necessarily correct =).\n\t\t*/\n\t\t\n\t\t// given a string of css, return a simple rule tree\n\t\t\n\t\tfunction parse(text) {\n\t\t  text = clean(text);\n\t\t  return parseCss(lex(text), text);\n\t\t}\n\t\t\n\t\t// remove stuff we don't care about that may hinder parsing\n\t\tfunction clean(cssText) {\n\t\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t\t}\n\t\t\n\t\t// super simple {...} lexer that returns a node tree\n\t\tfunction lex(text) {\n\t\t  var root = {\n\t\t    start: 0,\n\t\t    end: text.length\n\t\t  };\n\t\t  var n = root;\n\t\t  for (var i = 0, l = text.length; i < l; i++) {\n\t\t    if (text[i] === OPEN_BRACE) {\n\t\t      if (!n.rules) {\n\t\t        n.rules = [];\n\t\t      }\n\t\t      var p = n;\n\t\t      var previous = p.rules[p.rules.length - 1];\n\t\t      n = {\n\t\t        start: i + 1,\n\t\t        parent: p,\n\t\t        previous: previous\n\t\t      };\n\t\t      p.rules.push(n);\n\t\t    } else if (text[i] === CLOSE_BRACE) {\n\t\t      n.end = i + 1;\n\t\t      n = n.parent || root;\n\t\t    }\n\t\t  }\n\t\t  return root;\n\t\t}\n\t\t\n\t\t// add selectors/cssText to node tree\n\t\tfunction parseCss(node, text) {\n\t\t  var t = text.substring(node.start, node.end - 1);\n\t\t  node.parsedCssText = node.cssText = t.trim();\n\t\t  if (node.parent) {\n\t\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t\t    t = text.substring(ss, node.start - 1);\n\t\t    t = _expandUnicodeEscapes(t);\n\t\t    t = t.replace(RX.multipleSpaces, ' ');\n\t\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t\t    // helps with mixin syntax\n\t\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t\t    var s = node.parsedSelector = node.selector = t.trim();\n\t\t    node.atRule = s.indexOf(AT_START) === 0;\n\t\t    // note, support a subset of rule types...\n\t\t    if (node.atRule) {\n\t\t      if (s.indexOf(MEDIA_START) === 0) {\n\t\t        node.type = types.MEDIA_RULE;\n\t\t      } else if (s.match(RX.keyframesRule)) {\n\t\t        node.type = types.KEYFRAMES_RULE;\n\t\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t\t      }\n\t\t    } else {\n\t\t      if (s.indexOf(VAR_START) === 0) {\n\t\t        node.type = types.MIXIN_RULE;\n\t\t      } else {\n\t\t        node.type = types.STYLE_RULE;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      parseCss(r, text);\n\t\t    }\n\t\t  }\n\t\t  return node;\n\t\t}\n\t\t\n\t\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t\t// expanded form that doesn't require trailing space `\\000033`\n\t\tfunction _expandUnicodeEscapes(s) {\n\t\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t\t    var code = arguments[1],\n\t\t        repeat = 6 - code.length;\n\t\t    while (repeat--) {\n\t\t      code = '0' + code;\n\t\t    }\n\t\t    return '\\\\' + code;\n\t\t  });\n\t\t}\n\t\t\n\t\t// stringify parsed css.\n\t\tfunction stringify(node, preserveProperties, text) {\n\t\t  text = text || '';\n\t\t  // calc rule cssText\n\t\t  var cssText = '';\n\t\t  if (node.cssText || node.rules) {\n\t\t    var r$ = node.rules;\n\t\t    if (r$ && !_hasMixinRules(r$)) {\n\t\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t        cssText = stringify(r, preserveProperties, cssText);\n\t\t      }\n\t\t    } else {\n\t\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t\t      cssText = cssText.trim();\n\t\t      if (cssText) {\n\t\t        cssText = '  ' + cssText + '\\n';\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  // emit rule if there is cssText\n\t\t  if (cssText) {\n\t\t    if (node.selector) {\n\t\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t\t    }\n\t\t    text += cssText;\n\t\t    if (node.selector) {\n\t\t      text += CLOSE_BRACE + '\\n\\n';\n\t\t    }\n\t\t  }\n\t\t  return text;\n\t\t}\n\t\t\n\t\tfunction _hasMixinRules(rules) {\n\t\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t\t}\n\t\t\n\t\tfunction removeCustomProps(cssText) {\n\t\t  cssText = removeCustomPropAssignment(cssText);\n\t\t  return removeCustomPropApply(cssText);\n\t\t}\n\t\t\n\t\tfunction removeCustomPropAssignment(cssText) {\n\t\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t\t}\n\t\t\n\t\tfunction removeCustomPropApply(cssText) {\n\t\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t\t}\n\t\t\n\t\tvar types = {\n\t\t  STYLE_RULE: 1,\n\t\t  KEYFRAMES_RULE: 7,\n\t\t  MEDIA_RULE: 4,\n\t\t  MIXIN_RULE: 1000\n\t\t};\n\t\t\n\t\tvar OPEN_BRACE = '{';\n\t\tvar CLOSE_BRACE = '}';\n\t\t\n\t\t// helper regexp's\n\t\tvar RX = {\n\t\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t\t  port: /@import[^;]*;/gim,\n\t\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t\t  multipleSpaces: /\\s+/g\n\t\t};\n\t\t\n\t\tvar VAR_START = '--';\n\t\tvar MEDIA_START = '@media';\n\t\tvar AT_START = '@';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\t\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\t\n\t\t// experimental support for native @apply\n\t\tfunction detectNativeApply() {\n\t\t  var style = document.createElement('style');\n\t\t  style.textContent = '.foo { @apply --foo }';\n\t\t  document.head.appendChild(style);\n\t\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t\t  document.head.removeChild(style);\n\t\t  return nativeCssApply;\n\t\t}\n\t\t\n\t\tvar nativeCssApply = false && detectNativeApply();\n\t\t\n\t\tfunction parseSettings(settings) {\n\t\t  if (settings) {\n\t\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t\t  }\n\t\t}\n\t\t\n\t\tif (window.ShadyCSS) {\n\t\t  parseSettings(window.ShadyCSS);\n\t\t} else if (window.WebComponents) {\n\t\t  parseSettings(window.WebComponents.flags);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction toCssText(rules, callback) {\n\t\t  if (typeof rules === 'string') {\n\t\t    rules = parse(rules);\n\t\t  }\n\t\t  if (callback) {\n\t\t    forEachRule(rules, callback);\n\t\t  }\n\t\t  return stringify(rules, nativeCssVariables);\n\t\t}\n\t\t\n\t\tfunction rulesForStyle(style) {\n\t\t  if (!style.__cssRules && style.textContent) {\n\t\t    style.__cssRules = parse(style.textContent);\n\t\t  }\n\t\t  return style.__cssRules;\n\t\t}\n\t\t\n\t\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t\t// like a normal selector but is not (it has nothing to do with scoping\n\t\t// for example).\n\t\tfunction isKeyframesSelector(rule) {\n\t\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t\t}\n\t\t\n\t\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t\t  if (!node) {\n\t\t    return;\n\t\t  }\n\t\t  var skipRules = false;\n\t\t  if (onlyActiveRules) {\n\t\t    if (node.type === types.MEDIA_RULE) {\n\t\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t\t      if (matchMedia) {\n\t\t        // if rule is a non matching @media rule, skip subrules\n\t\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t\t          skipRules = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  if (node.type === types.STYLE_RULE) {\n\t\t    styleRuleCallback(node);\n\t\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t\t    keyframesRuleCallback(node);\n\t\t  } else if (node.type === types.MIXIN_RULE) {\n\t\t    skipRules = true;\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$ && !skipRules) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t// add a string of cssText to the document.\n\t\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t\t  var style = createScopeStyle(cssText, moniker);\n\t\t  return applyStyle$1(style, target, contextNode);\n\t\t}\n\t\t\n\t\tfunction applyStyle$1(style, target, contextNode) {\n\t\t  target = target || document.head;\n\t\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t\t  lastHeadApplyNode = style;\n\t\t  return target.insertBefore(style, after);\n\t\t}\n\t\t\n\t\tfunction createScopeStyle(cssText, moniker) {\n\t\t  var style = document.createElement('style');\n\t\t  if (moniker) {\n\t\t    style.setAttribute('scope', moniker);\n\t\t  }\n\t\t  style.textContent = cssText;\n\t\t  return style;\n\t\t}\n\t\t\n\t\tvar lastHeadApplyNode = null;\n\t\t\n\t\t// insert a comment node as a styling position placeholder.\n\t\tfunction applyStylePlaceHolder(moniker) {\n\t\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t\t  var scope = document.head;\n\t\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t\t  lastHeadApplyNode = placeHolder;\n\t\t  return placeHolder;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t// cssBuildTypeForModule: function (module) {\n\t\t//   let dm = Polymer.DomModule.import(module);\n\t\t//   if (dm) {\n\t\t//     return getCssBuildType(dm);\n\t\t//   }\n\t\t// },\n\t\t//\n\t\t\n\t\t\n\t\t// Walk from text[start] matching parens\n\t\t// returns position of the outer end paren\n\t\tfunction findMatchingParen(text, start) {\n\t\t  var level = 0;\n\t\t  for (var i = start, l = text.length; i < l; i++) {\n\t\t    if (text[i] === '(') {\n\t\t      level++;\n\t\t    } else if (text[i] === ')') {\n\t\t      if (--level === 0) {\n\t\t        return i;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return -1;\n\t\t}\n\t\t\n\t\tfunction processVariableAndFallback(str, callback) {\n\t\t  // find 'var('\n\t\t  var start = str.indexOf('var(');\n\t\t  if (start === -1) {\n\t\t    // no var?, everything is prefix\n\t\t    return callback(str, '', '', '');\n\t\t  }\n\t\t  //${prefix}var(${inner})${suffix}\n\t\t  var end = findMatchingParen(str, start + 3);\n\t\t  var inner = str.substring(start + 4, end);\n\t\t  var prefix = str.substring(0, start);\n\t\t  // suffix may have other variables\n\t\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t\t  var comma = inner.indexOf(',');\n\t\t  // value and fallback args should be trimmed to match in property lookup\n\t\t  if (comma === -1) {\n\t\t    // variable, no fallback\n\t\t    return callback(prefix, inner.trim(), '', suffix);\n\t\t  }\n\t\t  // var(${value},${fallback})\n\t\t  var value = inner.substring(0, comma).trim();\n\t\t  var fallback = inner.substring(comma + 1).trim();\n\t\t  return callback(prefix, value, fallback, suffix);\n\t\t}\n\t\t\n\t\tvar rx = {\n\t\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t\t  IS_VAR: /^--/,\n\t\t  BRACKETED: /\\{[^}]*\\}/g,\n\t\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\t\n\t\t* scoping:\n\t\t\n\t\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t\t  * selectors re-written as follows:\n\t\t\n\t\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\t\n\t\t* :host -> scopeName\n\t\t\n\t\t* :host(...) -> scopeName...\n\t\t\n\t\t* ::slotted(...) -> scopeName > ...\n\t\t\n\t\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\t\n\t\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\t\n\t\t*/\n\t\tvar SCOPE_NAME = 'style-scope';\n\t\t\n\t\tvar StyleTransformer = {\n\t\t\n\t\t  // Given a node and scope name, add a scoping class to each node\n\t\t  // in the tree. This facilitates transforming css into scoped rules.\n\t\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t\t    // one time optimization to skip scoping...\n\t\t    if (node.__styleScoped) {\n\t\t      node.__styleScoped = null;\n\t\t    } else {\n\t\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t\t    if (node.classList) {\n\t\t      this.element(node, selector, shouldRemoveScope);\n\t\t    }\n\t\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t\t    if (c$) {\n\t\t      for (var i = 0; i < c$.length; i++) {\n\t\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  element: function element(_element, scope, shouldRemoveScope) {\n\t\t    // note: if using classes, we add both the general 'style-scope' class\n\t\t    // as well as the specific scope. This enables easy filtering of all\n\t\t    // `style-scope` elements\n\t\t    if (scope) {\n\t\t      // note: svg on IE does not have classList so fallback to class\n\t\t      if (_element.classList) {\n\t\t        if (shouldRemoveScope) {\n\t\t          _element.classList.remove(SCOPE_NAME);\n\t\t          _element.classList.remove(scope);\n\t\t        } else {\n\t\t          _element.classList.add(SCOPE_NAME);\n\t\t          _element.classList.add(scope);\n\t\t        }\n\t\t      } else if (_element.getAttribute) {\n\t\t        var c = _element.getAttribute(CLASS);\n\t\t        if (shouldRemoveScope) {\n\t\t          if (c) {\n\t\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t\t          }\n\t\t        } else {\n\t\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t\t    var cssBuildType = element.__cssBuild;\n\t\t    // no need to shim selectors if settings.useNativeShadow, also\n\t\t    // a shady css build will already have transformed selectors\n\t\t    // NOTE: This method may be called as part of static or property shimming.\n\t\t    // When there is a targeted build it will not be called for static shimming,\n\t\t    // but when the property shim is used it is called and should opt out of\n\t\t    // static shimming work when a proper build exists.\n\t\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t\t    return cssText.trim();\n\t\t  },\n\t\t\n\t\t  // Given a string of cssText and a scoping string (scope), returns\n\t\t  // a string of scoped css where each selector is transformed to include\n\t\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t\t  // (e.g. :host) to use the scoping selector.\n\t\t  css: function css(rules, scope, ext, callback) {\n\t\t    var hostScope = this._calcHostScope(scope, ext);\n\t\t    scope = this._calcElementScope(scope);\n\t\t    var self = this;\n\t\t    return toCssText(rules, function (rule) {\n\t\t      if (!rule.isScoped) {\n\t\t        self.rule(rule, scope, hostScope);\n\t\t        rule.isScoped = true;\n\t\t      }\n\t\t      if (callback) {\n\t\t        callback(rule, scope, hostScope);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _calcElementScope: function _calcElementScope(scope) {\n\t\t    if (scope) {\n\t\t      return CSS_CLASS_PREFIX + scope;\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t\t    return ext ? '[is=' + scope + ']' : scope;\n\t\t  },\n\t\t\n\t\t  rule: function rule(_rule, scope, hostScope) {\n\t\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  // transforms a css rule to a scoped rule.\n\t\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t\t    // against selectors (e.g. when calculating style properties)\n\t\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t\t    // we want to skip transformation of rules that appear in keyframes,\n\t\t    // because they are keyframe selectors, not element selectors.\n\t\t    if (!isKeyframesSelector(rule)) {\n\t\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t\t      }\n\t\t    }\n\t\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t\t  },\n\t\t\n\t\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t\t    var _this = this;\n\t\t\n\t\t    var stop = false;\n\t\t    selector = selector.trim();\n\t\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t\t    });\n\t\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t\t      if (!stop) {\n\t\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t\t        stop = stop || info.stop;\n\t\t        c = info.combinator;\n\t\t        s = info.value;\n\t\t      }\n\t\t      return c + s;\n\t\t    });\n\t\t    return selector;\n\t\t  },\n\t\t\n\t\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t\t    // replace :host with host scoping class\n\t\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t\t    if (selector.indexOf(HOST) >= 0) {\n\t\t      selector = this._transformHostSelector(selector, hostScope);\n\t\t      // replace other selectors with scoping class\n\t\t    } else if (slottedIndex !== 0) {\n\t\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t\t    }\n\t\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t\t    // also ignore left-side combinator\n\t\t    var slotted = false;\n\t\t    if (slottedIndex >= 0) {\n\t\t      combinator = '';\n\t\t      slotted = true;\n\t\t    }\n\t\t    // process scope jumping selectors up to the scope jump and then stop\n\t\t    var stop = void 0;\n\t\t    if (slotted) {\n\t\t      stop = true;\n\t\t      if (slotted) {\n\t\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t\t          return ' > ' + paren;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t\t    });\n\t\t    return { value: selector, combinator: combinator, stop: stop };\n\t\t  },\n\t\t\n\t\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t\t    p$[0] += scope;\n\t\t    return p$.join(PSEUDO_PREFIX);\n\t\t  },\n\t\t\n\t\t  // :host(...) -> scopeName...\n\t\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t\t    var m = selector.match(HOST_PAREN);\n\t\t    var paren = m && m[2].trim() || '';\n\t\t    if (paren) {\n\t\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t\t        // paren starts with a type selector\n\t\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t\t        // if the type selector is our hostScope then avoid pre-pending it\n\t\t        if (typeSelector === hostScope) {\n\t\t          return paren;\n\t\t          // otherwise, this selector should not match in this scope so\n\t\t          // output a bogus selector.\n\t\t        } else {\n\t\t          return SELECTOR_NO_MATCH;\n\t\t        }\n\t\t      } else {\n\t\t        // make sure to do a replace here to catch selectors like:\n\t\t        // `:host(.foo)::before`\n\t\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t\t          return hostScope + paren;\n\t\t        });\n\t\t      }\n\t\t      // if no paren, do a straight :host replacement.\n\t\t      // TODO(sorvell): this should not strictly be necessary but\n\t\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t\t      // which have been improperly used under Shady DOM. This should be\n\t\t      // deprecated.\n\t\t    } else {\n\t\t      return selector.replace(HOST, hostScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  documentRule: function documentRule(rule) {\n\t\t    // reset selector in case this is redone.\n\t\t    rule.selector = rule.parsedSelector;\n\t\t    this.normalizeRootSelector(rule);\n\t\t    this._transformRule(rule, this._transformDocumentSelector);\n\t\t  },\n\t\t\n\t\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t\t    if (rule.selector === ROOT) {\n\t\t      rule.selector = 'html';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t\t  },\n\t\t  SCOPE_NAME: SCOPE_NAME\n\t\t};\n\t\t\n\t\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\t\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\t\tvar COMPLEX_SELECTOR_SEP = ',';\n\t\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\t\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\t\tvar HOST = ':host';\n\t\tvar ROOT = ':root';\n\t\tvar SLOTTED = '::slotted';\n\t\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t\t// NOTE: this supports 1 nested () pair for things like\n\t\t// :host(:not([selected]), more general support requires\n\t\t// parsing which seems like overkill\n\t\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\t// similar to HOST_PAREN\n\t\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\t\tvar CSS_CLASS_PREFIX = '.';\n\t\tvar PSEUDO_PREFIX = ':';\n\t\tvar CLASS = 'class';\n\t\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\t\n\t\tvar classCallCheck = function (instance, Constructor) {\n\t\t  if (!(instance instanceof Constructor)) {\n\t\t    throw new TypeError(\"Cannot call a class as a function\");\n\t\t  }\n\t\t};\n\t\t\n\t\tvar createClass = function () {\n\t\t  function defineProperties(target, props) {\n\t\t    for (var i = 0; i < props.length; i++) {\n\t\t      var descriptor = props[i];\n\t\t      descriptor.enumerable = descriptor.enumerable || false;\n\t\t      descriptor.configurable = true;\n\t\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return function (Constructor, protoProps, staticProps) {\n\t\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t\t    return Constructor;\n\t\t  };\n\t\t}();\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar set$1 = function set$1(object, property, value, receiver) {\n\t\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\t\n\t\t  if (desc === undefined) {\n\t\t    var parent = Object.getPrototypeOf(object);\n\t\t\n\t\t    if (parent !== null) {\n\t\t      set$1(parent, property, value, receiver);\n\t\t    }\n\t\t  } else if (\"value\" in desc && desc.writable) {\n\t\t    desc.value = value;\n\t\t  } else {\n\t\t    var setter = desc.set;\n\t\t\n\t\t    if (setter !== undefined) {\n\t\t      setter.call(receiver, value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return value;\n\t\t};\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar toConsumableArray = function (arr) {\n\t\t  if (Array.isArray(arr)) {\n\t\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\t\n\t\t    return arr2;\n\t\t  } else {\n\t\t    return Array.from(arr);\n\t\t  }\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar StyleInfo = function () {\n\t\t  createClass(StyleInfo, null, [{\n\t\t    key: 'get',\n\t\t    value: function get(node) {\n\t\t      return node.__styleInfo;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'set',\n\t\t    value: function set(node, styleInfo) {\n\t\t      node.__styleInfo = styleInfo;\n\t\t      return styleInfo;\n\t\t    }\n\t\t  }]);\n\t\t\n\t\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t\t    classCallCheck(this, StyleInfo);\n\t\t\n\t\t    this.styleRules = ast || null;\n\t\t    this.placeholder = placeholder || null;\n\t\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t\t    this.overrideStyleProperties = {};\n\t\t    this.elementName = elementName || '';\n\t\t    this.cssBuild = cssBuild || '';\n\t\t    this.typeExtension = typeExtension || '';\n\t\t    this.styleProperties = null;\n\t\t    this.scopeSelector = null;\n\t\t    this.customStyle = null;\n\t\t  }\n\t\t\n\t\t  return StyleInfo;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO: dedupe with shady\n\t\tvar p = window.Element.prototype;\n\t\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\t\n\t\tvar StyleProperties = {\n\t\t\n\t\t  // decorates styles with rule info and returns an array of used style\n\t\t  // property names\n\t\t  decorateStyles: function decorateStyles(rules) {\n\t\t    var self = this,\n\t\t        props = {},\n\t\t        keyframes = [],\n\t\t        ruleIndex = 0;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      self.decorateRule(rule);\n\t\t      // mark in-order position of ast rule in styles block, used for cache key\n\t\t      rule.index = ruleIndex++;\n\t\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t\t    }, function onKeyframesRule(rule) {\n\t\t      keyframes.push(rule);\n\t\t    });\n\t\t    // Cache all found keyframes rules for later reference:\n\t\t    rules._keyframes = keyframes;\n\t\t    // return this list of property names *consumes* in these styles.\n\t\t    var names = [];\n\t\t    for (var i in props) {\n\t\t      names.push(i);\n\t\t    }\n\t\t    return names;\n\t\t  },\n\t\t\n\t\t  // decorate a single rule with property info\n\t\t  decorateRule: function decorateRule(rule) {\n\t\t    if (rule.propertyInfo) {\n\t\t      return rule.propertyInfo;\n\t\t    }\n\t\t    var info = {},\n\t\t        properties = {};\n\t\t    var hasProperties = this.collectProperties(rule, properties);\n\t\t    if (hasProperties) {\n\t\t      info.properties = properties;\n\t\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t\t      rule.rules = null;\n\t\t    }\n\t\t    info.cssText = this.collectCssText(rule);\n\t\t    rule.propertyInfo = info;\n\t\t    return info;\n\t\t  },\n\t\t\n\t\t  // collects the custom properties from a rule's cssText\n\t\t  collectProperties: function collectProperties(rule, properties) {\n\t\t    var info = rule.propertyInfo;\n\t\t    if (info) {\n\t\t      if (info.properties) {\n\t\t        Object.assign(properties, info.properties);\n\t\t        return true;\n\t\t      }\n\t\t    } else {\n\t\t      var m = void 0,\n\t\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t\t      var cssText = rule.parsedCssText;\n\t\t      var value = void 0;\n\t\t      var any = void 0;\n\t\t      while (m = rx$$1.exec(cssText)) {\n\t\t        // note: group 2 is var, 3 is mixin\n\t\t        value = (m[2] || m[3]).trim();\n\t\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t\t        if (value !== 'inherit' || value !== 'unset') {\n\t\t          properties[m[1].trim()] = value;\n\t\t        }\n\t\t        any = true;\n\t\t      }\n\t\t      return any;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // returns cssText of properties that consume variables/mixins\n\t\t  collectCssText: function collectCssText(rule) {\n\t\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t\t  },\n\t\t\n\t\t  // NOTE: we support consumption inside mixin assignment\n\t\t  // but not production, so strip out {...}\n\t\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t\t  },\n\t\t\n\t\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t\t    var m = void 0;\n\t\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t\t      var name = m[1];\n\t\t      // This regex catches all variable names, and following non-whitespace char\n\t\t      // If next char is not ':', then variable is a consumer\n\t\t      if (m[2] !== ':') {\n\t\t        props[name] = true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // turns custom properties into realized values.\n\t\t  reify: function reify(props) {\n\t\t    // big perf optimization here: reify only *own* properties\n\t\t    // since this object has __proto__ of the element's scope properties\n\t\t    var names = Object.getOwnPropertyNames(props);\n\t\t    for (var i = 0, n; i < names.length; i++) {\n\t\t      n = names[i];\n\t\t      props[n] = this.valueForProperty(props[n], props);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // given a property value, returns the reified value\n\t\t  // a property value may be:\n\t\t  // (1) a literal value like: red or 5px;\n\t\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t\t  // var(--a, var(--b));\n\t\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t\t  valueForProperty: function valueForProperty(property, props) {\n\t\t    var _this = this;\n\t\t\n\t\t    // case (1) default\n\t\t    // case (3) defines a mixin and we have to reify the internals\n\t\t    if (property) {\n\t\t      if (property.indexOf(';') >= 0) {\n\t\t        property = this.valueForProperties(property, props);\n\t\t      } else {\n\t\t        (function () {\n\t\t          // case (2) variable\n\t\t          var self = _this;\n\t\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t\t            if (!value) {\n\t\t              return prefix + suffix;\n\t\t            }\n\t\t            var propertyValue = self.valueForProperty(props[value], props);\n\t\t            // if value is \"initial\", then the variable should be treated as unset\n\t\t            if (!propertyValue || propertyValue === 'initial') {\n\t\t              // fallback may be --a or var(--a) or literal\n\t\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t\t              // for use with native css variables.\n\t\t              // Since we have full control, we can use `inherit` directly.\n\t\t              propertyValue = 'inherit';\n\t\t            }\n\t\t            return prefix + (propertyValue || '') + suffix;\n\t\t          };\n\t\t          property = processVariableAndFallback(property, fn);\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\t    return property && property.trim() || '';\n\t\t  },\n\t\t\n\t\t  // note: we do not yet support mixin within mixin\n\t\t  valueForProperties: function valueForProperties(property, props) {\n\t\t    var parts = property.split(';');\n\t\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t\t      if (_p = parts[i]) {\n\t\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t\t        if (m) {\n\t\t          _p = this.valueForProperty(props[m[1]], props);\n\t\t        } else {\n\t\t          var colon = _p.indexOf(':');\n\t\t          if (colon !== -1) {\n\t\t            var pp = _p.substring(colon);\n\t\t            pp = pp.trim();\n\t\t            pp = this.valueForProperty(pp, props) || pp;\n\t\t            _p = _p.substring(0, colon) + pp;\n\t\t          }\n\t\t        }\n\t\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t\t        // strip trailing ;\n\t\t        _p.slice(0, -1) : _p || '';\n\t\t      }\n\t\t    }\n\t\t    return parts.join(';');\n\t\t  },\n\t\t\n\t\t  applyProperties: function applyProperties(rule, props) {\n\t\t    var output = '';\n\t\t    // dynamically added sheets may not be decorated so ensure they are.\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (rule.propertyInfo.cssText) {\n\t\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t\t  // functions which take in cssText and spit out transformed cssText.\n\t\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t\t    var input = rule.cssText;\n\t\t    var output = rule.cssText;\n\t\t    if (rule.hasAnimations == null) {\n\t\t      // Cache whether or not the rule has any animations to begin with:\n\t\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t\t    }\n\t\t    // If there are no animations referenced, we can skip transforms:\n\t\t    if (rule.hasAnimations) {\n\t\t      var transform = void 0;\n\t\t      // If we haven't transformed this rule before, we iterate over all\n\t\t      // transforms:\n\t\t      if (rule.keyframeNamesToTransform == null) {\n\t\t        rule.keyframeNamesToTransform = [];\n\t\t        for (var keyframe in keyframeTransforms) {\n\t\t          transform = keyframeTransforms[keyframe];\n\t\t          output = transform(input);\n\t\t          // If the transform actually changed the CSS text, we cache the\n\t\t          // transform name for future use:\n\t\t          if (input !== output) {\n\t\t            input = output;\n\t\t            rule.keyframeNamesToTransform.push(keyframe);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        // If we already have a list of keyframe names that apply to this\n\t\t        // rule, we apply only those keyframe name transforms:\n\t\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t\t          input = transform(input);\n\t\t        }\n\t\t        output = input;\n\t\t      }\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Test if the rules in these styles matches the given `element` and if so,\n\t\t  // collect any custom properties into `props`.\n\t\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t\t    var props = {},\n\t\t        self = this;\n\t\t    // generates a unique key for these matches\n\t\t    var o = [];\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t\t      // time to only include ones that have properties\n\t\t      if (!rule.propertyInfo) {\n\t\t        self.decorateRule(rule);\n\t\t      }\n\t\t      // match element against transformedSelector: selector may contain\n\t\t      // unwanted uniquification and parsedSelector does not directly match\n\t\t      // for :host selectors.\n\t\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t\t          self.collectProperties(rule, props);\n\t\t          // produce numeric key for these matches for lookup\n\t\t          addToBitMask(rule.index, o);\n\t\t        }\n\t\t      }\n\t\t    }, null, true);\n\t\t    return { properties: props, key: o };\n\t\t  },\n\t\t\n\t\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (!rule.propertyInfo.properties) {\n\t\t      return;\n\t\t    }\n\t\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t\t    var parsedSelector = rule.parsedSelector;\n\t\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t\t    // build info is either in scope (when scope is an element) or in the style\n\t\t    // when scope is the default scope; note: this allows default scope to have\n\t\t    // mixed mode built and unbuilt styles.\n\t\t    if (cssBuild === 'shady') {\n\t\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t\t    }\n\t\t    if (cssBuild === 'shadow') {\n\t\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t      isHost = isHost && !isRoot;\n\t\t    }\n\t\t    if (!isRoot && !isHost) {\n\t\t      return;\n\t\t    }\n\t\t    var selectorToMatch = hostScope;\n\t\t    if (isHost) {\n\t\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t\t      if (nativeShadow && !rule.transformedSelector) {\n\t\t        // transform :host into a matchable selector\n\t\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t\t      }\n\t\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t\t    }\n\t\t    callback({\n\t\t      selector: selectorToMatch,\n\t\t      isHost: isHost,\n\t\t      isRoot: isRoot\n\t\t    });\n\t\t  },\n\t\t\n\t\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t\t    var hostProps = {},\n\t\t        rootProps = {},\n\t\t        self = this;\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    var cssBuild = rules && rules.__cssBuild;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t\t        var element = scope._element || scope;\n\t\t        if (matchesSelector.call(element, info.selector)) {\n\t\t          if (info.isHost) {\n\t\t            self.collectProperties(rule, hostProps);\n\t\t          } else {\n\t\t            self.collectProperties(rule, rootProps);\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }, null, true);\n\t\t    return { rootProps: rootProps, hostProps: hostProps };\n\t\t  },\n\t\t\n\t\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t\t    var self = this;\n\t\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t\t    var rules = StyleInfo.get(element).styleRules;\n\t\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t\t      self.applyProperties(rule, properties);\n\t\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t\t        // is not necessary to apply them in ShadowDOM.\n\t\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t\t    var keyframesRules = rules._keyframes;\n\t\t    var keyframeTransforms = {};\n\t\t    if (!nativeShadow && keyframesRules) {\n\t\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t\t      // advance for the current scope. This allows us to catch keyframes\n\t\t      // rules that appear anywhere in the stylesheet:\n\t\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t\t      }\n\t\t    }\n\t\t    return keyframeTransforms;\n\t\t  },\n\t\t\n\t\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t\t  // particular scoped keyframes rule.\n\t\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t\t    return function (cssText) {\n\t\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t\t    };\n\t\t  },\n\t\t\n\t\t  // Transforms `@keyframes` names to be unique for the current host.\n\t\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t\t  },\n\t\t\n\t\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t\t  // have low specificity. They are overrideable by class selectors but,\n\t\t  // unfortunately, not by type selectors (e.g. overriding via\n\t\t  // `.special` is ok, but not by `x-foo`).\n\t\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    var selector = rule.transformedSelector;\n\t\t    var scope = '.' + scopeId;\n\t\t    var parts = selector.split(',');\n\t\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t\t    }\n\t\t    rule.selector = parts.join(',');\n\t\t  },\n\t\t\n\t\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t\t    var c = element.getAttribute('class') || '';\n\t\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t\t    if (c !== v) {\n\t\t      element.setAttribute('class', v);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t\t    // calculate cssText to apply\n\t\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t\t    // if shady and we have a cached style that is not style, decrement\n\t\t    var styleInfo = StyleInfo.get(element);\n\t\t    var s = styleInfo.customStyle;\n\t\t    if (s && !nativeShadow && s !== style) {\n\t\t      s._useCount--;\n\t\t      if (s._useCount <= 0 && s.parentNode) {\n\t\t        s.parentNode.removeChild(s);\n\t\t      }\n\t\t    }\n\t\t    // apply styling always under native or if we generated style\n\t\t    // or the cached style is not in document(!)\n\t\t    if (nativeShadow) {\n\t\t      // update existing style only under native\n\t\t      if (styleInfo.customStyle) {\n\t\t        styleInfo.customStyle.textContent = cssText;\n\t\t        style = styleInfo.customStyle;\n\t\t        // otherwise, if we have css to apply, do so\n\t\t      } else if (cssText) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t\t      }\n\t\t    } else {\n\t\t      // shady and no cache hit\n\t\t      if (!style) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        if (cssText) {\n\t\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t\t        }\n\t\t        // shady and cache hit but not in document\n\t\t      } else if (!style.parentNode) {\n\t\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t\t      }\n\t\t    }\n\t\t    // ensure this style is our custom style and increment its use count.\n\t\t    if (style) {\n\t\t      style._useCount = style._useCount || 0;\n\t\t      // increment use count if we changed styles\n\t\t      if (styleInfo.customStyle != style) {\n\t\t        style._useCount++;\n\t\t      }\n\t\t      styleInfo.customStyle = style;\n\t\t    }\n\t\t    // @media rules may be stale in IE 10 and 11\n\t\t    if (IS_IE) {\n\t\t      style.textContent = style.textContent;\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t\n\t\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t\t    var rules = rulesForStyle(style);\n\t\t    var self = this;\n\t\t    style.textContent = toCssText(rules, function (rule) {\n\t\t      var css = rule.cssText = rule.parsedCssText;\n\t\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t\t        // remove property assignments\n\t\t        // so next function isn't confused\n\t\t        // NOTE: we have 3 categories of css:\n\t\t        // (1) normal properties,\n\t\t        // (2) custom property assignments (--foo: red;),\n\t\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t\t        // are not and this makes this case unique.\n\t\t        css = removeCustomPropAssignment(css);\n\t\t        // replace with reified properties, scenario is same as mixin\n\t\t        rule.cssText = self.valueForProperties(css, properties);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  rx: rx,\n\t\t  XSCOPE_NAME: 'x-scope'\n\t\t};\n\t\t\n\t\tfunction addToBitMask(n, bits) {\n\t\t  var o = parseInt(n / 32);\n\t\t  var v = 1 << n % 32;\n\t\t  bits[o] = (bits[o] || 0) | v;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar templateMap = {};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar placeholderMap = {};\n\t\t\n\t\tvar ce = window.customElements;\n\t\tif (ce && !nativeShadow) {\n\t\t  (function () {\n\t\t    var origDefine = ce.define;\n\t\t    ce.define = function (name, clazz, options) {\n\t\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t\t      return origDefine.call(ce, name, clazz, options);\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\tvar StyleCache = function () {\n\t\t  function StyleCache() {\n\t\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t\t    classCallCheck(this, StyleCache);\n\t\t\n\t\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t\t    this.cache = {};\n\t\t    this.typeMax = typeMax;\n\t\t  }\n\t\t\n\t\t  createClass(StyleCache, [{\n\t\t    key: '_validate',\n\t\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t\t        var pn = ownPropertyNames[idx];\n\t\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t\t          return false;\n\t\t        }\n\t\t      }\n\t\t      return true;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'store',\n\t\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t\t      var list = this.cache[tagname] || [];\n\t\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t\t      if (list.length > this.typeMax) {\n\t\t        list.shift();\n\t\t      }\n\t\t      this.cache[tagname] = list;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'fetch',\n\t\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t\t      var list = this.cache[tagname];\n\t\t      if (!list) {\n\t\t        return;\n\t\t      }\n\t\t      // reverse list for most-recent lookups\n\t\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t\t        var entry = list[idx];\n\t\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t\t          return entry;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }]);\n\t\t  return StyleCache;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/**\n\t\t * The apply shim simulates the behavior of `@apply` proposed at\n\t\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t\t * The approach is to convert a property like this:\n\t\t *\n\t\t *    --foo: {color: red; background: blue;}\n\t\t *\n\t\t * to this:\n\t\t *\n\t\t *    --foo_-_color: red;\n\t\t *    --foo_-_background: blue;\n\t\t *\n\t\t * Then where `@apply --foo` is used, that is converted to:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background);\n\t\t *\n\t\t * This approach generally works but there are some issues and limitations.\n\t\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t\t * another element sets it to:\n\t\t *\n\t\t *    --foo: { border: 2px solid red; }\n\t\t *\n\t\t * We must now ensure that the color and background from the previous setting\n\t\t * do not apply. This is accomplished by changing the property set to this:\n\t\t *\n\t\t *    --foo_-_border: 2px solid red;\n\t\t *    --foo_-_color: initial;\n\t\t *    --foo_-_background: initial;\n\t\t *\n\t\t * This works but introduces one new issue.\n\t\t * Consider this setup at the point where the `@apply` is used:\n\t\t *\n\t\t *    background: orange;\n\t\t *    @apply --foo;\n\t\t *\n\t\t * In this case the background will be unset (initial) rather than the desired\n\t\t * `orange`. We address this by altering the property set to use a fallback\n\t\t * value like this:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background, orange);\n\t\t *    border: var(--foo_-_border);\n\t\t *\n\t\t * Note that the default is retained in the property set and the `background` is\n\t\t * the desired `orange`. This leads us to a limitation.\n\t\t *\n\t\t * Limitation 1:\n\t\t\n\t\t * Only properties in the rule where the `@apply`\n\t\t * is used are considered as default values.\n\t\t * If another rule matches the element and sets `background` with\n\t\t * less specificity than the rule in which `@apply` appears,\n\t\t * the `background` will not be set.\n\t\t *\n\t\t * Limitation 2:\n\t\t *\n\t\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t\t * `@apply` properties.\n\t\t\n\t\t*/\n\t\t\n\t\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\t\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\t\n\t\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\t\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\t\n\t\t// separator used between mixin-name and mixin-property-name when producing properties\n\t\t// NOTE: plain '-' may cause collisions in user styles\n\t\tvar MIXIN_VAR_SEP = '_-_';\n\t\t\n\t\t// map of mixin to property names\n\t\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\t\n\t\tvar MixinMap = function () {\n\t\t  function MixinMap() {\n\t\t    classCallCheck(this, MixinMap);\n\t\t\n\t\t    this._map = {};\n\t\t  }\n\t\t\n\t\t  createClass(MixinMap, [{\n\t\t    key: 'set',\n\t\t    value: function set(name, props) {\n\t\t      name = name.trim();\n\t\t      this._map[name] = {\n\t\t        properties: props,\n\t\t        dependants: {}\n\t\t      };\n\t\t    }\n\t\t  }, {\n\t\t    key: 'get',\n\t\t    value: function get(name) {\n\t\t      name = name.trim();\n\t\t      return this._map[name];\n\t\t    }\n\t\t  }]);\n\t\t  return MixinMap;\n\t\t}();\n\t\t\n\t\tvar ApplyShim = function () {\n\t\t  function ApplyShim() {\n\t\t    var _this = this;\n\t\t\n\t\t    classCallCheck(this, ApplyShim);\n\t\t\n\t\t    this._currentTemplate = null;\n\t\t    this._measureElement = null;\n\t\t    this._map = new MixinMap();\n\t\t    this._separator = MIXIN_VAR_SEP;\n\t\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t\t    };\n\t\t  }\n\t\t\n\t\t  createClass(ApplyShim, [{\n\t\t    key: 'transformStyle',\n\t\t    value: function transformStyle(style, elementName) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      this.transformRules(ast, elementName);\n\t\t      return ast;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRules',\n\t\t    value: function transformRules(rules, elementName) {\n\t\t      var _this2 = this;\n\t\t\n\t\t      this._currentTemplate = templateMap[elementName];\n\t\t      forEachRule(rules, function (r) {\n\t\t        _this2.transformRule(r);\n\t\t      });\n\t\t      if (this._currentTemplate) {\n\t\t        this._currentTemplate.__applyShimInvalid = false;\n\t\t      }\n\t\t      this._currentTemplate = null;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRule',\n\t\t    value: function transformRule(rule) {\n\t\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t\t      // :root was only used for variable assignment in property shim,\n\t\t      // but generates invalid selectors with real properties.\n\t\t      // replace with `:host > *`, which serves the same effect\n\t\t      if (rule.selector === ':root') {\n\t\t        rule.selector = ':host > *';\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformCssText',\n\t\t    value: function transformCssText(cssText) {\n\t\t      // produce variables\n\t\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t\t      // consume mixins\n\t\t      return this._consumeCssProperties(cssText);\n\t\t    }\n\t\t  }, {\n\t\t    key: '_getInitialValueForProperty',\n\t\t    value: function _getInitialValueForProperty(property) {\n\t\t      if (!this._measureElement) {\n\t\t        this._measureElement = document.createElement('meta');\n\t\t        this._measureElement.style.all = 'initial';\n\t\t        document.head.appendChild(this._measureElement);\n\t\t      }\n\t\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t\t    }\n\t\t    // replace mixin consumption with variable consumption\n\t\t\n\t\t  }, {\n\t\t    key: '_consumeCssProperties',\n\t\t    value: function _consumeCssProperties(text) {\n\t\t      var m = void 0;\n\t\t      // loop over text until all mixins with defintions have been applied\n\t\t      while (m = MIXIN_MATCH.exec(text)) {\n\t\t        var matchText = m[0];\n\t\t        var mixinName = m[1];\n\t\t        var idx = m.index;\n\t\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t\t        var applyPos = idx + matchText.indexOf('@apply');\n\t\t        var afterApplyPos = idx + matchText.length;\n\t\t        // find props defined before this @apply\n\t\t        var textBeforeApply = text.slice(0, applyPos);\n\t\t        var textAfterApply = text.slice(afterApplyPos);\n\t\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t\t        // use regex match position to replace mixin, keep linear processing time\n\t\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t\t        // move regex search to _after_ replacement\n\t\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t\t      }\n\t\t      return text;\n\t\t    }\n\t\t    // produce variable consumption at the site of mixin consumption\n\t\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t\t    // Example:\n\t\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\t\n\t\t  }, {\n\t\t    key: '_atApplyToCssProperties',\n\t\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t\t      var vars = [];\n\t\t      var mixinEntry = this._map.get(mixinName);\n\t\t      // if we depend on a mixin before it is created\n\t\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t\t      if (!mixinEntry) {\n\t\t        this._map.set(mixinName, {});\n\t\t        mixinEntry = this._map.get(mixinName);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        if (this._currentTemplate) {\n\t\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t\t        }\n\t\t        var p = void 0,\n\t\t            parts = void 0,\n\t\t            f = void 0;\n\t\t        for (p in mixinEntry.properties) {\n\t\t          f = fallbacks && fallbacks[p];\n\t\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t\t          if (f) {\n\t\t            parts.push(',', f);\n\t\t          }\n\t\t          parts.push(')');\n\t\t          vars.push(parts.join(''));\n\t\t        }\n\t\t      }\n\t\t      return vars.join('; ');\n\t\t    }\n\t\t  }, {\n\t\t    key: '_replaceInitialOrInherit',\n\t\t    value: function _replaceInitialOrInherit(property, value) {\n\t\t      var match = INITIAL_INHERIT.exec(value);\n\t\t      if (match) {\n\t\t        if (match[1]) {\n\t\t          // initial\n\t\t          // replace `initial` with the concrete initial value for this property\n\t\t          value = ApplyShim._getInitialValueForProperty(property);\n\t\t        } else {\n\t\t          // inherit\n\t\t          // with this purposfully illegal value, the variable will be invalid at\n\t\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t\t          // and for inheriting values, will behave similarly\n\t\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t\t          value = 'apply-shim-inherit';\n\t\t        }\n\t\t      }\n\t\t      return value;\n\t\t    }\n\t\t\n\t\t    // \"parse\" a mixin definition into a map of properties and values\n\t\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\t\n\t\t  }, {\n\t\t    key: '_cssTextToMap',\n\t\t    value: function _cssTextToMap(text) {\n\t\t      var props = text.split(';');\n\t\t      var property = void 0,\n\t\t          value = void 0;\n\t\t      var out = {};\n\t\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t\t        p = props[i];\n\t\t        if (p) {\n\t\t          sp = p.split(':');\n\t\t          // ignore lines that aren't definitions like @media\n\t\t          if (sp.length > 1) {\n\t\t            property = sp[0].trim();\n\t\t            // some properties may have ':' in the value, like data urls\n\t\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t\t            out[property] = value;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return out;\n\t\t    }\n\t\t  }, {\n\t\t    key: '_invalidateMixinEntry',\n\t\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t\t      for (var elementName in mixinEntry.dependants) {\n\t\t        if (elementName !== this._currentTemplate) {\n\t\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: '_produceCssProperties',\n\t\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t\t      var _this3 = this;\n\t\t\n\t\t      // handle case where property value is a mixin\n\t\t      if (valueProperty) {\n\t\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t\t          if (value && _this3._map.get(value)) {\n\t\t            valueMixin = '@apply ' + value + ';';\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      if (!valueMixin) {\n\t\t        return matchText;\n\t\t      }\n\t\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t\t      var combinedProps = mixinValues;\n\t\t      var mixinEntry = this._map.get(propertyName);\n\t\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t\t      if (oldProps) {\n\t\t        // NOTE: since we use mixin, the map of properties is updated here\n\t\t        // and this is what we want.\n\t\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t\t      } else {\n\t\t        this._map.set(propertyName, combinedProps);\n\t\t      }\n\t\t      var out = [];\n\t\t      var p = void 0,\n\t\t          v = void 0;\n\t\t      // set variables defined by current mixin\n\t\t      var needToInvalidate = false;\n\t\t      for (p in combinedProps) {\n\t\t        v = mixinValues[p];\n\t\t        // if property not defined by current mixin, set initial\n\t\t        if (v === undefined) {\n\t\t          v = 'initial';\n\t\t        }\n\t\t        if (oldProps && !(p in oldProps)) {\n\t\t          needToInvalidate = true;\n\t\t        }\n\t\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t\t      }\n\t\t      if (needToInvalidate) {\n\t\t        this._invalidateMixinEntry(mixinEntry);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        mixinEntry.properties = combinedProps;\n\t\t      }\n\t\t      // because the mixinMap is global, the mixin might conflict with\n\t\t      // a different scope's simple variable definition:\n\t\t      // Example:\n\t\t      // some style somewhere:\n\t\t      // --mixin1:{ ... }\n\t\t      // --mixin2: var(--mixin1);\n\t\t      // some other element:\n\t\t      // --mixin1: 10px solid red;\n\t\t      // --foo: var(--mixin1);\n\t\t      // In this case, we leave the original variable definition in place.\n\t\t      if (valueProperty) {\n\t\t        prefix = matchText + ';' + prefix;\n\t\t      }\n\t\t      return prefix + out.join('; ') + ';';\n\t\t    }\n\t\t  }]);\n\t\t  return ApplyShim;\n\t\t}();\n\t\t\n\t\tvar applyShim = new ApplyShim();\n\t\twindow['ApplyShim'] = applyShim;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar flush = function flush() {};\n\t\t\n\t\tif (!nativeShadow) {\n\t\t  (function () {\n\t\t    var handler = function handler(mxns) {\n\t\t      for (var x = 0; x < mxns.length; x++) {\n\t\t        var mxn = mxns[x];\n\t\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t\t          var n = mxn.addedNodes[i];\n\t\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t\t            var root = n.getRootNode();\n\t\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t              // may no longer be in a shadowroot\n\t\t              var host = root.host;\n\t\t              if (host) {\n\t\t                var scope = host.is || host.localName;\n\t\t                StyleTransformer.dom(n, scope);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t\t          var _n = mxn.removedNodes[_i];\n\t\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t\t            if (classIdx >= 0) {\n\t\t              // NOTE: relies on the scoping class always being adjacent to the\n\t\t              // SCOPE_NAME class.\n\t\t              var _scope = _n.classList[classIdx + 1];\n\t\t              if (_scope) {\n\t\t                StyleTransformer.dom(_n, _scope, true);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    };\n\t\t\n\t\t    var observer = new MutationObserver(handler);\n\t\t    var startState = 'interactive';\n\t\t\n\t\t    var start = function start() {\n\t\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t\t    };\n\t\t    if (window.HTMLImports) {\n\t\t      window.HTMLImports.whenReady(start);\n\t\t    } else if (document.readyState === startState) {\n\t\t      requestAnimationFrame(start);\n\t\t    } else {\n\t\t      document.addEventListener('readystatechange', function () {\n\t\t        if (document.readyState === startState) {\n\t\t          start();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t\n\t\t    flush = function flush() {\n\t\t      handler(observer.takeRecords());\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(dfreedm): consider spliting into separate global\n\t\tvar styleCache = new StyleCache();\n\t\t\n\t\tvar ShadyCSS = {\n\t\t  flush: flush,\n\t\t  scopeCounter: {},\n\t\t  nativeShadow: nativeShadow,\n\t\t  nativeCss: nativeCssVariables,\n\t\t  nativeCssApply: nativeCssApply,\n\t\t  _documentOwner: document.documentElement,\n\t\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t\t    return name + '-' + id;\n\t\t  },\n\t\t  getStyleAst: function getStyleAst(style) {\n\t\t    return rulesForStyle(style);\n\t\t  },\n\t\t  styleAstToString: function styleAstToString(ast) {\n\t\t    return toCssText(ast);\n\t\t  },\n\t\t  _gatherStyles: function _gatherStyles(template) {\n\t\t    var styles = template.content.querySelectorAll('style');\n\t\t    var cssText = [];\n\t\t    for (var i = 0; i < styles.length; i++) {\n\t\t      var s = styles[i];\n\t\t      cssText.push(s.textContent);\n\t\t      s.parentNode.removeChild(s);\n\t\t    }\n\t\t    return cssText.join('').trim();\n\t\t  },\n\t\t  _getCssBuild: function _getCssBuild(template) {\n\t\t    var style = template.content.querySelector('style');\n\t\t    if (!style) {\n\t\t      return '';\n\t\t    }\n\t\t    return style.getAttribute('css-build') || '';\n\t\t  },\n\t\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t\t    if (template._prepared) {\n\t\t      return;\n\t\t    }\n\t\t    template._prepared = true;\n\t\t    template.name = elementName;\n\t\t    template.extends = typeExtension;\n\t\t    templateMap[elementName] = template;\n\t\t    var cssBuild = this._getCssBuild(template);\n\t\t    var cssText = this._gatherStyles(template);\n\t\t    var info = {\n\t\t      is: elementName,\n\t\t      extends: typeExtension,\n\t\t      __cssBuild: cssBuild\n\t\t    };\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleTransformer.dom(template.content, elementName);\n\t\t    }\n\t\t    var ast = parse(cssText);\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      applyShim.transformRules(ast, elementName);\n\t\t    }\n\t\t    template._styleAst = ast;\n\t\t\n\t\t    var ownPropertyNames = [];\n\t\t    if (!this.nativeCss) {\n\t\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t\t    }\n\t\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t\t      var root = this.nativeShadow ? template.content : null;\n\t\t      var placeholder = placeholderMap[elementName];\n\t\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t\t      template._style = style;\n\t\t    }\n\t\t    template._ownPropertyNames = ownPropertyNames;\n\t\t  },\n\t\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t\t    if (cssText.length) {\n\t\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t\t    }\n\t\t  },\n\t\t  _prepareHost: function _prepareHost(host) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var typeExtension = void 0;\n\t\t    if (is !== host.localName) {\n\t\t      typeExtension = host.localName;\n\t\t    }\n\t\t    var placeholder = placeholderMap[is];\n\t\t    var template = templateMap[is];\n\t\t    var ast = void 0;\n\t\t    var ownStylePropertyNames = void 0;\n\t\t    var cssBuild = void 0;\n\t\t    if (template) {\n\t\t      ast = template._styleAst;\n\t\t      ownStylePropertyNames = template._ownPropertyNames;\n\t\t      cssBuild = template._cssBuild;\n\t\t    }\n\t\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t\t  },\n\t\t  applyStyle: function applyStyle(host, overrideProps) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    if (window.CustomStyle) {\n\t\t      var CS = window.CustomStyle;\n\t\t      if (CS._documentDirty) {\n\t\t        CS.findStyles();\n\t\t        if (!this.nativeCss) {\n\t\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t\t        } else if (!this.nativeCssApply) {\n\t\t          CS._revalidateApplyShim();\n\t\t        }\n\t\t        CS.applyStyles();\n\t\t        CS._documentDirty = false;\n\t\t      }\n\t\t    }\n\t\t    var styleInfo = StyleInfo.get(host);\n\t\t    if (!styleInfo) {\n\t\t      styleInfo = this._prepareHost(host);\n\t\t    }\n\t\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t\t    if (this.nativeCss) {\n\t\t      var template = templateMap[is];\n\t\t      if (template && template.__applyShimInvalid && template._style) {\n\t\t        // update template\n\t\t        applyShim.transformRules(template._styleAst, is);\n\t\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        // update instance if native shadowdom\n\t\t        if (this.nativeShadow) {\n\t\t          var style = host.shadowRoot.querySelector('style');\n\t\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        }\n\t\t        styleInfo.styleRules = template._styleAst;\n\t\t      }\n\t\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t\t    } else {\n\t\t      this._updateProperties(host, styleInfo);\n\t\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t\t        // TODO: use caching\n\t\t        this._applyStyleProperties(host, styleInfo);\n\t\t      }\n\t\t    }\n\t\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t\t    // note: some elements may not have a root!\n\t\t    if (root) {\n\t\t      this._applyToDescendants(root);\n\t\t    }\n\t\t  },\n\t\t  _applyToDescendants: function _applyToDescendants(root) {\n\t\t    var c$ = root.children;\n\t\t    for (var i = 0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (c.shadowRoot) {\n\t\t        this.applyStyle(c);\n\t\t      }\n\t\t      this._applyToDescendants(c);\n\t\t    }\n\t\t  },\n\t\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t\t    var root = node.getRootNode();\n\t\t    var host = root.host;\n\t\t    if (host) {\n\t\t      if (StyleInfo.get(host)) {\n\t\t        return host;\n\t\t      } else {\n\t\t        return this._styleOwnerForNode(host);\n\t\t      }\n\t\t    }\n\t\t    return this._documentOwner;\n\t\t  },\n\t\t  _isRootOwner: function _isRootOwner(node) {\n\t\t    return node === this._documentOwner;\n\t\t  },\n\t\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t\t    // only generate new scope if cached style is not found\n\t\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t\t    }\n\t\t    if (!cacheEntry) {\n\t\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t\t    var owner = this._styleOwnerForNode(host);\n\t\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t\t    var props = Object.create(ownerProperties || null);\n\t\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t\t    var propertiesMatchingHost = propertyData.properties;\n\t\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t\t    StyleProperties.reify(props);\n\t\t    styleInfo.styleProperties = props;\n\t\t  },\n\t\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t\t    for (var p in overrides) {\n\t\t      var v = overrides[p];\n\t\t      // skip override props if they are not truthy or 0\n\t\t      // in order to fall back to inherited values\n\t\t      if (v || v === 0) {\n\t\t        props[p] = v;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t\t    // remove previous properties\n\t\t    for (var p in properties) {\n\t\t      // NOTE: for bc with shim, don't apply null values.\n\t\t      if (p === null) {\n\t\t        element.style.removeProperty(p);\n\t\t      } else {\n\t\t        element.style.setProperty(p, properties[p]);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  updateStyles: function updateStyles(properties) {\n\t\t    if (window.CustomStyle) {\n\t\t      window.CustomStyle._documentDirty = true;\n\t\t    }\n\t\t    this.applyStyle(this._documentOwner, properties);\n\t\t  },\n\t\t\n\t\t  /* Custom Style operations */\n\t\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t\t    var _this = this;\n\t\t\n\t\t    var ast = rulesForStyle(style);\n\t\t    forEachRule(ast, function (rule) {\n\t\t      if (nativeShadow) {\n\t\t        StyleTransformer.normalizeRootSelector(rule);\n\t\t      } else {\n\t\t        StyleTransformer.documentRule(rule);\n\t\t      }\n\t\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t\t        applyShim.transformRule(rule);\n\t\t      }\n\t\t    });\n\t\t    if (this.nativeCss) {\n\t\t      style.textContent = toCssText(ast);\n\t\t    } else {\n\t\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t\t    }\n\t\t  },\n\t\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      applyShim.transformRules(ast);\n\t\t      style.textContent = toCssText(ast);\n\t\t    }\n\t\t  },\n\t\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t\t    if (!this.nativeCss) {\n\t\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t\t    }\n\t\t  },\n\t\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t\t    var value = void 0;\n\t\t    if (!this.nativeCss) {\n\t\t      // element is either a style host, or an ancestor of a style host\n\t\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t\t      value = styleInfo.styleProperties[property];\n\t\t    }\n\t\t    // fall back to the property value from the computed styling\n\t\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t\t    // trim whitespace that can come after the `:` in css\n\t\t    // example: padding: 2px -> \" 2px\"\n\t\t    return value.trim();\n\t\t  },\n\t\t\n\t\t  // given an element and a classString, replaces\n\t\t  // the element's class with the provided classString and adds\n\t\t  // any necessary ShadyCSS static and property based scoping selectors\n\t\t  // NOTE: this method is suitable to be called in an environment in which\n\t\t  // setAttribute('class', ...) and className setter have been overridden so\n\t\t  // it cannot rely on those methods.\n\t\t  setElementClass: function setElementClass(element, classString) {\n\t\t    var _element$classList;\n\t\t\n\t\t    // use classList to clear existing classes\n\t\t    while (element.classList.length) {\n\t\t      element.classList.remove(element.classList[0]);\n\t\t    }\n\t\t    // add user classString\n\t\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t\t    // add static scoping: scope by shadyRoot\n\t\t    var root = element.getRootNode();\n\t\t    if (root.host) {\n\t\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t\t    }\n\t\t    // add property scoping: scope by special selector\n\t\t    if (!this.nativeCss) {\n\t\t      var styleInfo = StyleInfo.get(element);\n\t\t      if (styleInfo && styleInfo.scopeSelector) {\n\t\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t\t    return StyleInfo.get(node);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow['ShadyCSS'] = ShadyCSS;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\t\n\t\tExample:\n\t\t<shady-style>\n\t\t  <style>\n\t\t  ...\n\t\t  </style>\n\t\t</shady-style>\n\t\t*/\n\t\t\n\t\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\t\n\t\tvar enqueued = false;\n\t\t\n\t\tvar customStyles = [];\n\t\t\n\t\tvar hookFn = null;\n\t\t\n\t\t/*\n\t\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\t\tas all the instances will boot asynchronously after page load.\n\t\t\n\t\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t\t*/\n\t\tfunction enqueueDocumentValidation() {\n\t\t  if (enqueued) {\n\t\t    return;\n\t\t  }\n\t\t  enqueued = true;\n\t\t  if (window.HTMLImports) {\n\t\t    window.HTMLImports.whenReady(validateDocument);\n\t\t  } else if (document.readyState === 'complete') {\n\t\t    requestAnimationFrame(validateDocument);\n\t\t  } else {\n\t\t    document.addEventListener('readystatechange', function () {\n\t\t      if (document.readyState === 'complete') {\n\t\t        validateDocument();\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t}\n\t\t\n\t\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t\t// helps ensure that the first run of validateDocument will actually\n\t\t// have access to all the custom-style's created via loading imports.\n\t\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t\t// then the enqueue immediately calls validateDocument and work that could be\n\t\t// batched is not.\n\t\tenqueueDocumentValidation();\n\t\t\n\t\tfunction validateDocument() {\n\t\t  if (enqueued) {\n\t\t    ShadyCSS$1.updateStyles();\n\t\t    enqueued = false;\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction CustomStyle() {\n\t\t  /*\n\t\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t\t  CustomElement polyfill replacement that can be `.call`ed\n\t\t  */\n\t\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t\t  customStyles.push(self);\n\t\t  enqueueDocumentValidation();\n\t\t  return self;\n\t\t}\n\t\t\n\t\tObject.defineProperties(CustomStyle, {\n\t\t  /*\n\t\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t\t   The function must take a <style> element as input, and return nothing.\n\t\t  */\n\t\t  processHook: {\n\t\t    get: function get() {\n\t\t      return hookFn;\n\t\t    },\n\t\t    set: function set(fn) {\n\t\t      hookFn = fn;\n\t\t      return fn;\n\t\t    }\n\t\t  },\n\t\t  _customStyles: {\n\t\t    get: function get() {\n\t\t      return customStyles;\n\t\t    }\n\t\t  },\n\t\t  _documentDirty: {\n\t\t    get: function get() {\n\t\t      return enqueued;\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      enqueued = value;\n\t\t      return value;\n\t\t    }\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.findStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._findStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle._revalidateApplyShim = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    var s = customStyles[i];\n\t\t    if (s._style) {\n\t\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.applyStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._applyStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t\t  'constructor': {\n\t\t    value: CustomStyle,\n\t\t    configurable: true,\n\t\t    writable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.prototype._findStyle = function () {\n\t\t  if (!this._style) {\n\t\t    var style = this.querySelector('style');\n\t\t    if (!style) {\n\t\t      return;\n\t\t    }\n\t\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t\t    // which is referenced with __appliedElement.\n\t\t    // Also, we must copy over the attributes.\n\t\t    if (style.__appliedElement) {\n\t\t      for (var i = 0; i < style.attributes.length; i++) {\n\t\t        var attr = style.attributes[i];\n\t\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t\t      }\n\t\t    }\n\t\t    this._style = style.__appliedElement || style;\n\t\t    if (hookFn) {\n\t\t      hookFn(this._style);\n\t\t    }\n\t\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype._applyStyle = function () {\n\t\t  if (this._style) {\n\t\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow.customElements.define('custom-style', CustomStyle);\n\t\twindow['CustomStyle'] = CustomStyle;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/*\n\t\tSmall module to load ShadyCSS and CustomStyle together\n\t\t*/\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadycss.min.js.map\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(3), __webpack_require__(4)) :\n\t  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n\t  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n\t}(this, (function (exports,incrementalDom,root) {\n\t\n\troot = 'default' in root ? root['default'] : root;\n\t\n\tfunction keys() {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  var _ref$enumOnly = _ref.enumOnly;\n\t  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\t\n\t  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n\t  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n\t}\n\t\n\t// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n\t// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\n\tvar assign = (function (obj) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  args.forEach(function (arg) {\n\t    return keys(arg).forEach(function (name) {\n\t      return obj[name] = arg[name];\n\t    });\n\t  }); // eslint-disable-line no-return-assign\n\t  return obj;\n\t});\n\t\n\tvar empty = function (val) {\n\t  return typeof val === 'undefined' || val === null;\n\t};\n\t\n\tvar alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {\n\t  return isNaN(val) ? undefined : Number(val);\n\t};\n\tvar alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n\t  return empty(val) ? undefined : String(val);\n\t};\n\t\n\tfunction create(def) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args.unshift({}, def);\n\t    return assign.apply(undefined, args);\n\t  };\n\t}\n\t\n\tvar array = create({\n\t  coerce: function coerce(val) {\n\t    return Array.isArray(val) ? val : [val];\n\t  },\n\t  default: function _default() {\n\t    return [];\n\t  },\n\t  deserialize: JSON.parse,\n\t  serialize: JSON.stringify\n\t});\n\t\n\tvar boolean = create({\n\t  coerce: function coerce(value) {\n\t    return !!value;\n\t  },\n\t  default: false,\n\t  deserialize: function deserialize(value) {\n\t    return !(value === null);\n\t  },\n\t  serialize: function serialize(value) {\n\t    return value ? '' : undefined;\n\t  }\n\t});\n\t\n\tvar number = create({\n\t  default: 0,\n\t  coerce: alwaysUndefinedIfNotANumberOrNumber,\n\t  deserialize: alwaysUndefinedIfNotANumberOrNumber,\n\t  serialize: alwaysUndefinedIfNotANumberOrNumber\n\t});\n\t\n\tvar string = create({\n\t  default: '',\n\t  coerce: alwaysUndefinedIfEmptyOrString,\n\t  deserialize: alwaysUndefinedIfEmptyOrString,\n\t  serialize: alwaysUndefinedIfEmptyOrString\n\t});\n\t\n\tvar prop = Object.freeze({\n\t\tcreate: create,\n\t\tarray: array,\n\t\tboolean: boolean,\n\t\tnumber: number,\n\t\tstring: string\n\t});\n\t\n\tvar connected = '____skate_connected';\n\tvar created$1 = '____skate_created';\n\t\n\t// DEPRECATED\n\t//\n\t// This is the only \"symbol\" that must stay a string. This is because it is\n\t// relied upon across several versions. We should remove it, but ensure that\n\t// it's considered a breaking change that whatever version removes it cannot\n\t// be passed to vdom functions as tag names.\n\tvar name = '____skate_name';\n\t\n\t// Used on the Constructor\n\tvar ctorCreateInitProps = '____skate_ctor_createInitProps';\n\tvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\n\tvar ctorProps = '____skate_ctor_props';\n\tvar ctorPropsMap = '____skate_ctor_propsMap';\n\t\n\t// Used on the Element\n\tvar props = '____skate_props';\n\tvar ref$1 = '____skate_ref';\n\tvar renderer$1 = '____skate_renderer';\n\tvar rendering = '____skate_rendering';\n\tvar rendererDebounced = '____skate_rendererDebounced';\n\tvar updated$1 = '____skate_updated';\n\t\n\t// DEPRECTAED\n\t//\n\t// We should not be relying on internals for symbols as this creates version\n\t// coupling. We will move forward with platform agnostic ways of doing this.\n\t\n\t\n\tvar symbols$1 = Object.freeze({\n\t\tname: name\n\t});\n\t\n\tfunction enter(object, props) {\n\t  var saved = {};\n\t  Object.keys(props).forEach(function (key) {\n\t    saved[key] = object[key];\n\t    object[key] = props[key];\n\t  });\n\t  return saved;\n\t}\n\t\n\tfunction exit(object, saved) {\n\t  assign(object, saved);\n\t}\n\t\n\t// Decorates a function with a side effect that changes the properties of an\n\t// object during its execution, and restores them after. There is no error\n\t// handling here, if the wrapped function throws an error, properties are not\n\t// restored and all bets are off.\n\tvar propContext = function (object, props) {\n\t  return function (func) {\n\t    return function () {\n\t      var saved = enter(object, props);\n\t      var result = func.apply(undefined, arguments);\n\t      exit(object, saved);\n\t      return result;\n\t    };\n\t  };\n\t};\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\t\n\t\n\t\n\t\n\t\n\tvar asyncGenerator = function () {\n\t  function AwaitValue(value) {\n\t    this.value = value;\n\t  }\n\t\n\t  function AsyncGenerator(gen) {\n\t    var front, back;\n\t\n\t    function send(key, arg) {\n\t      return new Promise(function (resolve, reject) {\n\t        var request = {\n\t          key: key,\n\t          arg: arg,\n\t          resolve: resolve,\n\t          reject: reject,\n\t          next: null\n\t        };\n\t\n\t        if (back) {\n\t          back = back.next = request;\n\t        } else {\n\t          front = back = request;\n\t          resume(key, arg);\n\t        }\n\t      });\n\t    }\n\t\n\t    function resume(key, arg) {\n\t      try {\n\t        var result = gen[key](arg);\n\t        var value = result.value;\n\t\n\t        if (value instanceof AwaitValue) {\n\t          Promise.resolve(value.value).then(function (arg) {\n\t            resume(\"next\", arg);\n\t          }, function (arg) {\n\t            resume(\"throw\", arg);\n\t          });\n\t        } else {\n\t          settle(result.done ? \"return\" : \"normal\", result.value);\n\t        }\n\t      } catch (err) {\n\t        settle(\"throw\", err);\n\t      }\n\t    }\n\t\n\t    function settle(type, value) {\n\t      switch (type) {\n\t        case \"return\":\n\t          front.resolve({\n\t            value: value,\n\t            done: true\n\t          });\n\t          break;\n\t\n\t        case \"throw\":\n\t          front.reject(value);\n\t          break;\n\t\n\t        default:\n\t          front.resolve({\n\t            value: value,\n\t            done: false\n\t          });\n\t          break;\n\t      }\n\t\n\t      front = front.next;\n\t\n\t      if (front) {\n\t        resume(front.key, front.arg);\n\t      } else {\n\t        back = null;\n\t      }\n\t    }\n\t\n\t    this._invoke = send;\n\t\n\t    if (typeof gen.return !== \"function\") {\n\t      this.return = undefined;\n\t    }\n\t  }\n\t\n\t  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n\t    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n\t      return this;\n\t    };\n\t  }\n\t\n\t  AsyncGenerator.prototype.next = function (arg) {\n\t    return this._invoke(\"next\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.throw = function (arg) {\n\t    return this._invoke(\"throw\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.return = function (arg) {\n\t    return this._invoke(\"return\", arg);\n\t  };\n\t\n\t  return {\n\t    wrap: function (fn) {\n\t      return function () {\n\t        return new AsyncGenerator(fn.apply(this, arguments));\n\t      };\n\t    },\n\t    await: function (value) {\n\t      return new AwaitValue(value);\n\t    }\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar defineProperty = function (obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\t\n\t  return obj;\n\t};\n\t\n\tvar get$1 = function get$1(object, property, receiver) {\n\t  if (object === null) object = Function.prototype;\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent === null) {\n\t      return undefined;\n\t    } else {\n\t      return get$1(parent, property, receiver);\n\t    }\n\t  } else if (\"value\" in desc) {\n\t    return desc.value;\n\t  } else {\n\t    var getter = desc.get;\n\t\n\t    if (getter === undefined) {\n\t      return undefined;\n\t    }\n\t\n\t    return getter.call(receiver);\n\t  }\n\t};\n\t\n\tvar inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\t\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar possibleConstructorReturn = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/* eslint no-plusplus: 0 */\n\t\n\tvar customElements = root.customElements;\n\tvar HTMLElement = root.HTMLElement;\n\t\n\tvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\t\n\t// A stack of children that corresponds to the current function helper being\n\t// executed.\n\tvar stackChren = [];\n\t\n\tvar $skip = '__skip';\n\tvar $currentEventHandlers = '__events';\n\tvar $stackCurrentHelperProps = '__props';\n\t\n\t// The current function helper in the stack.\n\tvar stackCurrentHelper = void 0;\n\t\n\t// This is used for the Incremental DOM overrides to keep track of what args\n\t// to pass the main elementOpen() function.\n\tvar overrideArgs = void 0;\n\t\n\t// The number of levels deep after skipping a tree.\n\tvar skips = 0;\n\t\n\tvar noop = function noop() {};\n\t\n\t// Adds or removes an event listener for an element.\n\tfunction applyEvent(elem, ename, newFunc) {\n\t  var events = elem[$currentEventHandlers];\n\t\n\t  if (!events) {\n\t    events = elem[$currentEventHandlers] = {};\n\t  }\n\t\n\t  // Undefined indicates that there is no listener yet.\n\t  if (typeof events[ename] === 'undefined') {\n\t    // We only add a single listener once. Originally this was a workaround for\n\t    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n\t    // also a simpler model for binding / unbinding events because you only\n\t    // have a single handler you need to worry about and a single place where\n\t    // you only store one event handler\n\t    elem.addEventListener(ename, function (e) {\n\t      if (events[ename]) {\n\t        events[ename].call(this, e);\n\t      }\n\t    });\n\t  }\n\t\n\t  // Not undefined indicates that we have set a listener, so default to null.\n\t  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n\t}\n\t\n\tvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n\t  // Attributes that shouldn't be applied to the DOM.\n\t  key: noop,\n\t  statics: noop,\n\t\n\t  // Attributes that *must* be set via a property on all elements.\n\t  checked: incrementalDom.applyProp,\n\t  className: incrementalDom.applyProp,\n\t  disabled: incrementalDom.applyProp,\n\t  value: incrementalDom.applyProp,\n\t\n\t  // Ref handler.\n\t  ref: function ref(elem, name$$1, value) {\n\t    elem[ref$1] = value;\n\t  },\n\t\n\t\n\t  // Skip handler.\n\t  skip: function skip(elem, name$$1, value) {\n\t    if (value) {\n\t      elem[$skip] = true;\n\t    } else {\n\t      delete elem[$skip];\n\t    }\n\t  }\n\t}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n\t  var _ref = customElements.get(elem.localName) || {\n\t    props: {},\n\t    prototype: {}\n\t  };\n\t\n\t  var props$$1 = _ref.props;\n\t  var prototype = _ref.prototype;\n\t\n\t  // TODO when refactoring properties to not have to workaround the old\n\t  // WebKit bug we can remove the \"name in props\" check below.\n\t  //\n\t  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n\t  // elements that set a property that isn't explicitly specified in \"props\"\n\t  // or \"prototype\" unless it is added to the element explicitly as a\n\t  // property prior to passing the prop to the vdom function. For example, if\n\t  // it were added in a lifecycle callback because it wouldn't have been\n\t  // upgraded yet.\n\t  //\n\t  // We prefer setting props, so we do this if there's a property matching\n\t  // name that was passed. However, certain props on SVG elements are\n\t  // readonly and error when you try to set them.\n\t\n\t  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n\t    incrementalDom.applyProp(elem, name$$1, value);\n\t    return;\n\t  }\n\t\n\t  // Explicit false removes the attribute.\n\t  if (value === false) {\n\t    applyDefault(elem, name$$1);\n\t    return;\n\t  }\n\t\n\t  // Handle built-in and custom events.\n\t  if (name$$1.indexOf('on') === 0) {\n\t    var firstChar = name$$1[2];\n\t    var eventName = void 0;\n\t\n\t    if (firstChar === '-') {\n\t      eventName = name$$1.substring(3);\n\t    } else if (firstChar === firstChar.toUpperCase()) {\n\t      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n\t    }\n\t\n\t    if (eventName) {\n\t      applyEvent(elem, eventName, value);\n\t      return;\n\t    }\n\t  }\n\t\n\t  applyDefault(elem, name$$1, value);\n\t}));\n\t\n\tfunction resolveTagName(name$$1) {\n\t  // We return falsy values as some wrapped IDOM functions allow empty values.\n\t  if (!name$$1) {\n\t    return name$$1;\n\t  }\n\t\n\t  // We try and return the cached tag name, if one exists.\n\t  if (name$$1[name]) {\n\t    return name$$1[name];\n\t  }\n\t\n\t  // If it's a custom element, we get the tag name by constructing it and\n\t  // caching it.\n\t  if (name$$1.prototype instanceof HTMLElement) {\n\t    // eslint-disable-next-line\n\t    var elem = new name$$1();\n\t    return name$$1[name] = elem.localName;\n\t  }\n\t\n\t  // Pass all other values through so IDOM gets what it's expecting.\n\t  return name$$1;\n\t}\n\t\n\t// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n\t// so it's the only function we need to execute in the context of our attributes.\n\tvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\t\n\tfunction elementOpenStart(tag) {\n\t  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t  overrideArgs = [tag, key, statics];\n\t}\n\t\n\tfunction elementOpenEnd() {\n\t  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n\t  overrideArgs = null;\n\t  return node;\n\t}\n\t\n\tfunction wrapIdomFunc(func) {\n\t  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\t\n\t  return function wrap() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args[0] = resolveTagName(args[0]);\n\t    stackCurrentHelper = null;\n\t    if (typeof args[0] === 'function') {\n\t      // If we've encountered a function, handle it according to the type of\n\t      // function that is being wrapped.\n\t      stackCurrentHelper = args[0];\n\t      return tnameFuncHandler.apply(undefined, args);\n\t    } else if (stackChren.length) {\n\t      // We pass the wrap() function in here so that when it's called as\n\t      // children, it will queue up for the next stack, if there is one.\n\t      stackChren[stackChren.length - 1].push([wrap, args]);\n\t    } else {\n\t      if (func === elementOpen$1) {\n\t        if (skips) {\n\t          return ++skips;\n\t        }\n\t\n\t        var elem = func.apply(undefined, args);\n\t\n\t        if (elem[$skip]) {\n\t          ++skips;\n\t        }\n\t\n\t        return elem;\n\t      }\n\t\n\t      if (func === incrementalDom.elementClose) {\n\t        if (skips === 1) {\n\t          incrementalDom.skip();\n\t        }\n\t\n\t        // We only want to skip closing if it's not the last closing tag in the\n\t        // skipped tree because we keep the element that initiated the skpping.\n\t        if (skips && --skips) {\n\t          return;\n\t        }\n\t\n\t        var _elem = func.apply(undefined, args);\n\t        var ref$$1 = _elem[ref$1];\n\t\n\t        // We delete so that it isn't called again for the same element. If the\n\t        // ref changes, or the element changes, this will be defined again.\n\t        delete _elem[ref$1];\n\t\n\t        // Execute the saved ref after esuring we've cleand up after it.\n\t        if (typeof ref$$1 === 'function') {\n\t          ref$$1(_elem);\n\t        }\n\t\n\t        return _elem;\n\t      }\n\t\n\t      // We must call elementOpenStart and elementOpenEnd even if we are\n\t      // skipping because they queue up attributes and then call elementClose.\n\t      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n\t        return func.apply(undefined, args);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction newAttr() {\n\t  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t    args[_key2] = arguments[_key2];\n\t  }\n\t\n\t  if (stackCurrentHelper) {\n\t    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n\t  } else if (stackChren.length) {\n\t    stackChren[stackChren.length - 1].push([newAttr, args]);\n\t  } else {\n\t    overrideArgs.push(args[0]);\n\t    overrideArgs.push(args[1]);\n\t  }\n\t}\n\t\n\tfunction stackOpen(tname, key, statics) {\n\t  var props$$1 = { key: key, statics: statics };\n\t\n\t  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n\t    attrs[_key3 - 3] = arguments[_key3];\n\t  }\n\t\n\t  for (var a = 0; a < attrs.length; a += 2) {\n\t    props$$1[attrs[a]] = attrs[a + 1];\n\t  }\n\t  tname[$stackCurrentHelperProps] = props$$1;\n\t  stackChren.push([]);\n\t}\n\t\n\tfunction stackClose(tname) {\n\t  var chren = stackChren.pop();\n\t  var props$$1 = tname[$stackCurrentHelperProps];\n\t  delete tname[$stackCurrentHelperProps];\n\t  var elemOrFn = tname(props$$1, function () {\n\t    return chren.forEach(function (args) {\n\t      return args[0].apply(args, toConsumableArray(args[1]));\n\t    });\n\t  });\n\t  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n\t}\n\t\n\t// Incremental DOM overrides\n\t// -------------------------\n\t\n\t// We must override internal functions that call internal Incremental DOM\n\t// functions because we can't override the internal references. This means\n\t// we must roughly re-implement their behaviour. Luckily, they're fairly\n\t// simple.\n\tvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\n\tvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\t\n\t// Standard open / closed overrides don't need to reproduce internal behaviour\n\t// because they are the ones referenced from *End and *Start.\n\tvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\n\tvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\t\n\t// Ensure we call our overridden functions instead of the internal ones.\n\tfunction newElementVoid(tag) {\n\t  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t    args[_key4 - 1] = arguments[_key4];\n\t  }\n\t\n\t  newElementOpen.apply(undefined, [tag].concat(args));\n\t  return newElementClose(tag);\n\t}\n\t\n\t// Text override ensures their calls can queue if using function helpers.\n\tvar newText = wrapIdomFunc(incrementalDom.text);\n\t\n\t// Convenience function for declaring an Incremental DOM element using\n\t// hyperscript-style syntax.\n\tfunction element(tname, attrs) {\n\t  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\t\n\t  // If attributes are a function, then they should be treated as children.\n\t\n\t  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n\t    chren[_key5 - 2] = arguments[_key5];\n\t  }\n\t\n\t  if (atype === 'function' || atype === 'string' || atype === 'number') {\n\t    chren.unshift(attrs);\n\t  }\n\t\n\t  // Ensure the attributes are an object. Null is considered an object so we\n\t  // have to test for this explicitly.\n\t  if (attrs === null || atype !== 'object') {\n\t    attrs = {};\n\t  }\n\t\n\t  // We open the element so we can set attrs after.\n\t  newElementOpenStart(tname, attrs.key, attrs.statics);\n\t\n\t  // Delete so special attrs don't actually get set.\n\t  delete attrs.key;\n\t  delete attrs.statics;\n\t\n\t  // Set attributes.\n\t  Object.keys(attrs).forEach(function (name$$1) {\n\t    return newAttr(name$$1, attrs[name$$1]);\n\t  });\n\t\n\t  // Close before we render the descendant tree.\n\t  newElementOpenEnd(tname);\n\t\n\t  chren.forEach(function (ch) {\n\t    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n\t    if (ctype === 'function') {\n\t      ch();\n\t    } else if (ctype === 'string' || ctype === 'number') {\n\t      newText(ch);\n\t    } else if (Array.isArray(ch)) {\n\t      ch.forEach(function (sch) {\n\t        return sch();\n\t      });\n\t    }\n\t  });\n\t\n\t  return newElementClose(tname);\n\t}\n\t\n\t// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n\t// transpiles for JSX (React.createElement() / h).\n\tfunction builder() {\n\t  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n\t    tags[_key6] = arguments[_key6];\n\t  }\n\t\n\t  if (tags.length === 0) {\n\t    return function () {\n\t      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n\t        args[_key7] = arguments[_key7];\n\t      }\n\t\n\t      return element.bind.apply(element, [null].concat(args));\n\t    };\n\t  }\n\t  return tags.map(function (tag) {\n\t    return function () {\n\t      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n\t        args[_key8] = arguments[_key8];\n\t      }\n\t\n\t      return element.bind.apply(element, [null, tag].concat(args));\n\t    };\n\t  });\n\t}\n\t\n\t\n\t\n\tvar vdom = Object.freeze({\n\t\telement: element,\n\t\tbuilder: builder,\n\t\tattr: newAttr,\n\t\telementClose: newElementClose,\n\t\telementOpen: newElementOpen,\n\t\telementOpenEnd: newElementOpenEnd,\n\t\telementOpenStart: newElementOpenStart,\n\t\telementVoid: newElementVoid,\n\t\ttext: newText\n\t});\n\t\n\tfunction createSymbol(description) {\n\t  return typeof Symbol === 'function' ? Symbol(description) : description;\n\t}\n\t\n\tvar data = function (element) {\n\t  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t\n\t  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n\t};\n\t\n\tvar dashCase = function (str) {\n\t  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t    var dash = !one || idx % 2 === 0 ? '' : '-';\n\t    return '' + one + dash + two.toLowerCase();\n\t  });\n\t};\n\t\n\tvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n\t];\n\tvar native = (function (fn) {\n\t  return nativeHints.map(function (hint) {\n\t    return (fn || '').toString().indexOf([hint]) > -1;\n\t  }).reduce(function (a, b) {\n\t    return a || b;\n\t  });\n\t});\n\t\n\tvar MutationObserver = root.MutationObserver;\n\t\n\t\n\tfunction microtaskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var i = 0;\n\t  var cbArgs = [];\n\t  var elem = document.createElement('span');\n\t  var observer = new MutationObserver(function () {\n\t    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t    scheduled = false;\n\t    cbArgs = null;\n\t  });\n\t\n\t  observer.observe(elem, { childList: true });\n\t\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      elem.textContent = '' + i;\n\t      i += 1;\n\t    }\n\t  };\n\t}\n\t\n\t// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n\t// polyfill requires that the element be in the document to trigger Mutation\n\t// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n\t//\n\t// The soonest we can set the timeout for in IE is 1 as they have issues when\n\t// setting to 0.\n\tfunction taskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var cbArgs = [];\n\t  return function () {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      setTimeout(function () {\n\t        scheduled = false;\n\t        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t      }, 1);\n\t    }\n\t  };\n\t}\n\tvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\t\n\tvar getOwnPropertyDescriptors = function () {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  return keys(obj).reduce(function (prev, curr) {\n\t    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t    return prev;\n\t  }, {});\n\t};\n\t\n\t/**\n\t * This is needed to avoid IE11 \"stack size errors\" when creating\n\t * a new property on the constructor of an HTMLElement\n\t */\n\tfunction setCtorNativeProperty(Ctor, propName, value) {\n\t  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n\t}\n\t\n\t/**\n\t * Returns a cached map of property options for the given component class.\n\t * Keys in the map are the properties name which can a string or a symbol.\n\t *\n\t * The map is created by caching the result of: static get props\n\t */\n\tfunction getPropsMap(Ctor) {\n\t  // Must be defined on constructor and not from a superclass\n\t  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n\t    (function () {\n\t      var props$$1 = Ctor.props || {};\n\t\n\t      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n\t        result[propNameOrSymbol] = props$$1[propNameOrSymbol];\n\t        return result;\n\t      }, {});\n\t      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n\t    })();\n\t  }\n\t\n\t  return Ctor[ctorPropsMap];\n\t}\n\t\n\tfunction get$2(elem) {\n\t  var props$$1 = {};\n\t  keys(getPropsMap(elem.constructor)).forEach(function (key) {\n\t    props$$1[key] = elem[key];\n\t  });\n\t\n\t  return props$$1;\n\t}\n\t\n\tfunction set$2(elem, newProps) {\n\t  assign(elem, newProps);\n\t  if (elem[renderer$1]) {\n\t    elem[renderer$1]();\n\t  }\n\t}\n\t\n\tvar props$1 = function (elem, newProps) {\n\t  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n\t};\n\t\n\tfunction getDefaultValue(elem, name, opts) {\n\t  return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n\t}\n\t\n\tfunction getInitialValue(elem, name, opts) {\n\t  return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n\t}\n\t\n\tfunction getPropData(elem, name) {\n\t  var elemData = data(elem, 'props');\n\t  return elemData[name] || (elemData[name] = {});\n\t}\n\t\n\tfunction syncFirstTimeProp(elem, prop, propName, attributeName, propData) {\n\t  var syncAttrValue = propData.lastAssignedValue;\n\t  if (empty(syncAttrValue)) {\n\t    if ('initial' in prop) {\n\t      syncAttrValue = getInitialValue(elem, propName, prop);\n\t    } else if ('default' in prop) {\n\t      syncAttrValue = getDefaultValue(elem, propName, prop);\n\t    }\n\t  }\n\t  if (!empty(syncAttrValue) && prop.serialize) {\n\t    syncAttrValue = prop.serialize(syncAttrValue);\n\t  }\n\t  if (!empty(syncAttrValue)) {\n\t    propData.syncingAttribute = true;\n\t    elem.setAttribute(attributeName, syncAttrValue);\n\t  }\n\t}\n\t\n\tfunction syncExistingProp(elem, prop, propName, attributeName, propData) {\n\t  if (attributeName && !propData.settingAttribute) {\n\t    var internalValue = propData.internalValue;\n\t\n\t    var serializedValue = prop.serialize(internalValue);\n\t    var currentAttrValue = elem.getAttribute(attributeName);\n\t    var serializedIsEmpty = empty(serializedValue);\n\t    var attributeChanged = !(serializedIsEmpty && empty(currentAttrValue) || serializedValue === currentAttrValue);\n\t\n\t    propData.syncingAttribute = true;\n\t\n\t    var shouldRemoveAttribute = empty(propData.lastAssignedValue);\n\t    if (shouldRemoveAttribute || serializedIsEmpty) {\n\t      elem.removeAttribute(attributeName);\n\t    } else {\n\t      elem.setAttribute(attributeName, serializedValue);\n\t    }\n\t\n\t    if (!attributeChanged && propData.syncingAttribute) {\n\t      propData.syncingAttribute = false;\n\t    }\n\t  }\n\t\n\t  // Allow the attribute to be linked again.\n\t  propData.settingAttribute = false;\n\t}\n\t\n\tfunction syncPropToAttr(elem, prop, propName, isFirstSync) {\n\t  var attributeName = data(elem, 'propertyLinks')[propName];\n\t  var propData = getPropData(elem, propName);\n\t\n\t  if (attributeName) {\n\t    if (isFirstSync) {\n\t      syncFirstTimeProp(elem, prop, propName, attributeName, propData);\n\t    } else {\n\t      syncExistingProp(elem, prop, propName, attributeName, propData);\n\t    }\n\t  }\n\t}\n\t\n\tfunction createNativePropertyDefinition(name$$1, opts) {\n\t  var prop = {\n\t    configurable: true,\n\t    enumerable: true\n\t  };\n\t\n\t  prop.created = function created(elem) {\n\t    var propData = getPropData(elem, name$$1);\n\t    var attributeName = opts.attribute === true ? dashCase(name$$1) : opts.attribute;\n\t    var initialValue = elem[name$$1];\n\t\n\t    // Store property to attribute link information.\n\t    data(elem, 'attributeLinks')[attributeName] = name$$1;\n\t    data(elem, 'propertyLinks')[name$$1] = attributeName;\n\t\n\t    // Set up initial value if it wasn't specified.\n\t    if (empty(initialValue)) {\n\t      if (attributeName && elem.hasAttribute(attributeName)) {\n\t        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n\t      } else if ('initial' in opts) {\n\t        initialValue = getInitialValue(elem, name$$1, opts);\n\t      } else if ('default' in opts) {\n\t        initialValue = getDefaultValue(elem, name$$1, opts);\n\t      }\n\t    }\n\t\n\t    propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n\t  };\n\t\n\t  prop.get = function get() {\n\t    var propData = getPropData(this, name$$1);\n\t    var internalValue = propData.internalValue;\n\t\n\t    return typeof opts.get === 'function' ? opts.get(this, { name: name$$1, internalValue: internalValue }) : internalValue;\n\t  };\n\t\n\t  prop.set = function set(newValue) {\n\t    var propData = getPropData(this, name$$1);\n\t    propData.lastAssignedValue = newValue;\n\t    var oldValue = propData.oldValue;\n\t\n\t\n\t    if (empty(oldValue)) {\n\t      oldValue = null;\n\t    }\n\t\n\t    if (empty(newValue)) {\n\t      newValue = getDefaultValue(this, name$$1, opts);\n\t    }\n\t\n\t    if (typeof opts.coerce === 'function') {\n\t      newValue = opts.coerce(newValue);\n\t    }\n\t\n\t    var changeData = { name: name$$1, newValue: newValue, oldValue: oldValue };\n\t\n\t    if (typeof opts.set === 'function') {\n\t      opts.set(this, changeData);\n\t    }\n\t\n\t    // Queue a re-render.\n\t    this[rendererDebounced](this);\n\t\n\t    // Update prop data so we can use it next time.\n\t    propData.internalValue = propData.oldValue = newValue;\n\t\n\t    // Link up the attribute.\n\t    if (this[connected]) {\n\t      syncPropToAttr(this, opts, name$$1, false);\n\t    }\n\t  };\n\t\n\t  return prop;\n\t}\n\t\n\tvar initProps = function (opts) {\n\t  opts = opts || {};\n\t\n\t  if (typeof opts === 'function') {\n\t    opts = { coerce: opts };\n\t  }\n\t\n\t  return function (name$$1) {\n\t    return createNativePropertyDefinition(name$$1, assign({\n\t      default: null,\n\t      deserialize: function deserialize(value) {\n\t        return value;\n\t      },\n\t      serialize: function serialize(value) {\n\t        return value;\n\t      }\n\t    }, opts));\n\t  };\n\t};\n\t\n\tvar HTMLElement$1 = root.HTMLElement || function () {\n\t  function _class() {\n\t    classCallCheck(this, _class);\n\t  }\n\t\n\t  return _class;\n\t}();\n\tvar _prevName = createSymbol('prevName');\n\tvar _prevOldValue = createSymbol('prevOldValue');\n\tvar _prevNewValue = createSymbol('prevNewValue');\n\t\n\tfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n\t  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n\t}\n\t\n\tfunction syncPropsToAttrs(elem) {\n\t  var props$$1 = getPropsMap(elem.constructor);\n\t  Object.keys(props$$1).forEach(function (propName) {\n\t    var prop = props$$1[propName];\n\t    syncPropToAttr(elem, prop, propName, true);\n\t  });\n\t}\n\t\n\t// TODO remove when not catering to Safari < 10.\n\t//\n\t// Ensures that definitions passed as part of the constructor are functions\n\t// that return property definitions used on the element.\n\tfunction ensurePropertyFunctions(Ctor) {\n\t  var props$$1 = getPropsMap(Ctor);\n\t  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props$$1[descriptorName];\n\t    if (typeof descriptors[descriptorName] !== 'function') {\n\t      descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n\t    }\n\t    return descriptors;\n\t  }, {});\n\t}\n\t\n\t// TODO remove when not catering to Safari < 10.\n\t//\n\t// This can probably be simplified into createInitProps().\n\tfunction ensurePropertyDefinitions(Ctor) {\n\t  var props$$1 = ensurePropertyFunctions(Ctor);\n\t  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props$$1[descriptorName](descriptorName);\n\t    return descriptors;\n\t  }, {});\n\t}\n\t\n\t// TODO refactor when not catering to Safari < 10.\n\t//\n\t// We should be able to simplify this where all we do is Object.defineProperty().\n\tfunction createInitProps(Ctor) {\n\t  var props$$1 = ensurePropertyDefinitions(Ctor);\n\t\n\t  return function (elem) {\n\t    if (!props$$1) {\n\t      return;\n\t    }\n\t\n\t    keys(props$$1).forEach(function (name$$1) {\n\t      var prop = props$$1[name$$1];\n\t      prop.created(elem);\n\t\n\t      // We check here before defining to see if the prop was specified prior\n\t      // to upgrading.\n\t      var hasPropBeforeUpgrading = name$$1 in elem;\n\t\n\t      // This is saved prior to defining so that we can set it after it it was\n\t      // defined prior to upgrading. We don't want to invoke the getter if we\n\t      // don't need to, so we only get the value if we need to re-sync.\n\t      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\t\n\t      // https://bugs.webkit.org/show_bug.cgi?id=49739\n\t      //\n\t      // When Webkit fixes that bug so that native property accessors can be\n\t      // retrieved, we can move defining the property to the prototype and away\n\t      // from having to do if for every instance as all other browsers support\n\t      // this.\n\t      Object.defineProperty(elem, name$$1, prop);\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We'll be removing get / set callbacks on properties. Use the\n\t      // updatedCallback() instead.\n\t      //\n\t      // We re-set the prop if it was specified prior to upgrading because we\n\t      // need to ensure set() is triggered both in polyfilled environments and\n\t      // in native where the definition may be registerd after elements it\n\t      // represents have already been created.\n\t      if (hasPropBeforeUpgrading) {\n\t        elem[name$$1] = valueBeforeUpgrading;\n\t      }\n\t    });\n\t  };\n\t}\n\t\n\tvar _class2 = function (_HTMLElement) {\n\t  inherits(_class2, _HTMLElement);\n\t  createClass(_class2, null, [{\n\t    key: 'observedAttributes',\n\t\n\t\n\t    /**\n\t     * Returns unique attribute names configured with props and\n\t     * those set on the Component constructor if any\n\t     */\n\t    get: function get() {\n\t      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n\t\n\t      var props$$1 = getPropsMap(this);\n\t      var attrsFromLinkedProps = Object.keys(props$$1).map(function (key) {\n\t        var attribute = props$$1[key].attribute;\n\t\n\t        return attribute === true ? dashCase(key) : attribute;\n\t      }).filter(Boolean);\n\t\n\t      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n\t\n\t      return all.filter(function (item, index) {\n\t        return all.indexOf(item) === index;\n\t      });\n\t    },\n\t    set: function set(value) {\n\t      value = Array.isArray(value) ? value : [];\n\t      setCtorNativeProperty(this, 'observedAttributes', value);\n\t    }\n\t\n\t    // Returns superclass props overwritten with this Component props\n\t\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n\t    },\n\t    set: function set(value) {\n\t      setCtorNativeProperty(this, ctorProps, value);\n\t    }\n\t  }]);\n\t\n\t  function _class2() {\n\t    classCallCheck(this, _class2);\n\t\n\t    var _this = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this));\n\t\n\t    var constructor = _this.constructor;\n\t\n\t    // Used for the ready() function so it knows when it can call its callback.\n\t\n\t    _this[created$1] = true;\n\t\n\t    // TODO refactor to not cater to Safari < 10. This means we can depend on\n\t    // built-in property descriptors.\n\t    // Must be defined on constructor and not from a superclass\n\t    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n\t      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n\t    }\n\t\n\t    // Set up a renderer that is debounced for property sets to call directly.\n\t    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\t\n\t    // Set up property lifecycle.\n\t    var propConfigsCount = keys(getPropsMap(constructor)).length;\n\t    if (propConfigsCount && constructor[ctorCreateInitProps]) {\n\t      constructor[ctorCreateInitProps](_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static render()\n\t    if (!_this.renderCallback && constructor.render) {\n\t      _this.renderCallback = constructor.render.bind(constructor, _this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static created()\n\t    //\n\t    // Props should be set up before calling this.\n\t    if (typeof constructor.created === 'function') {\n\t      constructor.created(_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // Feature has rarely been used.\n\t    //\n\t    // Created should be set before invoking the ready listeners.\n\t    var elemData = data(_this);\n\t    var readyCallbacks = elemData.readyCallbacks;\n\t    if (readyCallbacks) {\n\t      readyCallbacks.forEach(function (cb) {\n\t        return cb(_this);\n\t      });\n\t      delete elemData.readyCallbacks;\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  // Custom Elements v1\n\t\n\t\n\t  createClass(_class2, [{\n\t    key: 'connectedCallback',\n\t    value: function connectedCallback() {\n\t      var constructor = this.constructor;\n\t\n\t      // DEPRECATED\n\t      //\n\t      // No more reflecting back to attributes in favour of one-way reflection.\n\t\n\t      syncPropsToAttrs(this);\n\t\n\t      // Used to check whether or not the component can render.\n\t      this[connected] = true;\n\t\n\t      // Render!\n\t      this[rendererDebounced]();\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static attached()\n\t      if (typeof constructor.attached === 'function') {\n\t        constructor.attached(this);\n\t      }\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We can remove this once all browsers support :defined.\n\t      this.setAttribute('defined', '');\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'disconnectedCallback',\n\t    value: function disconnectedCallback() {\n\t      var constructor = this.constructor;\n\t\n\t      // Ensures the component can't be rendered while disconnected.\n\t\n\t      this[connected] = false;\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static detached()\n\t      if (typeof constructor.detached === 'function') {\n\t        constructor.detached(this);\n\t      }\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n\t      // Polyfill calls this twice.\n\t      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n\t        return;\n\t      }\n\t\n\t      // Set data so we can prevent double calling if the polyfill.\n\t      this[_prevName] = name$$1;\n\t      this[_prevOldValue] = oldValue;\n\t      this[_prevNewValue] = newValue;\n\t\n\t      var attributeChanged = this.constructor.attributeChanged;\n\t\n\t      var propertyName = data(this, 'attributeLinks')[name$$1];\n\t\n\t      if (propertyName) {\n\t        var propData = data(this, 'props')[propertyName];\n\t\n\t        // This ensures a property set doesn't cause the attribute changed\n\t        // handler to run again once we set this flag. This only ever has a\n\t        // chance to run when you set an attribute, it then sets a property and\n\t        // then that causes the attribute to be set again.\n\t        if (propData.syncingAttribute) {\n\t          propData.syncingAttribute = false;\n\t        } else {\n\t          // Sync up the property.\n\t          var propOpts = getPropsMap(this.constructor)[propertyName];\n\t          propData.settingAttribute = true;\n\t          var newPropVal = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n\t          this[propertyName] = newPropVal;\n\t        }\n\t      }\n\t\n\t      if (attributeChanged) {\n\t        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n\t      }\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static updated() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t\n\t  }, {\n\t    key: 'updatedCallback',\n\t    value: function updatedCallback(prev) {\n\t      return this.constructor.updated(this, prev);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static rendered() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t\n\t  }, {\n\t    key: 'renderedCallback',\n\t    value: function renderedCallback() {\n\t      return this.constructor.rendered(this);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static renderer() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t\n\t  }, {\n\t    key: 'rendererCallback',\n\t    value: function rendererCallback() {\n\t      return this.constructor.renderer(this);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Invokes the complete render lifecycle.\n\t\n\t  }, {\n\t    key: renderer$1,\n\t    value: function value() {\n\t      if (this[rendering] || !this[connected]) {\n\t        return;\n\t      }\n\t\n\t      // Flag as rendering. This prevents anything from trying to render - or\n\t      // queueing a render - while there is a pending render.\n\t      this[rendering] = true;\n\t\n\t      if (this[updated$1]() && typeof this.renderCallback === 'function') {\n\t        this.rendererCallback();\n\t        this.renderedCallback();\n\t      }\n\t\n\t      this[rendering] = false;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Calls the user-defined updated() lifecycle callback.\n\t\n\t  }, {\n\t    key: updated$1,\n\t    value: function value() {\n\t      var prev = this[props];\n\t      this[props] = props$1(this);\n\t      return this.updatedCallback(prev);\n\t    }\n\t\n\t    // Skate\n\t\n\t  }], [{\n\t    key: 'extend',\n\t    value: function extend() {\n\t      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\t\n\t      // Create class for the user.\n\t      var Ctor = function (_Base) {\n\t        inherits(Ctor, _Base);\n\t\n\t        function Ctor() {\n\t          classCallCheck(this, Ctor);\n\t          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n\t        }\n\t\n\t        return Ctor;\n\t      }(Base);\n\t\n\t      // For inheriting from the object literal.\n\t\n\t\n\t      var opts = getOwnPropertyDescriptors(definition);\n\t      var prot = getOwnPropertyDescriptors(definition.prototype);\n\t\n\t      // Prototype is non configurable (but is writable).\n\t      delete opts.prototype;\n\t\n\t      // Pass on static and instance members from the definition.\n\t      Object.defineProperties(Ctor, opts);\n\t      Object.defineProperties(Ctor.prototype, prot);\n\t\n\t      return Ctor;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'updated',\n\t    value: function updated(elem, prev) {\n\t      if (!prev) {\n\t        return true;\n\t      }\n\t\n\t      // use get all keys so that we check Symbols as well as regular props\n\t      // using a for loop so we can break early\n\t      var allKeys = keys(prev);\n\t      for (var i = 0; i < allKeys.length; i += 1) {\n\t        if (prev[allKeys[i]] !== elem[allKeys[i]]) {\n\t          return true;\n\t        }\n\t      }\n\t\n\t      return false;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'rendered',\n\t    value: function rendered() {}\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'renderer',\n\t    value: function renderer(elem) {\n\t      if (!elem.shadowRoot) {\n\t        elem.attachShadow({ mode: 'open' });\n\t      }\n\t      incrementalDom.patchInner(elem.shadowRoot, function () {\n\t        var possibleFn = elem.renderCallback();\n\t        if (typeof possibleFn === 'function') {\n\t          possibleFn();\n\t        } else if (Array.isArray(possibleFn)) {\n\t          possibleFn.forEach(function (fn) {\n\t            if (typeof fn === 'function') {\n\t              fn();\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }\n\t  }]);\n\t  return _class2;\n\t}(HTMLElement$1);\n\t\n\tfunction uniqueId(prefix) {\n\t  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n\t  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0;\n\t    // eslint-disable-next-line no-mixed-operators\n\t    var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t  return (prefix || 'x') + '-' + rand;\n\t}\n\t\n\tvar define = function () {\n\t  var customElements = root.customElements;\n\t\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  var name$$1 = args[0];\n\t  var Ctor = args[1];\n\t\n\t\n\t  if (!customElements) {\n\t    throw new Error('Skate requires native custom element support or a polyfill.');\n\t  }\n\t\n\t  // Support passing an anonymous definition.\n\t  if (args.length === 1) {\n\t    // We are checking string for now, but once we remove the ability to pass\n\t    // an object literal, we can change this to check \"function\" and invert the\n\t    // blocks of logic.\n\t    if (typeof name$$1 === 'string') {\n\t      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n\t    } else {\n\t      Ctor = name$$1;\n\t      name$$1 = uniqueId();\n\t    }\n\t  }\n\t\n\t  // Ensure there's no conflicts.\n\t  if (customElements.get(name$$1)) {\n\t    name$$1 = uniqueId(name$$1);\n\t  }\n\t\n\t  // DEPRECATED\n\t  //\n\t  // Object literals.\n\t  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n\t    Ctor = _class2.extend(Ctor);\n\t  }\n\t\n\t  // This allows us to check this before instantiating the custom element to\n\t  // find its name from the constructor in the vdom module, thus improving\n\t  // performance but still falling back to a robust method.\n\t  Ctor[name] = name$$1;\n\t\n\t  // Sipmle define. Not supporting customised built-ins yet.\n\t  customElements.define(name$$1, Ctor);\n\t\n\t  // The spec doesn't return but this allows for a simpler, more concise API.\n\t  return Ctor;\n\t};\n\t\n\tvar Event = function (TheEvent) {\n\t  if (TheEvent) {\n\t    try {\n\t      new TheEvent('emit-init'); // eslint-disable-line no-new\n\t    } catch (e) {\n\t      return undefined;\n\t    }\n\t  }\n\t  return TheEvent;\n\t}(root.Event);\n\t\n\tfunction createCustomEvent(name) {\n\t  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var detail = opts.detail;\n\t\n\t  delete opts.detail;\n\t\n\t  var e = void 0;\n\t  if (Event) {\n\t    e = new Event(name, opts);\n\t    Object.defineProperty(e, 'detail', { value: detail });\n\t  } else {\n\t    e = document.createEvent('CustomEvent');\n\t    Object.defineProperty(e, 'composed', { value: opts.composed });\n\t    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n\t  }\n\t  return e;\n\t}\n\t\n\tvar emit = function (elem, name) {\n\t  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (opts.bubbles === undefined) {\n\t    opts.bubbles = true;\n\t  }\n\t  if (opts.cancelable === undefined) {\n\t    opts.cancelable = true;\n\t  }\n\t  if (opts.composed === undefined) {\n\t    opts.composed = true;\n\t  }\n\t  return elem.dispatchEvent(createCustomEvent(name, opts));\n\t};\n\t\n\tfunction getValue(elem) {\n\t  var type = elem.type;\n\t  if (type === 'checkbox' || type === 'radio') {\n\t    return elem.checked ? elem.value || true : false;\n\t  }\n\t  return elem.value;\n\t}\n\t\n\tvar link = function (elem, target) {\n\t  return function (e) {\n\t    var value = getValue(e.target);\n\t    var localTarget = target || e.target.name || 'value';\n\t\n\t    if (localTarget.indexOf('.') > -1) {\n\t      var parts = localTarget.split('.');\n\t      var firstPart = parts[0];\n\t      var propName = parts.pop();\n\t      var obj = parts.reduce(function (prev, curr) {\n\t        return prev && prev[curr];\n\t      }, elem);\n\t\n\t      obj[propName || e.target.name] = value;\n\t      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n\t    } else {\n\t      props$1(elem, defineProperty({}, localTarget, value));\n\t    }\n\t  };\n\t};\n\t\n\tvar ready = function (elem, done) {\n\t  var info = data(elem);\n\t  if (elem[created$1]) {\n\t    done(elem);\n\t  } else if (info.readyCallbacks) {\n\t    info.readyCallbacks.push(done);\n\t  } else {\n\t    info.readyCallbacks = [done];\n\t  }\n\t};\n\t\n\tvar h = builder();\n\t\n\texports.Component = _class2;\n\texports.define = define;\n\texports.emit = emit;\n\texports.h = h;\n\texports.link = link;\n\texports.prop = prop;\n\texports.props = props$1;\n\texports.ready = ready;\n\texports.symbols = symbols$1;\n\texports.vdom = vdom;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t//# sourceMappingURL=index.js.map\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function (name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\t\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\t\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = attributes[name] || attributes[symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes[symbols.default] = applyAttributeTyped;\n\t\n\tattributes[symbols.placeholder] = function () {};\n\t\n\tattributes['style'] = applyStyle;\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\t\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\t\n\t  return parent.namespaceURI;\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = undefined;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function (doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\t\n\t  while (child) {\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t\n\t    child = child.nextElementSibling;\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function (nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\t\n\t/** @type {?Context} */\n\tvar context = null;\n\t\n\t/** @type {?Node} */\n\tvar currentNode = null;\n\t\n\t/** @type {?Node} */\n\tvar currentParent = null;\n\t\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = null;\n\t\n\t/** @type {?Document} */\n\tvar doc = null;\n\t\n\t/**\n\t * Returns a patcher function that sets up and restores a patch context,\n\t * running the run function with the provided data.\n\t * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n\t * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n\t * @template T\n\t */\n\tvar patchFactory = function (run) {\n\t  /**\n\t   * TODO(moz): These annotations won't be necessary once we switch to Closure\n\t   * Compiler's new type inference. Remove these once the switch is done.\n\t   *\n\t   * @param {(!Element|!DocumentFragment)} node\n\t   * @param {!function(T)} fn\n\t   * @param {T=} data\n\t   * @template T\n\t   */\n\t  var f = function (node, fn, data) {\n\t    var prevContext = context;\n\t    var prevRoot = root;\n\t    var prevDoc = doc;\n\t    var prevCurrentNode = currentNode;\n\t    var prevCurrentParent = currentParent;\n\t    var previousInAttributes = false;\n\t    var previousInSkip = false;\n\t\n\t    context = new Context();\n\t    root = node;\n\t    doc = node.ownerDocument;\n\t    currentParent = node.parentNode;\n\t\n\t    if (false) {}\n\t\n\t    run(node, fn, data);\n\t\n\t    if (false) {}\n\t\n\t    context.notifyChanges();\n\t\n\t    context = prevContext;\n\t    root = prevRoot;\n\t    doc = prevDoc;\n\t    currentNode = prevCurrentNode;\n\t    currentParent = prevCurrentParent;\n\t  };\n\t  return f;\n\t};\n\t\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchInner = patchFactory(function (node, fn, data) {\n\t  currentNode = node;\n\t\n\t  enterNode();\n\t  fn(data);\n\t  exitNode();\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = patchFactory(function (node, fn, data) {\n\t  currentNode = /** @type {!Element} */{ nextSibling: node };\n\t\n\t  fn(data);\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (nodeName, key) {\n\t  var data = getData(currentNode);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\t\n\t  var node = undefined;\n\t\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && 'production' !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\t\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\t\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\t\n\t    context.markCreated(node);\n\t  }\n\t\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\t\n\t  currentNode = node;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function () {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = undefined;\n\t\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[symbols.placeholder] && node !== root) {\n\t    if (false) {}\n\t    return;\n\t  }\n\t\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\t\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function () {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function () {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function () {\n\t  clearUnvisitedDOM();\n\t\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\t\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function (tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function () {\n\t  if (false) {}\n\t\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function () {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function () {\n\t  if (false) {}\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip = function () {\n\t  if (false) {}\n\t  currentNode = currentParent.lastChild;\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function (tag, key, statics) {\n\t  if (false) {}\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function (name, value) {\n\t  if (false) {}\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd = function () {\n\t  if (false) {}\n\t\n\t  var node = elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose = function (tag) {\n\t  if (false) {}\n\t\n\t  var node = coreElementClose();\n\t\n\t  if (false) {}\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function (tag, key, statics, const_args) {\n\t  elementOpen.apply(null, arguments);\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  elementOpen.apply(null, arguments);\n\t  skip();\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text = function (value, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreText();\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\texports.patch = patchInner;\n\texports.patchInner = patchInner;\n\texports.patchOuter = patchOuter;\n\texports.currentElement = currentElement;\n\texports.skip = skip;\n\texports.elementVoid = elementVoid;\n\texports.elementOpenStart = elementOpenStart;\n\texports.elementOpenEnd = elementOpenEnd;\n\texports.elementOpen = elementOpen;\n\texports.elementClose = elementClose;\n\texports.elementPlaceholder = elementPlaceholder;\n\texports.text = text;\n\texports.attr = attr;\n\texports.symbols = symbols;\n\texports.attributes = attributes;\n\texports.applyAttr = applyAttr;\n\texports.applyProp = applyProp;\n\texports.notifications = notifications;\n\t\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict'\n\tmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n\t  (typeof global === 'object' && global.global === global && global) ||\n\t  this\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// dist/index-with-deps.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 80837e48f239fb4802dc","import 'skatejs-web-components';\n\nimport {Component, prop, h} from 'skatejs';\nconst React = { createElement: h };\n\n\n\ncustomElements.define('svg-import', class extends Component {\n\tstatic get props () {\n\t\treturn {\n\t\t\t// By declaring the property an attribute, we can now pass an initial value\n\t\t\t// for the count as part of the HTML.\n\t\t\tsrc: prop.string({ attribute: true }),\n\t\t\t'inner-style': prop.string({ attribute: true }),\n\t\t};\n\t}\n\tupdateXml(){\n\t\tif(!jQuery){\n\t\t\tthrow new TypeError('svg-import require jQuery to work!');\n\t\t}\n\t\tlet comp = this;\n\n\n\t\tconst $ = jQuery;\n\n\n\t\t$.get({url:this.src,cache:true,async:true})\n\t\t\t.then(function (xml) {\n\n\t\t\t\tvar $svg = $(xml).find('svg');\n\t\t\t\tvar svg = $svg.get(0);\n\t\t\t\tsvg.removeAttribute('xmlns:a');\n\t\t\t\tif(comp.width && comp.height){\n\t\t\t\t\t// svg.hasAttribute('viewBox') ? svg.setAttribute('viewBox', '0 0 ' + comp.height + ' ' + comp.width) : '';\n\t\t\t\t\tsvg.setAttribute('width','100%');\n\t\t\t\t\tsvg.setAttribute('height','100%');\n\t\t\t\t}\n\n\t\t\t\t// comp.xmlData = $svg.clone().wrap('<div/>').parent().html();\n\t\t\t\tvar wraper = $(comp.shadowRoot).find('.svg-import-wrap').get(0);\n\n\t\t\t\twraper.innerHTML = '';\n\t\t\t\twraper.appendChild(svg);\n\n\t\t\t})\n\t}\n\tconnectedCallback () {\n\t\t// Ensure we call the parent.\n\t\tsuper.connectedCallback();\n\t\t//this.updateXml();\n\n\t}\n\tattributeChangedCallback (name, oldValue, newValue) {\n\t\tsuper.attributeChangedCallback(name, oldValue, newValue);\n\t\tif(name == 'src'){\n\t\t\tthis.updateXml();\n\t\t}\n\n\t}\n\tdisconnectedCallback () {\n\t\t// Ensure we callback the parent.\n\t\tsuper.disconnectedCallback();\n\n\t\t// If we didn't clean up after ourselves, we'd continue to render\n\t}\n\trenderCallback () {\n\t\t// By separating the strings (and not using template literals or string\n\t\t// concatenation) it ensures the strings are diffed indepenedently. If\n\t\t// you select \"Count\" with your mouse, it will not deselect whenr endered.\n\t\tvar comp = this;\n\n\t\tconst defBoxStyle = `\n\t\t\t:host{display:inline-block;}\n\t\t\t.svg-import-wrap{\n\t\t\t\toverflow:hidden;\n\t\t\t\tmargin:0;\n\t\t\t\tpadding:0;\n\t\t\t\twidth:100%;\n\t\t\t\theight:100%;\n\t\t\t\tmin-width:5px;\n\t\t\t\tmin-height:5px;\n\t\t\t\tdisplay:block;\n\t\t\t}\n\t\t\tsvg{\n\t\t\t\twidth:100%;\n\t\t\t\theight:100%;\n\t\t\t}\n\t\t`;\n\n\t\treturn ([\n\t\t\th('style', defBoxStyle + comp['inner-style']),\n\t\t\t<figure role=\"image\" className=\"svg-import-wrap\"></figure>\n\t\t])\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsWebComponents\"] = factory();\n\telse\n\t\troot[\"skatejsWebComponents\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// We load the Safari fix first because the custom element polyfill overrides\n\t// attachShadow() to observe the shadow root.\n\t__webpack_require__(1);\n\t\n\t// We have to include this first so that it can patch native.\n\t__webpack_require__(2);\n\t\n\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t// ShadyDOM polyfill be loaded first.\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _window = window,\n\t    HTMLElement = _window.HTMLElement,\n\t    MutationObserver = _window.MutationObserver,\n\t    navigator = _window.navigator;\n\tvar userAgent = navigator.userAgent;\n\t\n\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\tvar safariVersions = [0, 1].map(function (v) {\n\t  return '10.0.' + v;\n\t}).concat(['10.0']);\n\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\n\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\tfunction fixSafari() {\n\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\n\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t  // element as this is the only scenario where styles aren't recalculated.\n\t  var moOpts = { childList: true, subtree: true };\n\t  var mo = new MutationObserver(function (muts) {\n\t    muts.forEach(function (mut) {\n\t      var target = mut.target;\n\t\n\t      if (target.tagName === 'STYLE') {\n\t        var nextSibling = target.nextSibling,\n\t            parentNode = target.parentNode;\n\t\n\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t        // as it seems that doesn't trigger a recalc.\n\t\n\t        parentNode.removeChild(target);\n\t        parentNode.insertBefore(target, nextSibling);\n\t      }\n\t    });\n\t  });\n\t\n\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t  function newAttachShadow(opts) {\n\t    var sr = oldAttachShadow.call(this, opts);\n\t    mo.observe(sr, moOpts);\n\t    return sr;\n\t  }\n\t\n\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t    // Ensure polyfills can override it (hoping they call it back).\n\t    configurable: true,\n\t    enumerable: true,\n\t    value: newAttachShadow,\n\t    writable: true\n\t  });\n\t}\n\t\n\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t// fixes the bug.\n\tif (patch) {\n\t  fixSafari();\n\t}\n\t\n\texports.default = patch;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t Code distributed by Google as part of the polymer project is also\n\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\n\t//# sourceMappingURL=custom-elements.min.js.map\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar settings = window.ShadyDOM || {};\n\t\n\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\n\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\n\tfunction isShadyRoot(obj) {\n\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t}\n\t\n\tvar p = Element.prototype;\n\tvar matches = p.matches || p.matchesSelector ||\n\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tfunction matchesSelector(element, selector) {\n\t  return matches.call(element, selector);\n\t}\n\t\n\tfunction copyOwnProperty(name, source, target) {\n\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t  if (pd) {\n\t    Object.defineProperty(target, name, pd);\n\t  }\n\t}\n\t\n\tfunction extend(target, source) {\n\t  if (target && source) {\n\t    var n$ = Object.getOwnPropertyNames(source);\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t      copyOwnProperty(n, source, target);\n\t    }\n\t  }\n\t  return target || source;\n\t}\n\t\n\tfunction extendAll(target) {\n\t  var sources = [], len = arguments.length - 1;\n\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t  for (var i=0; i < sources.length; i++) {\n\t    extend(target, sources[i]);\n\t  }\n\t  return target;\n\t}\n\t\n\tfunction mixin(target, source) {\n\t  for (var i in source) {\n\t    target[i] = source[i];\n\t  }\n\t  return target;\n\t}\n\t\n\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t  obj.__proto__ = proto;\n\t  return obj;\n\t}\n\t\n\tfunction patchPrototype(obj, mixin) {\n\t  var proto = Object.getPrototypeOf(obj);\n\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t    var patchProto = Object.create(proto);\n\t    patchProto.__sourceProto = proto;\n\t    extend(patchProto, mixin);\n\t    proto.__patchProto = patchProto;\n\t  }\n\t  setPrototypeOf(obj, proto.__patchProto);\n\t}\n\t\n\t\n\t\n\tvar common = {};\n\t\n\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\tvar promish;\n\tif (window.Promise) {\n\t  promish = Promise.resolve();\n\t} else {\n\t  promish = {\n\t    then: function(cb) {\n\t      var twiddle = document.createTextNode('');\n\t      var observer = new MutationObserver(function() {\n\t        observer.disconnect();\n\t        cb();\n\t      });\n\t      observer.observe(twiddle, {characterData: true});\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction newSplice(index, removed, addedCount) {\n\t  return {\n\t    index: index,\n\t    removed: removed,\n\t    addedCount: addedCount\n\t  };\n\t}\n\t\n\tvar EDIT_LEAVE = 0;\n\tvar EDIT_UPDATE = 1;\n\tvar EDIT_ADD = 2;\n\tvar EDIT_DELETE = 3;\n\t\n\tvar ArraySplice = {\n\t\n\t  // Note: This function is *based* on the computation of the Levenshtein\n\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t  // edits - not one. With Array splices, an update is really a delete\n\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t  // maximum array items in the original array. For example:\n\t  //\n\t  //   'xxxx123' -> '123yyyy'\n\t  //\n\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t  // leaves the substring '123' intact.\n\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t                              old, oldStart, oldEnd) {\n\t    var this$1 = this;\n\t\n\t    // \"Deletion\" columns\n\t    var rowCount = oldEnd - oldStart + 1;\n\t    var columnCount = currentEnd - currentStart + 1;\n\t    var distances = new Array(rowCount);\n\t\n\t    // \"Addition\" rows. Initialize null column.\n\t    for (var i = 0; i < rowCount; i++) {\n\t      distances[i] = new Array(columnCount);\n\t      distances[i][0] = i;\n\t    }\n\t\n\t    // Initialize null row\n\t    for (var j = 0; j < columnCount; j++)\n\t      distances[0][j] = j;\n\t\n\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t        else {\n\t          var north = distances[i$1 - 1][j$1] + 1;\n\t          var west = distances[i$1][j$1 - 1] + 1;\n\t          distances[i$1][j$1] = north < west ? north : west;\n\t        }\n\t      }\n\t    }\n\t\n\t    return distances;\n\t  },\n\t\n\t  // This starts at the final weight, and walks \"backward\" by finding\n\t  // the minimum previous weight recursively until the origin of the weight\n\t  // matrix.\n\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t    var i = distances.length - 1;\n\t    var j = distances[0].length - 1;\n\t    var current = distances[i][j];\n\t    var edits = [];\n\t    while (i > 0 || j > 0) {\n\t      if (i == 0) {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        continue;\n\t      }\n\t      if (j == 0) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        continue;\n\t      }\n\t      var northWest = distances[i - 1][j - 1];\n\t      var west = distances[i - 1][j];\n\t      var north = distances[i][j - 1];\n\t\n\t      var min;\n\t      if (west < north)\n\t        min = west < northWest ? west : northWest;\n\t      else\n\t        min = north < northWest ? north : northWest;\n\t\n\t      if (min == northWest) {\n\t        if (northWest == current) {\n\t          edits.push(EDIT_LEAVE);\n\t        } else {\n\t          edits.push(EDIT_UPDATE);\n\t          current = northWest;\n\t        }\n\t        i--;\n\t        j--;\n\t      } else if (min == west) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        current = west;\n\t      } else {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        current = north;\n\t      }\n\t    }\n\t\n\t    edits.reverse();\n\t    return edits;\n\t  },\n\t\n\t  /**\n\t   * Splice Projection functions:\n\t   *\n\t   * A splice map is a representation of how a previous array of items\n\t   * was transformed into a new array of items. Conceptually it is a list of\n\t   * tuples of\n\t   *\n\t   *   <index, removed, addedCount>\n\t   *\n\t   * which are kept in ascending index order of. The tuple represents that at\n\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t   * from |index|, |addedCount| items were added.\n\t   */\n\t\n\t  /**\n\t   * Lacking individual splice mutation information, the minimal set of\n\t   * splices can be synthesized given the previous state and final state of an\n\t   * array. The basic approach is to calculate the edit distance matrix and\n\t   * choose the shortest path through it.\n\t   *\n\t   * Complexity: O(l * p)\n\t   *   l: The length of the current array\n\t   *   p: The length of the old array\n\t   */\n\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t                        old, oldStart, oldEnd) {\n\t    var prefixCount = 0;\n\t    var suffixCount = 0;\n\t    var splice;\n\t\n\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t    if (currentStart == 0 && oldStart == 0)\n\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\n\t    if (currentEnd == current.length && oldEnd == old.length)\n\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\n\t    currentStart += prefixCount;\n\t    oldStart += prefixCount;\n\t    currentEnd -= suffixCount;\n\t    oldEnd -= suffixCount;\n\t\n\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t      return [];\n\t\n\t    if (currentStart == currentEnd) {\n\t      splice = newSplice(currentStart, [], 0);\n\t      while (oldStart < oldEnd)\n\t        splice.removed.push(old[oldStart++]);\n\t\n\t      return [ splice ];\n\t    } else if (oldStart == oldEnd)\n\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\n\t    var ops = this.spliceOperationsFromEditDistances(\n\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t                               old, oldStart, oldEnd));\n\t\n\t    splice = undefined;\n\t    var splices = [];\n\t    var index = currentStart;\n\t    var oldIndex = oldStart;\n\t    for (var i = 0; i < ops.length; i++) {\n\t      switch(ops[i]) {\n\t        case EDIT_LEAVE:\n\t          if (splice) {\n\t            splices.push(splice);\n\t            splice = undefined;\n\t          }\n\t\n\t          index++;\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_UPDATE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_ADD:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t          break;\n\t        case EDIT_DELETE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (splice) {\n\t      splices.push(splice);\n\t    }\n\t    return splices;\n\t  },\n\t\n\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t    var this$1 = this;\n\t\n\t    for (var i = 0; i < searchLength; i++)\n\t      if (!this$1.equals(current[i], old[i]))\n\t        return i;\n\t    return searchLength;\n\t  },\n\t\n\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t    var index1 = current.length;\n\t    var index2 = old.length;\n\t    var count = 0;\n\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t      count++;\n\t\n\t    return count;\n\t  },\n\t\n\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t                            previous.length);\n\t  },\n\t\n\t  equals: function equals(currentValue, previousValue) {\n\t    return currentValue === previousValue;\n\t  }\n\t\n\t};\n\t\n\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t// for now this is stuck on `utils`\n\t//import {patchNode} from './patch'\n\t// native add/remove\n\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\tvar nativeAppendChild = Element.prototype.appendChild;\n\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\n\t/**\n\t * `tree` is a dom manipulation library used by ShadyDom to\n\t * manipulate composed and logical trees.\n\t */\n\tvar tree = {\n\t\n\t  // sad but faster than slice...\n\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopy: function arrayCopy(a$) {\n\t    var l = a$.length;\n\t    var copy = new Array(l);\n\t    for (var i=0; i < l; i++) {\n\t      copy[i] = a$[i];\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes(node) {\n\t    tree.Logical.saveChildNodes(node);\n\t    if (!tree.Composed.hasParentNode(node)) {\n\t      tree.Composed.saveComposedData(node);\n\t      //tree.Composed.saveParentNode(node);\n\t    }\n\t    tree.Composed.saveChildNodes(node);\n\t  }\n\t\n\t};\n\t\n\ttree.Logical = {\n\t\n\t  hasParentNode: function hasParentNode(node) {\n\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes(node) {\n\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes(node) {\n\t    // note: we're distinguishing here between undefined and false-y:\n\t    // hasChildNodes uses undefined check to see if this element has logical\n\t    // children; the false-y check indicates whether or not we should rebuild\n\t    // the cached childNodes array.\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      tree.Composed.getChildNodes(node);\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes(node) {\n\t    if (!node.__dom.childNodes) {\n\t      node.__dom.childNodes = [];\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        node.__dom.childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.childNodes;\n\t  },\n\t\n\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t  // element will store firstChild/lastChild, and in case (2), the element\n\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t  // the mere existence of __dom is not enough to know if the requested\n\t  // logical data is available and instead we do an explicit undefined check.\n\t  getParentNode: function getParentNode(node) {\n\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t  },\n\t\n\t  getLastChild: function getLastChild(node) {\n\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t  },\n\t\n\t  getNextSibling: function getNextSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      this._getFirstElementChild(node) :\n\t      tree.Composed.getFirstElementChild(node);\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t    var n = node.__dom.firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild(node) {\n\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t      this._getLastElementChild(node) :\n\t      tree.Composed.getLastElementChild(node);\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild(node) {\n\t    var n = node.__dom.lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t      this._getNextElementSibling(node) :\n\t      tree.Composed.getNextElementSibling(node);\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t      this._getPreviousElementSibling(node) :\n\t      tree.Composed.getPreviousElementSibling(node);\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  // Capture the list of light children. It's important to do this before we\n\t  // start transforming the DOM into \"rendered\" state.\n\t  // Children may be added to this list dynamically. It will be treated as the\n\t  // source of truth for the light children of the element. This element's\n\t  // actual children will be treated as the rendered state once this function\n\t  // has been called.\n\t  saveChildNodes: function saveChildNodes$1(node) {\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.firstChild;\n\t      node.__dom.lastChild = node.lastChild;\n\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        n.__dom = n.__dom || {};\n\t        n.__dom.parentNode = node;\n\t        n.__dom.nextSibling = c$[i+1] || null;\n\t        n.__dom.previousSibling = c$[i-1] || null;\n\t        common.patchNode(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t  // already been distributed.\n\t  // NOTE: ensure `node` is patched...\n\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var c$ = tree.arrayCopyChildNodes(node);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1._linkNode(c$[i], container, ref_node);\n\t      }\n\t      // cleanup logical dom in doc fragment.\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t      node.__dom.childNodes = null;\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t    common.patchNode(node);\n\t    ref_node = ref_node || null;\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t      container.__dom.lastChild;\n\t    if (node.__dom.previousSibling) {\n\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.nextSibling = ref_node;\n\t    if (node.__dom.nextSibling) {\n\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.lastChild = node;\n\t      if (!container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.firstChild) {\n\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t    }\n\t    if (node === container.__dom.lastChild) {\n\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t    }\n\t    var p = node.__dom.previousSibling;\n\t    var n = node.__dom.nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.previousSibling = p;\n\t    }\n\t    // When an element is removed, logical data is no longer tracked.\n\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t    // from `null` which is set if info is null.\n\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t      node.__dom.nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  }\n\t\n\t}\n\t\n\t\n\t// TODO(sorvell): composed tree manipulation is made available\n\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t// to the tree for optional patching pluggability.\n\ttree.Composed = {\n\t\n\t  hasParentNode: function hasParentNode$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes$1(node) {\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes$1(node) {\n\t    if (!node.__dom.$childNodes) {\n\t      node.__dom.$childNodes = [];\n\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t        node.__dom.$childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getParentNode: function getParentNode$1(node) {\n\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t      (!node.__patched && node.parentNode);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild$1(node) {\n\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t  },\n\t\n\t  getLastChild: function getLastChild$1(node) {\n\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t  },\n\t\n\t  getNextSibling: function getNextSibling$1(node) {\n\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t    return node.__patched ? this._getFirstElementChild(node) :\n\t      node.firstElementChild;\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t    var n = node.__dom.$firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild$1(node) {\n\t    return node.__patched ? this._getLastElementChild(node) :\n\t      node.lastElementChild;\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t    var n = node.__dom.$lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t    return node.__patched ? this._getNextElementSibling(node) :\n\t      node.nextElementSibling;\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t      node.previousElementSibling;\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes$2(node) {\n\t    var this$1 = this;\n\t\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.$firstChild = node.firstChild;\n\t      node.__dom.$lastChild = node.lastChild;\n\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        this$1.saveComposedData(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  saveComposedData: function saveComposedData(node) {\n\t    node.__dom = node.__dom || {};\n\t    if (node.__dom.$parentNode === undefined) {\n\t      node.__dom.$parentNode = node.parentNode;\n\t    }\n\t    if (node.__dom.$nextSibling === undefined) {\n\t      node.__dom.$nextSibling = node.nextSibling;\n\t    }\n\t    if (node.__dom.$previousSibling === undefined) {\n\t      node.__dom.$previousSibling = node.previousSibling;\n\t    }\n\t  },\n\t\n\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.$childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      // TODO(sorvell): remember this for patching:\n\t      // the act of setting this info can affect patched nodes\n\t      // getters; therefore capture childNodes before patching.\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        this$1._linkNode(n, container, ref_node);\n\t      }\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t      container.__dom.$lastChild;\n\t    if (node.__dom.$previousSibling) {\n\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.$nextSibling = ref_node;\n\t    if (node.__dom.$nextSibling) {\n\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.$parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.$lastChild = node;\n\t      if (!container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.$firstChild) {\n\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t    }\n\t    if (node === container.__dom.$lastChild) {\n\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t    }\n\t    var p = node.__dom.$previousSibling;\n\t    var n = node.__dom.$nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.$nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.$previousSibling = p;\n\t    }\n\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t      node.__dom.$nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  clearChildNodes: function clearChildNodes(node) {\n\t    var this$1 = this;\n\t\n\t    var c$ = this.getChildNodes(node);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      this$1.recordRemoveChild(c, node);\n\t      nativeRemoveChild.call(node, c)\n\t    }\n\t  },\n\t\n\t  saveParentNode: function saveParentNode(node) {\n\t    node.__dom = node.__dom || {};\n\t    node.__dom.$parentNode = node.parentNode;\n\t  },\n\t\n\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t    this.saveChildNodes(parentNode);\n\t    // remove from current location.\n\t    this._addChild(parentNode, newChild, refChild);\n\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t  },\n\t\n\t  appendChild: function appendChild(parentNode, newChild) {\n\t    this.saveChildNodes(parentNode);\n\t    this._addChild(parentNode, newChild);\n\t    return nativeAppendChild.call(parentNode, newChild);\n\t  },\n\t\n\t  removeChild: function removeChild(parentNode, node) {\n\t    var currentParent = this.getParentNode(node);\n\t    this.saveChildNodes(parentNode);\n\t    this._removeChild(parentNode, node);\n\t    if (currentParent === parentNode) {\n\t      return nativeRemoveChild.call(parentNode, node);\n\t    }\n\t  },\n\t\n\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t    var this$1 = this;\n\t\n\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t    var oldParent = this.getParentNode(newChild);\n\t    if (oldParent) {\n\t      this._removeChild(oldParent, newChild);\n\t    }\n\t    if (isFrag) {\n\t      var c$ = this.getChildNodes(newChild);\n\t      for (var i=0; i < c$.length; i++) {\n\t        var c = c$[i];\n\t        // unlink document fragment children\n\t        this$1._removeChild(newChild, c);\n\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t      }\n\t    } else {\n\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t    }\n\t  },\n\t\n\t  _removeChild: function _removeChild(parentNode, node) {\n\t    this.recordRemoveChild(node, parentNode);\n\t  }\n\t\n\t};\n\t\n\t// for testing...\n\tvar descriptors = {};\n\tfunction getNativeProperty(element, property) {\n\t  if (!descriptors[property]) {\n\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t      HTMLElement.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Element.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Node.prototype, property);\n\t  }\n\t  return descriptors[property].get.call(element);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// NOTE: normalize event contruction where necessary (IE11)\n\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t  function(inType, params) {\n\t    params = params || {};\n\t    var e = document.createEvent('Event');\n\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t    return e;\n\t  };\n\t\n\tvar Distributor = (function () {\n\t  function anonymous(root) {\n\t    this.root = root;\n\t    this.insertionPointTag = 'slot';\n\t  }\n\t\n\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t  };\n\t\n\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t    return Boolean(this.root._insertionPoints &&\n\t      this.root._insertionPoints.length);\n\t  };\n\t\n\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t    return node.localName && node.localName == this.insertionPointTag;\n\t  };\n\t\n\t  anonymous.prototype.distribute = function distribute () {\n\t    if (this.hasInsertionPoint()) {\n\t      return this.distributePool(this.root, this.collectPool());\n\t    }\n\t    return [];\n\t  };\n\t\n\t  // Gather the pool of nodes that should be distributed. We will combine\n\t  // these with the \"content root\" to arrive at the composed tree.\n\t  anonymous.prototype.collectPool = function collectPool () {\n\t    return tree.arrayCopy(\n\t      tree.Logical.getChildNodes(this.root.host));\n\t  };\n\t\n\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t  // instead elements are distributed into storage\n\t  // array where applicable.\n\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t    var this$1 = this;\n\t\n\t    var dirtyRoots = [];\n\t    var p$ = this.root._insertionPoints;\n\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t      this$1.distributeInsertionPoint(p, pool);\n\t      // provoke redistribution on insertion point parents\n\t      // must do this on all candidate hosts since distribution in this\n\t      // scope invalidates their distribution.\n\t      // only get logical parent.\n\t      var parent = tree.Logical.getParentNode(p);\n\t      if (parent && parent.shadyRoot &&\n\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t        dirtyRoots.push(parent.shadyRoot);\n\t      }\n\t    }\n\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t      var p$1 = pool[i$1];\n\t      if (p$1) {\n\t        p$1._assignedSlot = undefined;\n\t        // remove undistributed elements from physical dom.\n\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t        if (parent$1) {\n\t          tree.Composed.removeChild(parent$1, p$1);\n\t        }\n\t      }\n\t    }\n\t    return dirtyRoots;\n\t  };\n\t\n\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t    var this$1 = this;\n\t\n\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t    if (prevAssignedNodes) {\n\t      this.clearAssignedSlots(insertionPoint, true);\n\t    }\n\t    insertionPoint._assignedNodes = [];\n\t    var needsSlotChange = false;\n\t    // distribute nodes from the pool that this selector matches\n\t    var anyDistributed = false;\n\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t      node=pool[i];\n\t      // skip nodes that were already used\n\t      if (!node) {\n\t        continue;\n\t      }\n\t      // distribute this node if it matches\n\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node, insertionPoint)\n\t        // remove this node from the pool\n\t        pool[i] = undefined;\n\t        // since at least one node matched, we won't need fallback content\n\t        anyDistributed = true;\n\t      }\n\t    }\n\t    // Fallback content if nothing was distributed here\n\t    if (!anyDistributed) {\n\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t      for (var j = 0, node$1; j < children.length; j++) {\n\t        node$1 = children[j];\n\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t      }\n\t    }\n\t    // we're already dirty if a node was newly added to the slot\n\t    // and we're also dirty if the assigned count decreased.\n\t    if (prevAssignedNodes) {\n\t      // TODO(sorvell): the tracking of previously assigned slots\n\t      // could instead by done with a Set and then we could\n\t      // avoid needing to iterate here to clear the info.\n\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t      }\n\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t        needsSlotChange = true;\n\t      }\n\t    }\n\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t    if (needsSlotChange) {\n\t      this._fireSlotChange(insertionPoint);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t    var n$ = slot._assignedNodes;\n\t    if (n$) {\n\t      for (var i=0; i < n$.length; i++) {\n\t        var n = n$[i];\n\t        if (savePrevious) {\n\t          n.__prevAssignedSlot = n._assignedSlot;\n\t        }\n\t        // only clear if it was previously set to this slot;\n\t        // this helps ensure that if the node has otherwise been distributed\n\t        // ignore it.\n\t        if (n._assignedSlot === slot) {\n\t          n._assignedSlot = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t    var slotName = insertionPoint.getAttribute('name');\n\t    slotName = slotName ? slotName.trim() : '';\n\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t    slot = slot ? slot.trim() : '';\n\t    return (slot == slotName);\n\t  };\n\t\n\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t    insertionPoint._assignedNodes.push(child);\n\t    child._assignedSlot = insertionPoint;\n\t  };\n\t\n\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t    var this$1 = this;\n\t\n\t    var n$ = insertionPoint._assignedNodes;\n\t    insertionPoint._distributedNodes = [];\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t      if (this$1.isInsertionPoint(n)) {\n\t        var d$ = n._distributedNodes;\n\t        if (d$) {\n\t          for (var j=0; j < d$.length; j++) {\n\t            insertionPoint._distributedNodes.push(d$[j]);\n\t          }\n\t        }\n\t      } else {\n\t        insertionPoint._distributedNodes.push(n$[i]);\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t    // Safari tech preview does not bubble but chrome does\n\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t    if (insertionPoint._assignedSlot) {\n\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t    return !(insertionPoint._assignedSlot);\n\t  };\n\t\n\t  return anonymous;\n\t}())\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t  polyfill across browsers.\n\t*/\n\tvar ShadyRoot = function ShadyRoot(host) {\n\t  if (!host) {\n\t    throw 'Must provide a host';\n\t  }\n\t  // NOTE: this strange construction is necessary because\n\t  // DocumentFragment cannot be subclassed on older browsers.\n\t  var frag = document.createDocumentFragment();\n\t  frag.__proto__ = ShadyFragmentMixin;\n\t  frag._init(host);\n\t  return frag;\n\t};\n\t\n\tvar ShadyMixin = {\n\t\n\t  _init: function _init(host) {\n\t    // NOTE: set a fake local name so this element can be\n\t    // distinguished from a DocumentFragment when patching.\n\t    // FF doesn't allow this to be `localName`\n\t    this.__localName = 'ShadyRoot';\n\t    // root <=> host\n\t    host.shadyRoot = this;\n\t    this.host = host;\n\t    // logical dom setup\n\t    tree.Logical.saveChildNodes(host);\n\t    tree.Logical.saveChildNodes(this);\n\t    // state flags\n\t    this._clean = true;\n\t    this._hasRendered = false;\n\t    this._distributor = new Distributor(this);\n\t    this.update();\n\t  },\n\t\n\t  // async render the \"top\" distributor (this is all that is needed to\n\t  // distribute this host).\n\t  update: function update() {\n\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t    if (distributionRoot._clean) {\n\t      distributionRoot._clean = false;\n\t      enqueue(function() {\n\t        distributionRoot.render();\n\t      });\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t  // this should only return a shadowRoot.\n\t  // returns the host that's the top of this host's distribution tree\n\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t    var root = element.shadyRoot;\n\t    while (element && this._elementNeedsDistribution(element)) {\n\t      root = element.getRootNode();\n\t      element = root && root.host;\n\t    }\n\t    return root;\n\t  },\n\t\n\t  // Return true if a host's children includes\n\t  // an insertion point that selects selectively\n\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t    var this$1 = this;\n\t\n\t    var c$ = tree.Logical.getChildNodes(element);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t        return element.getRootNode();\n\t      }\n\t    }\n\t  },\n\t\n\t  render: function render() {\n\t    if (!this._clean) {\n\t      this._clean = true;\n\t      if (!this._skipUpdateInsertionPoints) {\n\t        this.updateInsertionPoints();\n\t      } else if (!this._hasRendered) {\n\t        this._insertionPoints = [];\n\t      }\n\t      this._skipUpdateInsertionPoints = false;\n\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t      // that would avoid distribution for initial render if\n\t      // no insertion points exist. We cannot currently do this because\n\t      // it relies on elements being in the physical shadowRoot element\n\t      // so that native methods will be used. The current append code\n\t      // simply provokes distribution in this case and does not put the\n\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t      // consider if the special processing is worth the perf gain.\n\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t      //   tree.Composed.clearChildNodes(this.host);\n\t      //   tree.Composed.appendChild(this.host, this);\n\t      // } else {\n\t      // logical\n\t      this.distribute();\n\t      // physical\n\t      this.compose();\n\t      this._hasRendered = true;\n\t    }\n\t  },\n\t\n\t  forceRender: function forceRender() {\n\t    this._clean = false;\n\t    this.render();\n\t  },\n\t\n\t  distribute: function distribute() {\n\t    var dirtyRoots = this._distributor.distribute();\n\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t      dirtyRoots[i].forceRender();\n\t    }\n\t  },\n\t\n\t  updateInsertionPoints: function updateInsertionPoints() {\n\t    var this$1 = this;\n\t\n\t    var i$ = this.__insertionPoints;\n\t    // if any insertion points have been removed, clear their distribution info\n\t    if (i$) {\n\t      for (var i=0, c; i < i$.length; i++) {\n\t        c = i$[i];\n\t        if (c.getRootNode() !== this$1) {\n\t          this$1._distributor.clearAssignedSlots(c);\n\t        }\n\t      }\n\t    }\n\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t    // ensure insertionPoints's and their parents have logical dom info.\n\t    // save logical tree info\n\t    // a. for shadyRoot\n\t    // b. for insertion points (fallback)\n\t    // c. for parents of insertion points\n\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t      c$1 = i$[i$1];\n\t      tree.Logical.saveChildNodes(c$1);\n\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t    }\n\t  },\n\t\n\t  get _insertionPoints() {\n\t    if (!this.__insertionPoints) {\n\t      this.updateInsertionPoints();\n\t    }\n\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t  },\n\t\n\t  set _insertionPoints(insertionPoints) {\n\t    this.__insertionPoints = insertionPoints;\n\t  },\n\t\n\t  hasInsertionPoint: function hasInsertionPoint() {\n\t    return this._distributor.hasInsertionPoint();\n\t  },\n\t\n\t  compose: function compose() {\n\t    // compose self\n\t    // note: it's important to mark this clean before distribution\n\t    // so that attachment that provokes additional distribution (e.g.\n\t    // adding something to your parentNode) works\n\t    this._composeTree();\n\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t    // (these seem unnecessary)\n\t  },\n\t\n\t  // Reify dom such that it is at its correct rendering position\n\t  // based on logical distribution.\n\t  _composeTree: function _composeTree() {\n\t    var this$1 = this;\n\t\n\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t    var p$ = this._insertionPoints || [];\n\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t      parent = tree.Logical.getParentNode(p);\n\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t      }\n\t    }\n\t  },\n\t\n\t  // Returns the list of nodes which should be rendered inside `node`.\n\t  _composeNode: function _composeNode(node) {\n\t    var this$1 = this;\n\t\n\t    var children = [];\n\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t    for (var i = 0; i < c$.length; i++) {\n\t      var child = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t        var distributedNodes = child._distributedNodes ||\n\t          (child._distributedNodes = []);\n\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t          var distributedNode = distributedNodes[j];\n\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t            children.push(distributedNode);\n\t          }\n\t        }\n\t      } else {\n\t        children.push(child);\n\t      }\n\t    }\n\t    return children;\n\t  },\n\t\n\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t    return this._distributor.isFinalDestination(\n\t      insertionPoint, node);\n\t  },\n\t\n\t  // Ensures that the rendered node list inside `container` is `children`.\n\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t    var composed = tree.Composed.getChildNodes(container);\n\t    var splices = calculateSplices(children, composed);\n\t    // process removals\n\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t        // check if the node is still where we expect it is before trying\n\t        // to remove it; this can happen if we move a node and\n\t        // then schedule its previous host for distribution resulting in\n\t        // the node being removed here.\n\t        if (tree.Composed.getParentNode(n) === container) {\n\t          tree.Composed.removeChild(container, n);\n\t        }\n\t        composed.splice(s.index + d, 1);\n\t      }\n\t      d -= s.addedCount;\n\t    }\n\t    // process adds\n\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t      next = composed[s$1.index];\n\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t        n$1 = children[j$1];\n\t        tree.Composed.insertBefore(container, n$1, next);\n\t        // TODO(sorvell): is this splice strictly needed?\n\t        composed.splice(j$1, 0, n$1);\n\t      }\n\t    }\n\t  },\n\t\n\t  getInsertionPointTag: function getInsertionPointTag() {\n\t    return this._distributor.insertionPointTag;\n\t  }\n\t\n\t}\n\t\n\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\textend(ShadyFragmentMixin, ShadyMixin);\n\t\n\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\n\t// function upgradeLogicalChildren(children) {\n\t//   if (needsUpgrade && children) {\n\t//     for (let i=0; i < children.length; i++) {\n\t//       CustomElements.upgrade(children[i]);\n\t//     }\n\t//   }\n\t// }\n\t\n\t// render enqueuer/flusher\n\tvar customElements = window.customElements;\n\tvar flushList = [];\n\tvar scheduled;\n\tvar flushCount = 0;\n\tvar flushMax = 100;\n\tfunction enqueue(callback) {\n\t  if (!scheduled) {\n\t    scheduled = true;\n\t    promish.then(flush$1);\n\t  }\n\t  flushList.push(callback);\n\t}\n\t\n\tfunction flush$1() {\n\t  scheduled = false;\n\t  flushCount++;\n\t  while (flushList.length) {\n\t    flushList.shift()();\n\t  }\n\t  if (customElements && customElements.flush) {\n\t    customElements.flush();\n\t  }\n\t  // continue flushing after elements are upgraded...\n\t  var isFlushedMaxed = (flushCount > flushMax);\n\t  if (flushList.length && !isFlushedMaxed) {\n\t      flush$1();\n\t  }\n\t  flushCount = 0;\n\t  if (isFlushedMaxed) {\n\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t  }\n\t}\n\t\n\tflush$1.list = flushList;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// Cribbed from ShadowDOM polyfill\n\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t/////////////////////////////////////////////////////////////////////////////\n\t// innerHTML and outerHTML\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\n\tfunction escapeReplace(c) {\n\t  switch (c) {\n\t    case '&':\n\t      return '&amp;';\n\t    case '<':\n\t      return '&lt;';\n\t    case '>':\n\t      return '&gt;';\n\t    case '\"':\n\t      return '&quot;';\n\t    case '\\u00A0':\n\t      return '&nbsp;';\n\t  }\n\t}\n\t\n\tfunction escapeAttr(s) {\n\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t}\n\t\n\tfunction escapeData(s) {\n\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t}\n\t\n\tfunction makeSet(arr) {\n\t  var set = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    set[arr[i]] = true;\n\t  }\n\t  return set;\n\t}\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\tvar voidElements = makeSet([\n\t  'area',\n\t  'base',\n\t  'br',\n\t  'col',\n\t  'command',\n\t  'embed',\n\t  'hr',\n\t  'img',\n\t  'input',\n\t  'keygen',\n\t  'link',\n\t  'meta',\n\t  'param',\n\t  'source',\n\t  'track',\n\t  'wbr'\n\t]);\n\t\n\tvar plaintextParents = makeSet([\n\t  'style',\n\t  'script',\n\t  'xmp',\n\t  'iframe',\n\t  'noembed',\n\t  'noframes',\n\t  'plaintext',\n\t  'noscript'\n\t]);\n\t\n\tfunction getOuterHTML(node, parentNode, composed) {\n\t  switch (node.nodeType) {\n\t    case Node.ELEMENT_NODE: {\n\t      var tagName = node.localName;\n\t      var s = '<' + tagName;\n\t      var attrs = node.attributes;\n\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t      }\n\t      s += '>';\n\t      if (voidElements[tagName]) {\n\t        return s;\n\t      }\n\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t    }\n\t    case Node.TEXT_NODE: {\n\t      var data = node.data;\n\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t        return data;\n\t      }\n\t      return escapeData(data);\n\t    }\n\t    case Node.COMMENT_NODE: {\n\t      return '<!--' + node.data + '-->';\n\t    }\n\t    default: {\n\t      window.console.error(node);\n\t      throw new Error('not implemented');\n\t    }\n\t  }\n\t}\n\t\n\tfunction getInnerHTML(node, composed) {\n\t  if (node.localName === 'template') {\n\t    node = node.content;\n\t  }\n\t  var s = '';\n\t  var c$ = composed ? composed(node) : node.childNodes;\n\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t    s += getOuterHTML(child, node, composed);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar mixinImpl = {\n\t\n\t  // Try to add node. Record logical info, track insertion points, perform\n\t  // distribution iff needed. Return true if the add is handled.\n\t  addNode: function addNode(container, node, ref_node) {\n\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t    if (ownerRoot) {\n\t      // optimization: special insertion point tracking\n\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t      }\n\t      // note: we always need to see if an insertion point is added\n\t      // since this saves logical tree info; however, invalidation state\n\t      // needs\n\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t      // invalidate insertion points IFF not already invalid!\n\t      if (ipAdded) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t      }\n\t    }\n\t    if (tree.Logical.hasChildNodes(container)) {\n\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t    }\n\t    // if not distributing and not adding to host, do a fast path addition\n\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t      container.shadyRoot;\n\t    return handled;\n\t  },\n\t\n\t  // Try to remove node: update logical info and perform distribution iff\n\t  // needed. Return true if the removal has been handled.\n\t  // note that it's possible for both the node's host and its parent\n\t  // to require distribution... both cases are handled here.\n\t  removeNode: function removeNode(node) {\n\t    // important that we want to do this only if the node has a logical parent\n\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t      tree.Logical.getParentNode(node);\n\t    var distributed;\n\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t    if (logicalParent) {\n\t      // distribute node's parent iff needed\n\t      distributed = this.maybeDistributeParent(node);\n\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t      // remove node from root and distribute it iff needed\n\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    this._removeOwnerShadyRoot(node);\n\t    return distributed;\n\t  },\n\t\n\t\n\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t    var observer = node.__dom && node.__dom.observer;\n\t    if (observer) {\n\t      if (addedNode) {\n\t        observer.addedNodes.push(addedNode);\n\t      }\n\t      if (removedNode) {\n\t        observer.removedNodes.push(removedNode);\n\t      }\n\t      observer.schedule();\n\t    }\n\t  },\n\t\n\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t    if (parent) {\n\t      this._scheduleObserver(parent, null, node);\n\t      this.removeNode(node);\n\t    } else {\n\t      this._removeOwnerShadyRoot(node);\n\t    }\n\t  },\n\t\n\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t  },\n\t\n\t  getRootNode: function getRootNode$1(node) {\n\t    if (!node || !node.nodeType) {\n\t      return;\n\t    }\n\t    var root = node.__ownerShadyRoot;\n\t    if (root === undefined) {\n\t      if (isShadyRoot(node)) {\n\t        root = node;\n\t      } else {\n\t        var parent = tree.Logical.getParentNode(node);\n\t        root = parent ? this.getRootNode(parent) : node;\n\t      }\n\t      // memo-ize result for performance but only memo-ize\n\t      // result if node is in the document. This avoids a problem where a root\n\t      // can be cached while an element is inside a fragment.\n\t      // If this happens and we cache the result, the value can become stale\n\t      // because for perf we avoid processing the subtree of added fragments.\n\t      if (document.documentElement.contains(node)) {\n\t        node.__ownerShadyRoot = root;\n\t      }\n\t    }\n\t    return root;\n\t  },\n\t\n\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t    var root = this.getRootNode(node);\n\t    if (isShadyRoot(root)) {\n\t      return root;\n\t    }\n\t  },\n\t\n\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t    // <content> children but since this case is assumed to be exceedingly\n\t    // rare, we avoid the cost and will address with some specific api\n\t    // when the need arises.  For now, the user must call\n\t    // distributeContent(true), which updates insertion points manually\n\t    // and forces distribution.\n\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t      !node.__noInsertionPoint &&\n\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t    var wrappedContent = fragContent &&\n\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t    // There are 3 possible cases where a distribution may need to occur:\n\t    // 1. <content> being inserted (the host of the shady root where\n\t    //    content is inserted needs distribution)\n\t    // 2. children being inserted into parent with a shady root (parent\n\t    //    needs distribution)\n\t    // 3. container is an insertionPoint\n\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t      if (ownerRoot) {\n\t        // note, insertion point list update is handled after node\n\t        // mutations are complete\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    var needsDist = this._nodeNeedsDistribution(container);\n\t    if (needsDist) {\n\t      container.shadyRoot.update();\n\t    }\n\t    // Return true when distribution will fully handle the composition\n\t    // Note that if a content was being inserted that was wrapped by a node,\n\t    // and the parent does not need distribution, return false to allow\n\t    // the nodes to be added directly, after which children may be\n\t    // distributed and composed into the wrapping node(s)\n\t    return needsDist || (hasContent && !wrappedContent);\n\t  },\n\t\n\t  /* note: parent argument is required since node may have an out\n\t  of date parent at this point; returns true if a <content> is being added */\n\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t    var this$1 = this;\n\t\n\t    var added;\n\t    var insertionPointTag = root.getInsertionPointTag();\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t      !node.__noInsertionPoint) {\n\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t        np = tree.Logical.getParentNode(n);\n\t        // don't allow node's parent to be fragment itself\n\t        if (np === node) {\n\t          np = parent;\n\t        }\n\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t        added = added || na;\n\t      }\n\t    } else if (node.localName === insertionPointTag) {\n\t      tree.Logical.saveChildNodes(parent);\n\t      tree.Logical.saveChildNodes(node);\n\t      added = true;\n\t    }\n\t    return added;\n\t  },\n\t\n\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t    return node && node.shadyRoot &&\n\t      node.shadyRoot.hasInsertionPoint();\n\t  },\n\t\n\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t    var this$1 = this;\n\t\n\t    var hostNeedsDist;\n\t    var ip$ = root._insertionPoints;\n\t    for (var i=0; i<ip$.length; i++) {\n\t      var insertionPoint = ip$[i];\n\t      if (this$1._contains(container, insertionPoint)) {\n\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t        for (var j=0; j<dc$.length; j++) {\n\t          hostNeedsDist = true;\n\t          var node = dc$[j];\n\t          var parent = tree.Composed.getParentNode(node);\n\t          if (parent) {\n\t            tree.Composed.removeChild(parent, node);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return hostNeedsDist;\n\t  },\n\t\n\t  _contains: function _contains(container, node) {\n\t    while (node) {\n\t      if (node == container) {\n\t        return true;\n\t      }\n\t      node = tree.Logical.getParentNode(node);\n\t    }\n\t  },\n\t\n\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t    var this$1 = this;\n\t\n\t    // optimization: only reset the tree if node is actually in a root\n\t    if (this._hasCachedOwnerRoot(node)) {\n\t      var c$ = tree.Logical.getChildNodes(node);\n\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t        this$1._removeOwnerShadyRoot(n);\n\t      }\n\t    }\n\t    node.__ownerShadyRoot = undefined;\n\t  },\n\t\n\t  // TODO(sorvell): This will fail if distribution that affects this\n\t  // question is pending; this is expected to be exceedingly rare, but if\n\t  // the issue comes up, we can force a flush in this case.\n\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t    var root = this.getRootNode(insertionPoint);\n\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t      // means that we're composed to this spot.\n\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t        return n;\n\t      }\n\t    }\n\t  },\n\t\n\t  clearNode: function clearNode(node) {\n\t    while (node.firstChild) {\n\t      node.removeChild(node.firstChild);\n\t    }\n\t  },\n\t\n\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t    var parent = tree.Logical.getParentNode(node);\n\t    if (this._nodeNeedsDistribution(parent)) {\n\t      parent.shadyRoot.update();\n\t      return true;\n\t    }\n\t  },\n\t\n\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t    if (name === 'slot') {\n\t      this.maybeDistributeParent(node);\n\t    } else if (node.localName === 'slot' && name === 'name') {\n\t      var root = this.ownerShadyRootForNode(node);\n\t      if (root) {\n\t        root.update();\n\t      }\n\t    }\n\t  },\n\t\n\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t  // but it's also generally useful to recurse through the element tree\n\t  // and is used by Polymer's styling system.\n\t  query: function query(node, matcher, halter) {\n\t    var list = [];\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t    return list;\n\t  },\n\t\n\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t    var this$1 = this;\n\t\n\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t          this$1._queryElement(c, matcher, halter, list)) {\n\t        return true;\n\t      }\n\t    }\n\t  },\n\t\n\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t    var result = matcher(node);\n\t    if (result) {\n\t      list.push(node);\n\t    }\n\t    if (halter && halter(result)) {\n\t      return result;\n\t    }\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t  },\n\t\n\t  activeElementForNode: function activeElementForNode(node) {\n\t    var this$1 = this;\n\t\n\t    var active = document.activeElement;\n\t    if (!active) {\n\t      return null;\n\t    }\n\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t    if (node !== document) {\n\t      // If this node isn't a document or shady root, then it doesn't have\n\t      // an active element.\n\t      if (!isShadyRoot$$1) {\n\t        return null;\n\t      }\n\t      // If this shady root's host is the active element or the active\n\t      // element is not a descendant of the host (in the composed tree),\n\t      // then it doesn't have an active element.\n\t      if (node.host === active ||\n\t          !node.host.contains(active)) {\n\t        return null;\n\t      }\n\t    }\n\t    // This node is either the document or a shady root of which the active\n\t    // element is a (composed) descendant of its host; iterate upwards to\n\t    // find the active element's most shallow host within it.\n\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t    while (activeRoot && activeRoot !== node) {\n\t      active = activeRoot.host;\n\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t    }\n\t    if (node === document) {\n\t      // This node is the document, so activeRoot should be null.\n\t      return activeRoot ? null : active;\n\t    } else {\n\t      // This node is a non-document shady root, and it should be\n\t      // activeRoot.\n\t      return activeRoot === node ? active : null;\n\t    }\n\t  }\n\t\n\t};\n\t\n\tvar nativeCloneNode = Element.prototype.cloneNode;\n\tvar nativeImportNode = Document.prototype.importNode;\n\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\n\tvar setAttribute = function(attr, value) {\n\t  if (window.ShadyCSS && attr === 'class') {\n\t    window.ShadyCSS.setElementClass(this, value);\n\t  } else {\n\t    nativeSetAttribute.call(this, attr, value);\n\t  }\n\t}\n\t\n\tvar NodeMixin = {};\n\t\n\tObject.defineProperties(NodeMixin, {\n\t\n\t  parentElement: {\n\t    get: function get() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  parentNode: {\n\t    get: function get$1() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextSibling: {\n\t    get: function get$2() {\n\t      return tree.Logical.getNextSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousSibling: {\n\t    get: function get$3() {\n\t      return tree.Logical.getPreviousSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextElementSibling: {\n\t    get: function get$4() {\n\t      return tree.Logical.getNextElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousElementSibling: {\n\t    get: function get$5() {\n\t      return tree.Logical.getPreviousElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  assignedSlot: {\n\t    get: function get$6() {\n\t      return this._assignedSlot;\n\t    },\n\t    configurable: true\n\t  }\n\t});\n\t\n\tvar FragmentMixin = {\n\t\n\t  appendChild: function appendChild(node) {\n\t    return this.insertBefore(node);\n\t  },\n\t\n\t  // cases in which we may not be able to just do standard native call\n\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t  // has an insertion point)\n\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t  // container to container.host.\n\t  // 3. node is <content> (host of container needs distribution)\n\t  insertBefore: function insertBefore(node, ref_node) {\n\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t        'of this node');\n\t    }\n\t    // remove node from its current position iff it's in a tree.\n\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var parent = tree.Logical.getParentNode(node);\n\t      mixinImpl.removeNodeFromParent(node, parent);\n\t    }\n\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t      if (ref_node) {\n\t        // if ref_node is an insertion point replace with first distributed node\n\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t        if (root) {\n\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t        }\n\t      }\n\t      // if adding to a shadyRoot, add to host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host : this;\n\t      if (ref_node) {\n\t        tree.Composed.insertBefore(container, node, ref_node);\n\t      } else {\n\t        tree.Composed.appendChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, node);\n\t    return node;\n\t  },\n\t\n\t  /**\n\t    Removes the given `node` from the element's `lightChildren`.\n\t    This method also performs dom composition.\n\t  */\n\t  removeChild: function removeChild(node) {\n\t    if (tree.Logical.getParentNode(node) !== this) {\n\t      throw Error('The node to be removed is not a child of this node: ' +\n\t        node);\n\t    }\n\t    if (!mixinImpl.removeNode(node)) {\n\t      // if removing from a shadyRoot, remove form host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host :\n\t        this;\n\t      // not guaranteed to physically be in container; e.g.\n\t      // undistributed nodes.\n\t      var parent = tree.Composed.getParentNode(node);\n\t      if (container === parent) {\n\t        tree.Composed.removeChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, null, node);\n\t    return node;\n\t  },\n\t\n\t  replaceChild: function replaceChild(node, ref_node) {\n\t    this.insertBefore(node, ref_node);\n\t    this.removeChild(ref_node);\n\t    return node;\n\t  },\n\t\n\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t  querySelector: function querySelector(selector) {\n\t    // match selector and halt on first result.\n\t    var result = mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    }, function(n) {\n\t      return Boolean(n);\n\t    })[0];\n\t    return result || null;\n\t  },\n\t\n\t  querySelectorAll: function querySelectorAll(selector) {\n\t    return mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    });\n\t  },\n\t\n\t  cloneNode: function cloneNode(deep) {\n\t    if (this.localName == 'template') {\n\t      return nativeCloneNode.call(this, deep);\n\t    } else {\n\t      var n = nativeCloneNode.call(this, false);\n\t      if (deep) {\n\t        var c$ = this.childNodes;\n\t        for (var i=0, nc; i < c$.length; i++) {\n\t          nc = c$[i].cloneNode(true);\n\t          n.appendChild(nc);\n\t        }\n\t      }\n\t      return n;\n\t    }\n\t  },\n\t\n\t  importNode: function importNode(externalNode, deep) {\n\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t    var doc = this instanceof Document ? this :\n\t      this.ownerDocument;\n\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t    if (deep) {\n\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t      common.patchNode(n);\n\t      for (var i=0, nc; i < c$.length; i++) {\n\t        nc = doc.importNode(c$[i], true);\n\t        n.appendChild(nc);\n\t      }\n\t    }\n\t    return n;\n\t  }\n\t};\n\t\n\tObject.defineProperties(FragmentMixin, {\n\t\n\t  childNodes: {\n\t    get: function get$7() {\n\t      var c$ = tree.Logical.getChildNodes(this);\n\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  children: {\n\t    get: function get$8() {\n\t      if (tree.Logical.hasChildNodes(this)) {\n\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t        });\n\t      } else {\n\t        return tree.arrayCopyChildren(this);\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstChild: {\n\t    get: function get$9() {\n\t      return tree.Logical.getFirstChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastChild: {\n\t    get: function get$10() {\n\t      return tree.Logical.getLastChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstElementChild: {\n\t    get: function get$11() {\n\t      return tree.Logical.getFirstElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastElementChild: {\n\t    get: function get$12() {\n\t      return tree.Logical.getLastElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t  // textContent / innerHTML\n\t  textContent: {\n\t    get: function get$13() {\n\t      if (this.childNodes) {\n\t        var tc = [];\n\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t            tc.push(c.textContent);\n\t          }\n\t        }\n\t        return tc.join('');\n\t      }\n\t      return '';\n\t    },\n\t    set: function set(text) {\n\t      mixinImpl.clearNode(this);\n\t      if (text) {\n\t        this.appendChild(document.createTextNode(text));\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  innerHTML: {\n\t    get: function get$14() {\n\t      return getInnerHTML(this);\n\t    },\n\t    set: function set$1(text) {\n\t      var this$1 = this;\n\t\n\t      mixinImpl.clearNode(this);\n\t      var d = document.createElement('div');\n\t      d.innerHTML = text;\n\t      // here, appendChild may move nodes async so we cannot rely\n\t      // on node position when copying\n\t      var c$ = tree.arrayCopyChildNodes(d);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1.appendChild(c$[i]);\n\t      }\n\t    },\n\t    configurable: true\n\t  }\n\t\n\t});\n\t\n\tvar ElementMixin = {\n\t\n\t  // TODO(sorvell): should only exist on <slot>\n\t  assignedNodes: function assignedNodes(options) {\n\t    return (options && options.flatten ? this._distributedNodes :\n\t      this._assignedNodes) || [];\n\t  },\n\t\n\t\n\t  setAttribute: function setAttribute$1(name, value) {\n\t    setAttribute.call(this, name, value);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  },\n\t\n\t  removeAttribute: function removeAttribute(name) {\n\t    nativeRemoveAttribute.call(this, name);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  }\n\t\n\t};\n\t\n\tObject.defineProperties(ElementMixin, {\n\t\n\t  shadowRoot: {\n\t    get: function get$15() {\n\t      return this.shadyRoot;\n\t    }\n\t  },\n\t\n\t  slot: {\n\t    get: function get$16() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set$2(value) {\n\t      this.setAttribute('slot', value);\n\t    }\n\t  }\n\t\n\t});\n\t\n\tvar activeElementDescriptor = {\n\t  get: function get$17() {\n\t    return mixinImpl.activeElementForNode(this);\n\t  }\n\t}\n\t\n\tvar ActiveElementMixin = {};\n\tObject.defineProperties(ActiveElementMixin, {\n\t  activeElement: activeElementDescriptor\n\t});\n\t\n\tvar UnderActiveElementMixin = {};\n\tObject.defineProperties(UnderActiveElementMixin, {\n\t  _activeElement: activeElementDescriptor\n\t});\n\t\n\tvar Mixins = {\n\t\n\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\n\t  Fragment: extendAll({__patched: 'Fragment'},\n\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\n\t  Element: extendAll({__patched: 'Element'},\n\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\n\t  // Note: activeElement cannot be patched on document!\n\t  Document: extendAll({__patched: 'Document'},\n\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\n\t};\n\t\n\tvar getRootNode = function(node) {\n\t  return mixinImpl.getRootNode(node);\n\t}\n\t\n\tfunction filterMutations(mutations, target) {\n\t  var targetRootNode = getRootNode(target);\n\t  return mutations.filter(function(mutation) {\n\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t    if (mutationInScope && mutation.addedNodes) {\n\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t        return (targetRootNode === getRootNode(n));\n\t      });\n\t      Object.defineProperty(mutation, 'addedNodes', {\n\t        value: nodes,\n\t        configurable: true\n\t      });\n\t    }\n\t    return mutationInScope &&\n\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t  });\n\t}\n\t\n\t// const promise = Promise.resolve();\n\t\n\tvar AsyncObserver = function AsyncObserver() {\n\t  this._scheduled = false;\n\t  this.addedNodes = [];\n\t  this.removedNodes = [];\n\t  this.callbacks = new Set();\n\t};\n\t\n\tAsyncObserver.prototype.schedule = function schedule () {\n\t    var this$1 = this;\n\t\n\t  if (!this._scheduled) {\n\t    this._scheduled = true;\n\t    promish.then(function () {\n\t      this$1.flush();\n\t    });\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.flush = function flush () {\n\t  if (this._scheduled) {\n\t    this._scheduled = false;\n\t    var mutations = this.takeRecords();\n\t    if (mutations.length) {\n\t      this.callbacks.forEach(function(cb) {\n\t        cb(mutations);\n\t      });\n\t    }\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t    var mutations = [{\n\t      addedNodes: this.addedNodes,\n\t      removedNodes: this.removedNodes\n\t    }];\n\t    this.addedNodes = [];\n\t    this.removedNodes = [];\n\t    return mutations;\n\t  }\n\t  return [];\n\t};\n\t\n\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t// directly so that users do not have to fork their code.\n\t// Supporting the entire api may be challenging: e.g. filtering out\n\t// removed nodes in the wrong scope and seeing non-distributing\n\t// subtree child mutations.\n\tvar observeChildren = function(node, callback) {\n\t  common.patchNode(node);\n\t  if (!node.__dom.observer) {\n\t    node.__dom.observer = new AsyncObserver();\n\t  }\n\t  node.__dom.observer.callbacks.add(callback);\n\t  var observer = node.__dom.observer;\n\t  return {\n\t    _callback: callback,\n\t    _observer: observer,\n\t    _node: node,\n\t    takeRecords: function takeRecords() {\n\t      return observer.takeRecords()\n\t    }\n\t  };\n\t}\n\t\n\tvar unobserveChildren = function(handle) {\n\t  var observer = handle && handle._observer;\n\t  if (observer) {\n\t    observer.callbacks.delete(handle._callback);\n\t    if (!observer.callbacks.size) {\n\t      handle._node.__dom.observer = null;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tvar patchedCount = 0;\n\t\n\tvar log = false;\n\t\n\tvar patchImpl = {\n\t\n\t  canPatchNode: function(node) {\n\t    switch (node) {\n\t      case document.head:\n\t      case document.documentElement:\n\t        return false;\n\t      default:\n\t        return true;\n\t    }\n\t  },\n\t\n\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t    window.Node.prototype, 'textContent')),\n\t\n\t  patch: function(node) {\n\t    patchedCount++;\n\t    log && window.console.warn('patch node', node);\n\t    if (this.hasPrototypeDescriptors) {\n\t      patchPrototype(node, this.mixinForObject(node));\n\t    } else {\n\t      window.console.warn('Patching instance rather than prototype', node);\n\t      extend(node, this.mixinForNode(node));\n\t    }\n\t  },\n\t\n\t  mixinForObject: function(obj) {\n\t    switch (obj.nodeType) {\n\t      case Node.ELEMENT_NODE:\n\t        return Mixins.Element;\n\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t        return Mixins.Fragment;\n\t      case Node.DOCUMENT_NODE:\n\t        return Mixins.Document;\n\t      case Node.TEXT_NODE:\n\t      case Node.COMMENT_NODE:\n\t        return Mixins.Node;\n\t    }\n\t  },\n\t\n\t  unpatch: function(obj) {\n\t    if (obj.__sourceProto) {\n\t      obj.__proto__ = obj.__sourceProto;\n\t\n\t    }\n\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t  }\n\t\n\t};\n\t\n\tfunction patchNode(node) {\n\t  if (!settings.inUse) {\n\t    return;\n\t  }\n\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t    tree.saveChildNodes(node);\n\t    patchImpl.patch(node);\n\t  }\n\t}\n\t\n\tfunction unpatchNode(node) {\n\t  patchImpl.unpatch(node);\n\t}\n\t\n\tfunction isNodePatched(node) {\n\t  return Boolean(node.__patched);\n\t}\n\t\n\t// TODO(sorvell): fake export\n\tcommon.patchNode = patchNode;\n\tcommon.isNodePatched = isNodePatched;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar origAddEventListener = Element.prototype.addEventListener;\n\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\n\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\tvar alwaysComposed = {\n\t  blur: true,\n\t  focus: true,\n\t  focusin: true,\n\t  focusout: true,\n\t  click: true,\n\t  dblclick: true,\n\t  mousedown: true,\n\t  mouseenter: true,\n\t  mouseleave: true,\n\t  mousemove: true,\n\t  mouseout: true,\n\t  mouseover: true,\n\t  mouseup: true,\n\t  wheel: true,\n\t  beforeinput: true,\n\t  input: true,\n\t  keydown: true,\n\t  keyup: true,\n\t  compositionstart: true,\n\t  compositionupdate: true,\n\t  compositionend: true,\n\t  touchstart: true,\n\t  touchend: true,\n\t  touchmove: true,\n\t  touchcancel: true,\n\t  pointerover: true,\n\t  pointerenter: true,\n\t  pointerdown: true,\n\t  pointermove: true,\n\t  pointerup: true,\n\t  pointercancel: true,\n\t  pointerout: true,\n\t  pointerleave: true,\n\t  gotpointercapture: true,\n\t  lostpointercapture: true,\n\t  dragstart: true,\n\t  drag: true,\n\t  dragenter: true,\n\t  dragleave: true,\n\t  dragover: true,\n\t  drop: true,\n\t  dragend: true,\n\t  DOMActivate: true,\n\t  DOMFocusIn: true,\n\t  DOMFocusOut: true,\n\t  keypress: true\n\t};\n\t\n\tfunction pathComposer(startNode, composed) {\n\t  var composedPath = [];\n\t  var current = startNode;\n\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t  while (current) {\n\t    composedPath.push(current);\n\t    if (current.assignedSlot) {\n\t      current = current.assignedSlot;\n\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t      current = current.host;\n\t    } else {\n\t      current = current.parentNode;\n\t    }\n\t  }\n\t  // event composedPath includes window when startNode's ownerRoot is document\n\t  if (composedPath[composedPath.length - 1] === document) {\n\t    composedPath.push(window);\n\t  }\n\t  return composedPath;\n\t}\n\t\n\tfunction retarget(refNode, path) {\n\t  if (!isShadyRoot) {\n\t    return refNode;\n\t  }\n\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t  var refNodePath = pathComposer(refNode, true);\n\t  var p$ = path;\n\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t    ancestor = p$[i];\n\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t    if (root !== lastRoot) {\n\t      rootIdx = refNodePath.indexOf(root);\n\t      lastRoot = root;\n\t    }\n\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t      return ancestor;\n\t    }\n\t  }\n\t}\n\t\n\tvar EventMixin = {\n\t\n\t  __patched: 'Event',\n\t\n\t  get composed() {\n\t    if (this.isTrusted && this.__composed === undefined) {\n\t      this.__composed = alwaysComposed[this.type];\n\t    }\n\t    return this.__composed || false;\n\t  },\n\t\n\t  composedPath: function composedPath() {\n\t    if (!this.__composedPath) {\n\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t    }\n\t    return this.__composedPath;\n\t  },\n\t\n\t  get target() {\n\t    return retarget(this.currentTarget, this.composedPath());\n\t  },\n\t\n\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t  get relatedTarget() {\n\t    if (!this.__relatedTarget) {\n\t      return null;\n\t    }\n\t    if (!this.__relatedTargetComposedPath) {\n\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t    }\n\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t  },\n\t  stopPropagation: function stopPropagation() {\n\t    Event.prototype.stopPropagation.call(this);\n\t    this.__propagationStopped = true;\n\t  },\n\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t    Event.prototype.stopImmediatePropagation.call(this);\n\t    this.__immediatePropagationStopped = true;\n\t    this.__propagationStopped = true;\n\t  }\n\t\n\t};\n\t\n\tfunction mixinComposedFlag(Base) {\n\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t  // try to do `Base.call` with a dom construtor.\n\t  var klazz = function(type, options) {\n\t    var event = new Base(type, options);\n\t    event.__composed = options && Boolean(options.composed);\n\t    return event;\n\t  }\n\t  // put constructor properties on subclass\n\t  mixin(klazz, Base);\n\t  klazz.prototype = Base.prototype;\n\t  return klazz;\n\t}\n\t\n\tvar nonBubblingEventsToRetarget = {\n\t  focus: true,\n\t  blur: true\n\t};\n\t\n\tfunction fireHandlers(event, node, phase) {\n\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t    node.__handlers[event.type][phase];\n\t  if (hs) {\n\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t      fn.call(node, event);\n\t      if (event.__immediatePropagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction retargetNonBubblingEvent(e) {\n\t  var path = e.composedPath();\n\t  var node;\n\t  // override `currentTarget` to let patched `target` calculate correctly\n\t  Object.defineProperty(e, 'currentTarget', {\n\t    get: function() {\n\t      return node;\n\t    },\n\t    configurable: true\n\t  });\n\t  for (var i = path.length - 1; i >= 0; i--) {\n\t    node = path[i];\n\t    // capture phase fires all capture handlers\n\t    fireHandlers(e, node, 'capture');\n\t    if (e.__propagationStopped) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  // set the event phase to `AT_TARGET` as in spec\n\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\n\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t  // keep track of the last seen owner root\n\t  var lastFiredRoot;\n\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t    node = path[i$1];\n\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t      fireHandlers(e, node, 'bubble');\n\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t      if (node !== window) {\n\t        lastFiredRoot = node.getRootNode();\n\t      }\n\t      if (e.__propagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t  // It's more efficient to store the node/type/options information as Array in\n\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  if (fn.__eventWrappers) {\n\t    // Stop if the wrapper function has already been created.\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        return;\n\t      }\n\t    }\n\t  } else {\n\t    fn.__eventWrappers = [];\n\t  }\n\t\n\t  var wrapperFn = function(e) {\n\t    // Support `once` option.\n\t    if (once) {\n\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t    }\n\t    if (!e.__target) {\n\t      e.__target = e.target;\n\t      e.__relatedTarget = e.relatedTarget;\n\t      patchPrototype(e, EventMixin);\n\t    }\n\t    // There are two critera that should stop events from firing on this node\n\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t        if (e.target === e.relatedTarget) {\n\t          e.stopImmediatePropagation();\n\t          return;\n\t        }\n\t      }\n\t      return fn(e);\n\t    }\n\t  };\n\t  // Store the wrapper information.\n\t  fn.__eventWrappers.push({\n\t    node: this,\n\t    type: type,\n\t    capture: capture,\n\t    once: once,\n\t    passive: passive,\n\t    wrapperFn: wrapperFn\n\t  });\n\t\n\t  if (nonBubblingEventsToRetarget[type]) {\n\t    this.__handlers = this.__handlers || {};\n\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t  } else {\n\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  // Search the wrapped function.\n\t  var wrapperFn = undefined;\n\t  if (fn.__eventWrappers) {\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t        // Cleanup.\n\t        if (!fn.__eventWrappers.length) {\n\t          fn.__eventWrappers = undefined;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t      this.__handlers && this.__handlers[type]) {\n\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t    var idx = arr.indexOf(wrapperFn);\n\t    if (idx > -1) {\n\t      arr.splice(idx, 1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction activateFocusEventOverrides() {\n\t  for (var ev in nonBubblingEventsToRetarget) {\n\t    window.addEventListener(ev, function(e) {\n\t      if (!e.__target) {\n\t        e.__target = e.target;\n\t        e.__relatedTarget = e.relatedTarget;\n\t        patchPrototype(e, EventMixin);\n\t        retargetNonBubblingEvent(e);\n\t        e.stopImmediatePropagation();\n\t      }\n\t    }, true);\n\t  }\n\t}\n\t\n\t\n\tvar PatchedEvent = mixinComposedFlag(Event);\n\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tif (settings.inUse) {\n\t\n\t  window.ShadyDOM = {\n\t    tree: tree,\n\t    getNativeProperty: getNativeProperty,\n\t    patch: patchNode,\n\t    isPatched: isNodePatched,\n\t    unpatch: unpatchNode,\n\t    isShadyRoot: isShadyRoot,\n\t    enqueue: enqueue,\n\t    flush: flush$1,\n\t    inUse: settings.inUse,\n\t    filterMutations: filterMutations,\n\t    observeChildren: observeChildren,\n\t    unobserveChildren: unobserveChildren\n\t  };\n\t\n\t  var createRootAndEnsurePatched = function(node) {\n\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t    // a timing problem with gathering composed children.\n\t    // (1) currently the child list is crawled and patched when patching occurs\n\t    // (this needs to change)\n\t    // (2) we can only patch when an element has received its parsed children\n\t    // because we cannot detect them when inserted by parser.\n\t    // let ancestor = node;\n\t    // while (ancestor) {\n\t    //   patchNode(ancestor);\n\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t    // }\n\t    patchNode(node);\n\t    var root = new ShadyRoot(node);\n\t    patchNode(root);\n\t    return root;\n\t  }\n\t\n\t  Element.prototype.attachShadow = function() {\n\t    return createRootAndEnsurePatched(this);\n\t  }\n\t\n\t  Node.prototype.addEventListener = addEventListener;\n\t  Node.prototype.removeEventListener = removeEventListener;\n\t  Event = PatchedEvent;\n\t  CustomEvent = PatchedCustomEvent;\n\t  MouseEvent = PatchedMouseEvent;\n\t  activateFocusEventOverrides();\n\t\n\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t    get: function get() {\n\t      return document.documentElement.contains(this);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Node.prototype.getRootNode = function(options) {\n\t    return getRootNode(this, options);\n\t  }\n\t\n\t  Object.defineProperty(Element.prototype, 'slot', {\n\t    get: function get$1() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set(value) {\n\t      this.setAttribute('slot', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t    get: function get$2() {\n\t      return this._assignedSlot || null;\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Element.prototype.setAttribute = setAttribute;\n\t\n\t  Object.defineProperty(Element.prototype, 'className', {\n\t    get: function get$3() {\n\t      return this.getAttribute('class');\n\t    },\n\t    set: function set$1(value) {\n\t      this.setAttribute('class', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t  // via appendChild. This either needs to be expanded or contracted.\n\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t  //   patchNode(this);\n\t  //   return this.appendChild(node);\n\t  // }\n\t\n\t}\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadydom.min.js.map\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tExtremely simple css parser. Intended to be not more than what we need\n\tand definitely not necessarily correct =).\n\t*/\n\t\n\t// given a string of css, return a simple rule tree\n\t\n\tfunction parse(text) {\n\t  text = clean(text);\n\t  return parseCss(lex(text), text);\n\t}\n\t\n\t// remove stuff we don't care about that may hinder parsing\n\tfunction clean(cssText) {\n\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t}\n\t\n\t// super simple {...} lexer that returns a node tree\n\tfunction lex(text) {\n\t  var root = {\n\t    start: 0,\n\t    end: text.length\n\t  };\n\t  var n = root;\n\t  for (var i = 0, l = text.length; i < l; i++) {\n\t    if (text[i] === OPEN_BRACE) {\n\t      if (!n.rules) {\n\t        n.rules = [];\n\t      }\n\t      var p = n;\n\t      var previous = p.rules[p.rules.length - 1];\n\t      n = {\n\t        start: i + 1,\n\t        parent: p,\n\t        previous: previous\n\t      };\n\t      p.rules.push(n);\n\t    } else if (text[i] === CLOSE_BRACE) {\n\t      n.end = i + 1;\n\t      n = n.parent || root;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// add selectors/cssText to node tree\n\tfunction parseCss(node, text) {\n\t  var t = text.substring(node.start, node.end - 1);\n\t  node.parsedCssText = node.cssText = t.trim();\n\t  if (node.parent) {\n\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t    t = text.substring(ss, node.start - 1);\n\t    t = _expandUnicodeEscapes(t);\n\t    t = t.replace(RX.multipleSpaces, ' ');\n\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t    // helps with mixin syntax\n\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t    var s = node.parsedSelector = node.selector = t.trim();\n\t    node.atRule = s.indexOf(AT_START) === 0;\n\t    // note, support a subset of rule types...\n\t    if (node.atRule) {\n\t      if (s.indexOf(MEDIA_START) === 0) {\n\t        node.type = types.MEDIA_RULE;\n\t      } else if (s.match(RX.keyframesRule)) {\n\t        node.type = types.KEYFRAMES_RULE;\n\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t      }\n\t    } else {\n\t      if (s.indexOf(VAR_START) === 0) {\n\t        node.type = types.MIXIN_RULE;\n\t      } else {\n\t        node.type = types.STYLE_RULE;\n\t      }\n\t    }\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      parseCss(r, text);\n\t    }\n\t  }\n\t  return node;\n\t}\n\t\n\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t// expanded form that doesn't require trailing space `\\000033`\n\tfunction _expandUnicodeEscapes(s) {\n\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t    var code = arguments[1],\n\t        repeat = 6 - code.length;\n\t    while (repeat--) {\n\t      code = '0' + code;\n\t    }\n\t    return '\\\\' + code;\n\t  });\n\t}\n\t\n\t// stringify parsed css.\n\tfunction stringify(node, preserveProperties, text) {\n\t  text = text || '';\n\t  // calc rule cssText\n\t  var cssText = '';\n\t  if (node.cssText || node.rules) {\n\t    var r$ = node.rules;\n\t    if (r$ && !_hasMixinRules(r$)) {\n\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t        cssText = stringify(r, preserveProperties, cssText);\n\t      }\n\t    } else {\n\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t      cssText = cssText.trim();\n\t      if (cssText) {\n\t        cssText = '  ' + cssText + '\\n';\n\t      }\n\t    }\n\t  }\n\t  // emit rule if there is cssText\n\t  if (cssText) {\n\t    if (node.selector) {\n\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t    }\n\t    text += cssText;\n\t    if (node.selector) {\n\t      text += CLOSE_BRACE + '\\n\\n';\n\t    }\n\t  }\n\t  return text;\n\t}\n\t\n\tfunction _hasMixinRules(rules) {\n\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t}\n\t\n\tfunction removeCustomProps(cssText) {\n\t  cssText = removeCustomPropAssignment(cssText);\n\t  return removeCustomPropApply(cssText);\n\t}\n\t\n\tfunction removeCustomPropAssignment(cssText) {\n\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t}\n\t\n\tfunction removeCustomPropApply(cssText) {\n\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t}\n\t\n\tvar types = {\n\t  STYLE_RULE: 1,\n\t  KEYFRAMES_RULE: 7,\n\t  MEDIA_RULE: 4,\n\t  MIXIN_RULE: 1000\n\t};\n\t\n\tvar OPEN_BRACE = '{';\n\tvar CLOSE_BRACE = '}';\n\t\n\t// helper regexp's\n\tvar RX = {\n\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t  port: /@import[^;]*;/gim,\n\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t  multipleSpaces: /\\s+/g\n\t};\n\t\n\tvar VAR_START = '--';\n\tvar MEDIA_START = '@media';\n\tvar AT_START = '@';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\n\t// experimental support for native @apply\n\tfunction detectNativeApply() {\n\t  var style = document.createElement('style');\n\t  style.textContent = '.foo { @apply --foo }';\n\t  document.head.appendChild(style);\n\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t  document.head.removeChild(style);\n\t  return nativeCssApply;\n\t}\n\t\n\tvar nativeCssApply = false && detectNativeApply();\n\t\n\tfunction parseSettings(settings) {\n\t  if (settings) {\n\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t  }\n\t}\n\t\n\tif (window.ShadyCSS) {\n\t  parseSettings(window.ShadyCSS);\n\t} else if (window.WebComponents) {\n\t  parseSettings(window.WebComponents.flags);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction toCssText(rules, callback) {\n\t  if (typeof rules === 'string') {\n\t    rules = parse(rules);\n\t  }\n\t  if (callback) {\n\t    forEachRule(rules, callback);\n\t  }\n\t  return stringify(rules, nativeCssVariables);\n\t}\n\t\n\tfunction rulesForStyle(style) {\n\t  if (!style.__cssRules && style.textContent) {\n\t    style.__cssRules = parse(style.textContent);\n\t  }\n\t  return style.__cssRules;\n\t}\n\t\n\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t// like a normal selector but is not (it has nothing to do with scoping\n\t// for example).\n\tfunction isKeyframesSelector(rule) {\n\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t}\n\t\n\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t  if (!node) {\n\t    return;\n\t  }\n\t  var skipRules = false;\n\t  if (onlyActiveRules) {\n\t    if (node.type === types.MEDIA_RULE) {\n\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t      if (matchMedia) {\n\t        // if rule is a non matching @media rule, skip subrules\n\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t          skipRules = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  if (node.type === types.STYLE_RULE) {\n\t    styleRuleCallback(node);\n\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t    keyframesRuleCallback(node);\n\t  } else if (node.type === types.MIXIN_RULE) {\n\t    skipRules = true;\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$ && !skipRules) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t    }\n\t  }\n\t}\n\t\n\t// add a string of cssText to the document.\n\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t  var style = createScopeStyle(cssText, moniker);\n\t  return applyStyle$1(style, target, contextNode);\n\t}\n\t\n\tfunction applyStyle$1(style, target, contextNode) {\n\t  target = target || document.head;\n\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t  lastHeadApplyNode = style;\n\t  return target.insertBefore(style, after);\n\t}\n\t\n\tfunction createScopeStyle(cssText, moniker) {\n\t  var style = document.createElement('style');\n\t  if (moniker) {\n\t    style.setAttribute('scope', moniker);\n\t  }\n\t  style.textContent = cssText;\n\t  return style;\n\t}\n\t\n\tvar lastHeadApplyNode = null;\n\t\n\t// insert a comment node as a styling position placeholder.\n\tfunction applyStylePlaceHolder(moniker) {\n\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t  var scope = document.head;\n\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t  lastHeadApplyNode = placeHolder;\n\t  return placeHolder;\n\t}\n\t\n\t\n\t\n\t// cssBuildTypeForModule: function (module) {\n\t//   let dm = Polymer.DomModule.import(module);\n\t//   if (dm) {\n\t//     return getCssBuildType(dm);\n\t//   }\n\t// },\n\t//\n\t\n\t\n\t// Walk from text[start] matching parens\n\t// returns position of the outer end paren\n\tfunction findMatchingParen(text, start) {\n\t  var level = 0;\n\t  for (var i = start, l = text.length; i < l; i++) {\n\t    if (text[i] === '(') {\n\t      level++;\n\t    } else if (text[i] === ')') {\n\t      if (--level === 0) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tfunction processVariableAndFallback(str, callback) {\n\t  // find 'var('\n\t  var start = str.indexOf('var(');\n\t  if (start === -1) {\n\t    // no var?, everything is prefix\n\t    return callback(str, '', '', '');\n\t  }\n\t  //${prefix}var(${inner})${suffix}\n\t  var end = findMatchingParen(str, start + 3);\n\t  var inner = str.substring(start + 4, end);\n\t  var prefix = str.substring(0, start);\n\t  // suffix may have other variables\n\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t  var comma = inner.indexOf(',');\n\t  // value and fallback args should be trimmed to match in property lookup\n\t  if (comma === -1) {\n\t    // variable, no fallback\n\t    return callback(prefix, inner.trim(), '', suffix);\n\t  }\n\t  // var(${value},${fallback})\n\t  var value = inner.substring(0, comma).trim();\n\t  var fallback = inner.substring(comma + 1).trim();\n\t  return callback(prefix, value, fallback, suffix);\n\t}\n\t\n\tvar rx = {\n\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t  IS_VAR: /^--/,\n\t  BRACKETED: /\\{[^}]*\\}/g,\n\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\n\t* scoping:\n\t\n\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t  * selectors re-written as follows:\n\t\n\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\n\t* :host -> scopeName\n\t\n\t* :host(...) -> scopeName...\n\t\n\t* ::slotted(...) -> scopeName > ...\n\t\n\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\n\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\n\t*/\n\tvar SCOPE_NAME = 'style-scope';\n\t\n\tvar StyleTransformer = {\n\t\n\t  // Given a node and scope name, add a scoping class to each node\n\t  // in the tree. This facilitates transforming css into scoped rules.\n\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t    // one time optimization to skip scoping...\n\t    if (node.__styleScoped) {\n\t      node.__styleScoped = null;\n\t    } else {\n\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t    }\n\t  },\n\t\n\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t    if (node.classList) {\n\t      this.element(node, selector, shouldRemoveScope);\n\t    }\n\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t    if (c$) {\n\t      for (var i = 0; i < c$.length; i++) {\n\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t      }\n\t    }\n\t  },\n\t\n\t  element: function element(_element, scope, shouldRemoveScope) {\n\t    // note: if using classes, we add both the general 'style-scope' class\n\t    // as well as the specific scope. This enables easy filtering of all\n\t    // `style-scope` elements\n\t    if (scope) {\n\t      // note: svg on IE does not have classList so fallback to class\n\t      if (_element.classList) {\n\t        if (shouldRemoveScope) {\n\t          _element.classList.remove(SCOPE_NAME);\n\t          _element.classList.remove(scope);\n\t        } else {\n\t          _element.classList.add(SCOPE_NAME);\n\t          _element.classList.add(scope);\n\t        }\n\t      } else if (_element.getAttribute) {\n\t        var c = _element.getAttribute(CLASS);\n\t        if (shouldRemoveScope) {\n\t          if (c) {\n\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t          }\n\t        } else {\n\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t    var cssBuildType = element.__cssBuild;\n\t    // no need to shim selectors if settings.useNativeShadow, also\n\t    // a shady css build will already have transformed selectors\n\t    // NOTE: This method may be called as part of static or property shimming.\n\t    // When there is a targeted build it will not be called for static shimming,\n\t    // but when the property shim is used it is called and should opt out of\n\t    // static shimming work when a proper build exists.\n\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t    return cssText.trim();\n\t  },\n\t\n\t  // Given a string of cssText and a scoping string (scope), returns\n\t  // a string of scoped css where each selector is transformed to include\n\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t  // (e.g. :host) to use the scoping selector.\n\t  css: function css(rules, scope, ext, callback) {\n\t    var hostScope = this._calcHostScope(scope, ext);\n\t    scope = this._calcElementScope(scope);\n\t    var self = this;\n\t    return toCssText(rules, function (rule) {\n\t      if (!rule.isScoped) {\n\t        self.rule(rule, scope, hostScope);\n\t        rule.isScoped = true;\n\t      }\n\t      if (callback) {\n\t        callback(rule, scope, hostScope);\n\t      }\n\t    });\n\t  },\n\t\n\t  _calcElementScope: function _calcElementScope(scope) {\n\t    if (scope) {\n\t      return CSS_CLASS_PREFIX + scope;\n\t    } else {\n\t      return '';\n\t    }\n\t  },\n\t\n\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t    return ext ? '[is=' + scope + ']' : scope;\n\t  },\n\t\n\t  rule: function rule(_rule, scope, hostScope) {\n\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t  },\n\t\n\t  // transforms a css rule to a scoped rule.\n\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t    // against selectors (e.g. when calculating style properties)\n\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t  },\n\t\n\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t    // we want to skip transformation of rules that appear in keyframes,\n\t    // because they are keyframe selectors, not element selectors.\n\t    if (!isKeyframesSelector(rule)) {\n\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t      }\n\t    }\n\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t  },\n\t\n\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t    var _this = this;\n\t\n\t    var stop = false;\n\t    selector = selector.trim();\n\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t    });\n\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t      if (!stop) {\n\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t        stop = stop || info.stop;\n\t        c = info.combinator;\n\t        s = info.value;\n\t      }\n\t      return c + s;\n\t    });\n\t    return selector;\n\t  },\n\t\n\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t    // replace :host with host scoping class\n\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t    if (selector.indexOf(HOST) >= 0) {\n\t      selector = this._transformHostSelector(selector, hostScope);\n\t      // replace other selectors with scoping class\n\t    } else if (slottedIndex !== 0) {\n\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t    }\n\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t    // also ignore left-side combinator\n\t    var slotted = false;\n\t    if (slottedIndex >= 0) {\n\t      combinator = '';\n\t      slotted = true;\n\t    }\n\t    // process scope jumping selectors up to the scope jump and then stop\n\t    var stop = void 0;\n\t    if (slotted) {\n\t      stop = true;\n\t      if (slotted) {\n\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t          return ' > ' + paren;\n\t        });\n\t      }\n\t    }\n\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t    });\n\t    return { value: selector, combinator: combinator, stop: stop };\n\t  },\n\t\n\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t    p$[0] += scope;\n\t    return p$.join(PSEUDO_PREFIX);\n\t  },\n\t\n\t  // :host(...) -> scopeName...\n\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t    var m = selector.match(HOST_PAREN);\n\t    var paren = m && m[2].trim() || '';\n\t    if (paren) {\n\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t        // paren starts with a type selector\n\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t        // if the type selector is our hostScope then avoid pre-pending it\n\t        if (typeSelector === hostScope) {\n\t          return paren;\n\t          // otherwise, this selector should not match in this scope so\n\t          // output a bogus selector.\n\t        } else {\n\t          return SELECTOR_NO_MATCH;\n\t        }\n\t      } else {\n\t        // make sure to do a replace here to catch selectors like:\n\t        // `:host(.foo)::before`\n\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t          return hostScope + paren;\n\t        });\n\t      }\n\t      // if no paren, do a straight :host replacement.\n\t      // TODO(sorvell): this should not strictly be necessary but\n\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t      // which have been improperly used under Shady DOM. This should be\n\t      // deprecated.\n\t    } else {\n\t      return selector.replace(HOST, hostScope);\n\t    }\n\t  },\n\t\n\t  documentRule: function documentRule(rule) {\n\t    // reset selector in case this is redone.\n\t    rule.selector = rule.parsedSelector;\n\t    this.normalizeRootSelector(rule);\n\t    this._transformRule(rule, this._transformDocumentSelector);\n\t  },\n\t\n\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t    if (rule.selector === ROOT) {\n\t      rule.selector = 'html';\n\t    }\n\t  },\n\t\n\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t  },\n\t  SCOPE_NAME: SCOPE_NAME\n\t};\n\t\n\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\tvar COMPLEX_SELECTOR_SEP = ',';\n\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\tvar HOST = ':host';\n\tvar ROOT = ':root';\n\tvar SLOTTED = '::slotted';\n\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t// NOTE: this supports 1 nested () pair for things like\n\t// :host(:not([selected]), more general support requires\n\t// parsing which seems like overkill\n\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t// similar to HOST_PAREN\n\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\tvar CSS_CLASS_PREFIX = '.';\n\tvar PSEUDO_PREFIX = ':';\n\tvar CLASS = 'class';\n\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar StyleInfo = function () {\n\t  createClass(StyleInfo, null, [{\n\t    key: 'get',\n\t    value: function get(node) {\n\t      return node.__styleInfo;\n\t    }\n\t  }, {\n\t    key: 'set',\n\t    value: function set(node, styleInfo) {\n\t      node.__styleInfo = styleInfo;\n\t      return styleInfo;\n\t    }\n\t  }]);\n\t\n\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t    classCallCheck(this, StyleInfo);\n\t\n\t    this.styleRules = ast || null;\n\t    this.placeholder = placeholder || null;\n\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t    this.overrideStyleProperties = {};\n\t    this.elementName = elementName || '';\n\t    this.cssBuild = cssBuild || '';\n\t    this.typeExtension = typeExtension || '';\n\t    this.styleProperties = null;\n\t    this.scopeSelector = null;\n\t    this.customStyle = null;\n\t  }\n\t\n\t  return StyleInfo;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO: dedupe with shady\n\tvar p = window.Element.prototype;\n\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\n\tvar StyleProperties = {\n\t\n\t  // decorates styles with rule info and returns an array of used style\n\t  // property names\n\t  decorateStyles: function decorateStyles(rules) {\n\t    var self = this,\n\t        props = {},\n\t        keyframes = [],\n\t        ruleIndex = 0;\n\t    forEachRule(rules, function (rule) {\n\t      self.decorateRule(rule);\n\t      // mark in-order position of ast rule in styles block, used for cache key\n\t      rule.index = ruleIndex++;\n\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t    }, function onKeyframesRule(rule) {\n\t      keyframes.push(rule);\n\t    });\n\t    // Cache all found keyframes rules for later reference:\n\t    rules._keyframes = keyframes;\n\t    // return this list of property names *consumes* in these styles.\n\t    var names = [];\n\t    for (var i in props) {\n\t      names.push(i);\n\t    }\n\t    return names;\n\t  },\n\t\n\t  // decorate a single rule with property info\n\t  decorateRule: function decorateRule(rule) {\n\t    if (rule.propertyInfo) {\n\t      return rule.propertyInfo;\n\t    }\n\t    var info = {},\n\t        properties = {};\n\t    var hasProperties = this.collectProperties(rule, properties);\n\t    if (hasProperties) {\n\t      info.properties = properties;\n\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t      rule.rules = null;\n\t    }\n\t    info.cssText = this.collectCssText(rule);\n\t    rule.propertyInfo = info;\n\t    return info;\n\t  },\n\t\n\t  // collects the custom properties from a rule's cssText\n\t  collectProperties: function collectProperties(rule, properties) {\n\t    var info = rule.propertyInfo;\n\t    if (info) {\n\t      if (info.properties) {\n\t        Object.assign(properties, info.properties);\n\t        return true;\n\t      }\n\t    } else {\n\t      var m = void 0,\n\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t      var cssText = rule.parsedCssText;\n\t      var value = void 0;\n\t      var any = void 0;\n\t      while (m = rx$$1.exec(cssText)) {\n\t        // note: group 2 is var, 3 is mixin\n\t        value = (m[2] || m[3]).trim();\n\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t        if (value !== 'inherit' || value !== 'unset') {\n\t          properties[m[1].trim()] = value;\n\t        }\n\t        any = true;\n\t      }\n\t      return any;\n\t    }\n\t  },\n\t\n\t  // returns cssText of properties that consume variables/mixins\n\t  collectCssText: function collectCssText(rule) {\n\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t  },\n\t\n\t  // NOTE: we support consumption inside mixin assignment\n\t  // but not production, so strip out {...}\n\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t  },\n\t\n\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t    var m = void 0;\n\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t      var name = m[1];\n\t      // This regex catches all variable names, and following non-whitespace char\n\t      // If next char is not ':', then variable is a consumer\n\t      if (m[2] !== ':') {\n\t        props[name] = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  // turns custom properties into realized values.\n\t  reify: function reify(props) {\n\t    // big perf optimization here: reify only *own* properties\n\t    // since this object has __proto__ of the element's scope properties\n\t    var names = Object.getOwnPropertyNames(props);\n\t    for (var i = 0, n; i < names.length; i++) {\n\t      n = names[i];\n\t      props[n] = this.valueForProperty(props[n], props);\n\t    }\n\t  },\n\t\n\t  // given a property value, returns the reified value\n\t  // a property value may be:\n\t  // (1) a literal value like: red or 5px;\n\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t  // var(--a, var(--b));\n\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t  valueForProperty: function valueForProperty(property, props) {\n\t    var _this = this;\n\t\n\t    // case (1) default\n\t    // case (3) defines a mixin and we have to reify the internals\n\t    if (property) {\n\t      if (property.indexOf(';') >= 0) {\n\t        property = this.valueForProperties(property, props);\n\t      } else {\n\t        (function () {\n\t          // case (2) variable\n\t          var self = _this;\n\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t            if (!value) {\n\t              return prefix + suffix;\n\t            }\n\t            var propertyValue = self.valueForProperty(props[value], props);\n\t            // if value is \"initial\", then the variable should be treated as unset\n\t            if (!propertyValue || propertyValue === 'initial') {\n\t              // fallback may be --a or var(--a) or literal\n\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t              // for use with native css variables.\n\t              // Since we have full control, we can use `inherit` directly.\n\t              propertyValue = 'inherit';\n\t            }\n\t            return prefix + (propertyValue || '') + suffix;\n\t          };\n\t          property = processVariableAndFallback(property, fn);\n\t        })();\n\t      }\n\t    }\n\t    return property && property.trim() || '';\n\t  },\n\t\n\t  // note: we do not yet support mixin within mixin\n\t  valueForProperties: function valueForProperties(property, props) {\n\t    var parts = property.split(';');\n\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t      if (_p = parts[i]) {\n\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t        if (m) {\n\t          _p = this.valueForProperty(props[m[1]], props);\n\t        } else {\n\t          var colon = _p.indexOf(':');\n\t          if (colon !== -1) {\n\t            var pp = _p.substring(colon);\n\t            pp = pp.trim();\n\t            pp = this.valueForProperty(pp, props) || pp;\n\t            _p = _p.substring(0, colon) + pp;\n\t          }\n\t        }\n\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t        // strip trailing ;\n\t        _p.slice(0, -1) : _p || '';\n\t      }\n\t    }\n\t    return parts.join(';');\n\t  },\n\t\n\t  applyProperties: function applyProperties(rule, props) {\n\t    var output = '';\n\t    // dynamically added sheets may not be decorated so ensure they are.\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (rule.propertyInfo.cssText) {\n\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t  // functions which take in cssText and spit out transformed cssText.\n\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t    var input = rule.cssText;\n\t    var output = rule.cssText;\n\t    if (rule.hasAnimations == null) {\n\t      // Cache whether or not the rule has any animations to begin with:\n\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t    }\n\t    // If there are no animations referenced, we can skip transforms:\n\t    if (rule.hasAnimations) {\n\t      var transform = void 0;\n\t      // If we haven't transformed this rule before, we iterate over all\n\t      // transforms:\n\t      if (rule.keyframeNamesToTransform == null) {\n\t        rule.keyframeNamesToTransform = [];\n\t        for (var keyframe in keyframeTransforms) {\n\t          transform = keyframeTransforms[keyframe];\n\t          output = transform(input);\n\t          // If the transform actually changed the CSS text, we cache the\n\t          // transform name for future use:\n\t          if (input !== output) {\n\t            input = output;\n\t            rule.keyframeNamesToTransform.push(keyframe);\n\t          }\n\t        }\n\t      } else {\n\t        // If we already have a list of keyframe names that apply to this\n\t        // rule, we apply only those keyframe name transforms:\n\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t          input = transform(input);\n\t        }\n\t        output = input;\n\t      }\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Test if the rules in these styles matches the given `element` and if so,\n\t  // collect any custom properties into `props`.\n\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t    var props = {},\n\t        self = this;\n\t    // generates a unique key for these matches\n\t    var o = [];\n\t    // note: active rules excludes non-matching @media rules\n\t    forEachRule(rules, function (rule) {\n\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t      // time to only include ones that have properties\n\t      if (!rule.propertyInfo) {\n\t        self.decorateRule(rule);\n\t      }\n\t      // match element against transformedSelector: selector may contain\n\t      // unwanted uniquification and parsedSelector does not directly match\n\t      // for :host selectors.\n\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t          self.collectProperties(rule, props);\n\t          // produce numeric key for these matches for lookup\n\t          addToBitMask(rule.index, o);\n\t        }\n\t      }\n\t    }, null, true);\n\t    return { properties: props, key: o };\n\t  },\n\t\n\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (!rule.propertyInfo.properties) {\n\t      return;\n\t    }\n\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t    var parsedSelector = rule.parsedSelector;\n\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t    // build info is either in scope (when scope is an element) or in the style\n\t    // when scope is the default scope; note: this allows default scope to have\n\t    // mixed mode built and unbuilt styles.\n\t    if (cssBuild === 'shady') {\n\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t    }\n\t    if (cssBuild === 'shadow') {\n\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t      isHost = isHost && !isRoot;\n\t    }\n\t    if (!isRoot && !isHost) {\n\t      return;\n\t    }\n\t    var selectorToMatch = hostScope;\n\t    if (isHost) {\n\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t      if (nativeShadow && !rule.transformedSelector) {\n\t        // transform :host into a matchable selector\n\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t      }\n\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t    }\n\t    callback({\n\t      selector: selectorToMatch,\n\t      isHost: isHost,\n\t      isRoot: isRoot\n\t    });\n\t  },\n\t\n\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t    var hostProps = {},\n\t        rootProps = {},\n\t        self = this;\n\t    // note: active rules excludes non-matching @media rules\n\t    var cssBuild = rules && rules.__cssBuild;\n\t    forEachRule(rules, function (rule) {\n\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t        var element = scope._element || scope;\n\t        if (matchesSelector.call(element, info.selector)) {\n\t          if (info.isHost) {\n\t            self.collectProperties(rule, hostProps);\n\t          } else {\n\t            self.collectProperties(rule, rootProps);\n\t          }\n\t        }\n\t      });\n\t    }, null, true);\n\t    return { rootProps: rootProps, hostProps: hostProps };\n\t  },\n\t\n\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t    var self = this;\n\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t    var rules = StyleInfo.get(element).styleRules;\n\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t      self.applyProperties(rule, properties);\n\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t        // is not necessary to apply them in ShadowDOM.\n\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t      }\n\t    });\n\t  },\n\t\n\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t    var keyframesRules = rules._keyframes;\n\t    var keyframeTransforms = {};\n\t    if (!nativeShadow && keyframesRules) {\n\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t      // advance for the current scope. This allows us to catch keyframes\n\t      // rules that appear anywhere in the stylesheet:\n\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t      }\n\t    }\n\t    return keyframeTransforms;\n\t  },\n\t\n\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t  // particular scoped keyframes rule.\n\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t    return function (cssText) {\n\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t    };\n\t  },\n\t\n\t  // Transforms `@keyframes` names to be unique for the current host.\n\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t  },\n\t\n\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t  // have low specificity. They are overrideable by class selectors but,\n\t  // unfortunately, not by type selectors (e.g. overriding via\n\t  // `.special` is ok, but not by `x-foo`).\n\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    var selector = rule.transformedSelector;\n\t    var scope = '.' + scopeId;\n\t    var parts = selector.split(',');\n\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t    }\n\t    rule.selector = parts.join(',');\n\t  },\n\t\n\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t    var c = element.getAttribute('class') || '';\n\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t    if (c !== v) {\n\t      element.setAttribute('class', v);\n\t    }\n\t  },\n\t\n\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t    // calculate cssText to apply\n\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t    // if shady and we have a cached style that is not style, decrement\n\t    var styleInfo = StyleInfo.get(element);\n\t    var s = styleInfo.customStyle;\n\t    if (s && !nativeShadow && s !== style) {\n\t      s._useCount--;\n\t      if (s._useCount <= 0 && s.parentNode) {\n\t        s.parentNode.removeChild(s);\n\t      }\n\t    }\n\t    // apply styling always under native or if we generated style\n\t    // or the cached style is not in document(!)\n\t    if (nativeShadow) {\n\t      // update existing style only under native\n\t      if (styleInfo.customStyle) {\n\t        styleInfo.customStyle.textContent = cssText;\n\t        style = styleInfo.customStyle;\n\t        // otherwise, if we have css to apply, do so\n\t      } else if (cssText) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t      }\n\t    } else {\n\t      // shady and no cache hit\n\t      if (!style) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        if (cssText) {\n\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t        }\n\t        // shady and cache hit but not in document\n\t      } else if (!style.parentNode) {\n\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t      }\n\t    }\n\t    // ensure this style is our custom style and increment its use count.\n\t    if (style) {\n\t      style._useCount = style._useCount || 0;\n\t      // increment use count if we changed styles\n\t      if (styleInfo.customStyle != style) {\n\t        style._useCount++;\n\t      }\n\t      styleInfo.customStyle = style;\n\t    }\n\t    // @media rules may be stale in IE 10 and 11\n\t    if (IS_IE) {\n\t      style.textContent = style.textContent;\n\t    }\n\t    return style;\n\t  },\n\t\n\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t    var rules = rulesForStyle(style);\n\t    var self = this;\n\t    style.textContent = toCssText(rules, function (rule) {\n\t      var css = rule.cssText = rule.parsedCssText;\n\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t        // remove property assignments\n\t        // so next function isn't confused\n\t        // NOTE: we have 3 categories of css:\n\t        // (1) normal properties,\n\t        // (2) custom property assignments (--foo: red;),\n\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t        // are not and this makes this case unique.\n\t        css = removeCustomPropAssignment(css);\n\t        // replace with reified properties, scenario is same as mixin\n\t        rule.cssText = self.valueForProperties(css, properties);\n\t      }\n\t    });\n\t  },\n\t\n\t  rx: rx,\n\t  XSCOPE_NAME: 'x-scope'\n\t};\n\t\n\tfunction addToBitMask(n, bits) {\n\t  var o = parseInt(n / 32);\n\t  var v = 1 << n % 32;\n\t  bits[o] = (bits[o] || 0) | v;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar templateMap = {};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar placeholderMap = {};\n\t\n\tvar ce = window.customElements;\n\tif (ce && !nativeShadow) {\n\t  (function () {\n\t    var origDefine = ce.define;\n\t    ce.define = function (name, clazz, options) {\n\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t      return origDefine.call(ce, name, clazz, options);\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\tvar StyleCache = function () {\n\t  function StyleCache() {\n\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t    classCallCheck(this, StyleCache);\n\t\n\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t    this.cache = {};\n\t    this.typeMax = typeMax;\n\t  }\n\t\n\t  createClass(StyleCache, [{\n\t    key: '_validate',\n\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t        var pn = ownPropertyNames[idx];\n\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'store',\n\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t      var list = this.cache[tagname] || [];\n\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t      if (list.length > this.typeMax) {\n\t        list.shift();\n\t      }\n\t      this.cache[tagname] = list;\n\t    }\n\t  }, {\n\t    key: 'fetch',\n\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t      var list = this.cache[tagname];\n\t      if (!list) {\n\t        return;\n\t      }\n\t      // reverse list for most-recent lookups\n\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t        var entry = list[idx];\n\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t          return entry;\n\t        }\n\t      }\n\t    }\n\t  }]);\n\t  return StyleCache;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/**\n\t * The apply shim simulates the behavior of `@apply` proposed at\n\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t * The approach is to convert a property like this:\n\t *\n\t *    --foo: {color: red; background: blue;}\n\t *\n\t * to this:\n\t *\n\t *    --foo_-_color: red;\n\t *    --foo_-_background: blue;\n\t *\n\t * Then where `@apply --foo` is used, that is converted to:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background);\n\t *\n\t * This approach generally works but there are some issues and limitations.\n\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t * another element sets it to:\n\t *\n\t *    --foo: { border: 2px solid red; }\n\t *\n\t * We must now ensure that the color and background from the previous setting\n\t * do not apply. This is accomplished by changing the property set to this:\n\t *\n\t *    --foo_-_border: 2px solid red;\n\t *    --foo_-_color: initial;\n\t *    --foo_-_background: initial;\n\t *\n\t * This works but introduces one new issue.\n\t * Consider this setup at the point where the `@apply` is used:\n\t *\n\t *    background: orange;\n\t *    @apply --foo;\n\t *\n\t * In this case the background will be unset (initial) rather than the desired\n\t * `orange`. We address this by altering the property set to use a fallback\n\t * value like this:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background, orange);\n\t *    border: var(--foo_-_border);\n\t *\n\t * Note that the default is retained in the property set and the `background` is\n\t * the desired `orange`. This leads us to a limitation.\n\t *\n\t * Limitation 1:\n\t\n\t * Only properties in the rule where the `@apply`\n\t * is used are considered as default values.\n\t * If another rule matches the element and sets `background` with\n\t * less specificity than the rule in which `@apply` appears,\n\t * the `background` will not be set.\n\t *\n\t * Limitation 2:\n\t *\n\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t * `@apply` properties.\n\t\n\t*/\n\t\n\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\n\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\n\t// separator used between mixin-name and mixin-property-name when producing properties\n\t// NOTE: plain '-' may cause collisions in user styles\n\tvar MIXIN_VAR_SEP = '_-_';\n\t\n\t// map of mixin to property names\n\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\n\tvar MixinMap = function () {\n\t  function MixinMap() {\n\t    classCallCheck(this, MixinMap);\n\t\n\t    this._map = {};\n\t  }\n\t\n\t  createClass(MixinMap, [{\n\t    key: 'set',\n\t    value: function set(name, props) {\n\t      name = name.trim();\n\t      this._map[name] = {\n\t        properties: props,\n\t        dependants: {}\n\t      };\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get(name) {\n\t      name = name.trim();\n\t      return this._map[name];\n\t    }\n\t  }]);\n\t  return MixinMap;\n\t}();\n\t\n\tvar ApplyShim = function () {\n\t  function ApplyShim() {\n\t    var _this = this;\n\t\n\t    classCallCheck(this, ApplyShim);\n\t\n\t    this._currentTemplate = null;\n\t    this._measureElement = null;\n\t    this._map = new MixinMap();\n\t    this._separator = MIXIN_VAR_SEP;\n\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t    };\n\t  }\n\t\n\t  createClass(ApplyShim, [{\n\t    key: 'transformStyle',\n\t    value: function transformStyle(style, elementName) {\n\t      var ast = rulesForStyle(style);\n\t      this.transformRules(ast, elementName);\n\t      return ast;\n\t    }\n\t  }, {\n\t    key: 'transformRules',\n\t    value: function transformRules(rules, elementName) {\n\t      var _this2 = this;\n\t\n\t      this._currentTemplate = templateMap[elementName];\n\t      forEachRule(rules, function (r) {\n\t        _this2.transformRule(r);\n\t      });\n\t      if (this._currentTemplate) {\n\t        this._currentTemplate.__applyShimInvalid = false;\n\t      }\n\t      this._currentTemplate = null;\n\t    }\n\t  }, {\n\t    key: 'transformRule',\n\t    value: function transformRule(rule) {\n\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t      // :root was only used for variable assignment in property shim,\n\t      // but generates invalid selectors with real properties.\n\t      // replace with `:host > *`, which serves the same effect\n\t      if (rule.selector === ':root') {\n\t        rule.selector = ':host > *';\n\t      }\n\t    }\n\t  }, {\n\t    key: 'transformCssText',\n\t    value: function transformCssText(cssText) {\n\t      // produce variables\n\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t      // consume mixins\n\t      return this._consumeCssProperties(cssText);\n\t    }\n\t  }, {\n\t    key: '_getInitialValueForProperty',\n\t    value: function _getInitialValueForProperty(property) {\n\t      if (!this._measureElement) {\n\t        this._measureElement = document.createElement('meta');\n\t        this._measureElement.style.all = 'initial';\n\t        document.head.appendChild(this._measureElement);\n\t      }\n\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t    }\n\t    // replace mixin consumption with variable consumption\n\t\n\t  }, {\n\t    key: '_consumeCssProperties',\n\t    value: function _consumeCssProperties(text) {\n\t      var m = void 0;\n\t      // loop over text until all mixins with defintions have been applied\n\t      while (m = MIXIN_MATCH.exec(text)) {\n\t        var matchText = m[0];\n\t        var mixinName = m[1];\n\t        var idx = m.index;\n\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t        var applyPos = idx + matchText.indexOf('@apply');\n\t        var afterApplyPos = idx + matchText.length;\n\t        // find props defined before this @apply\n\t        var textBeforeApply = text.slice(0, applyPos);\n\t        var textAfterApply = text.slice(afterApplyPos);\n\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t        // use regex match position to replace mixin, keep linear processing time\n\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t        // move regex search to _after_ replacement\n\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t      }\n\t      return text;\n\t    }\n\t    // produce variable consumption at the site of mixin consumption\n\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t    // Example:\n\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\n\t  }, {\n\t    key: '_atApplyToCssProperties',\n\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t      var vars = [];\n\t      var mixinEntry = this._map.get(mixinName);\n\t      // if we depend on a mixin before it is created\n\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t      if (!mixinEntry) {\n\t        this._map.set(mixinName, {});\n\t        mixinEntry = this._map.get(mixinName);\n\t      }\n\t      if (mixinEntry) {\n\t        if (this._currentTemplate) {\n\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t        }\n\t        var p = void 0,\n\t            parts = void 0,\n\t            f = void 0;\n\t        for (p in mixinEntry.properties) {\n\t          f = fallbacks && fallbacks[p];\n\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t          if (f) {\n\t            parts.push(',', f);\n\t          }\n\t          parts.push(')');\n\t          vars.push(parts.join(''));\n\t        }\n\t      }\n\t      return vars.join('; ');\n\t    }\n\t  }, {\n\t    key: '_replaceInitialOrInherit',\n\t    value: function _replaceInitialOrInherit(property, value) {\n\t      var match = INITIAL_INHERIT.exec(value);\n\t      if (match) {\n\t        if (match[1]) {\n\t          // initial\n\t          // replace `initial` with the concrete initial value for this property\n\t          value = ApplyShim._getInitialValueForProperty(property);\n\t        } else {\n\t          // inherit\n\t          // with this purposfully illegal value, the variable will be invalid at\n\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t          // and for inheriting values, will behave similarly\n\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t          value = 'apply-shim-inherit';\n\t        }\n\t      }\n\t      return value;\n\t    }\n\t\n\t    // \"parse\" a mixin definition into a map of properties and values\n\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\n\t  }, {\n\t    key: '_cssTextToMap',\n\t    value: function _cssTextToMap(text) {\n\t      var props = text.split(';');\n\t      var property = void 0,\n\t          value = void 0;\n\t      var out = {};\n\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t        p = props[i];\n\t        if (p) {\n\t          sp = p.split(':');\n\t          // ignore lines that aren't definitions like @media\n\t          if (sp.length > 1) {\n\t            property = sp[0].trim();\n\t            // some properties may have ':' in the value, like data urls\n\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t            out[property] = value;\n\t          }\n\t        }\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_invalidateMixinEntry',\n\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t      for (var elementName in mixinEntry.dependants) {\n\t        if (elementName !== this._currentTemplate) {\n\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_produceCssProperties',\n\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t      var _this3 = this;\n\t\n\t      // handle case where property value is a mixin\n\t      if (valueProperty) {\n\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t          if (value && _this3._map.get(value)) {\n\t            valueMixin = '@apply ' + value + ';';\n\t          }\n\t        });\n\t      }\n\t      if (!valueMixin) {\n\t        return matchText;\n\t      }\n\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t      var combinedProps = mixinValues;\n\t      var mixinEntry = this._map.get(propertyName);\n\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t      if (oldProps) {\n\t        // NOTE: since we use mixin, the map of properties is updated here\n\t        // and this is what we want.\n\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t      } else {\n\t        this._map.set(propertyName, combinedProps);\n\t      }\n\t      var out = [];\n\t      var p = void 0,\n\t          v = void 0;\n\t      // set variables defined by current mixin\n\t      var needToInvalidate = false;\n\t      for (p in combinedProps) {\n\t        v = mixinValues[p];\n\t        // if property not defined by current mixin, set initial\n\t        if (v === undefined) {\n\t          v = 'initial';\n\t        }\n\t        if (oldProps && !(p in oldProps)) {\n\t          needToInvalidate = true;\n\t        }\n\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t      }\n\t      if (needToInvalidate) {\n\t        this._invalidateMixinEntry(mixinEntry);\n\t      }\n\t      if (mixinEntry) {\n\t        mixinEntry.properties = combinedProps;\n\t      }\n\t      // because the mixinMap is global, the mixin might conflict with\n\t      // a different scope's simple variable definition:\n\t      // Example:\n\t      // some style somewhere:\n\t      // --mixin1:{ ... }\n\t      // --mixin2: var(--mixin1);\n\t      // some other element:\n\t      // --mixin1: 10px solid red;\n\t      // --foo: var(--mixin1);\n\t      // In this case, we leave the original variable definition in place.\n\t      if (valueProperty) {\n\t        prefix = matchText + ';' + prefix;\n\t      }\n\t      return prefix + out.join('; ') + ';';\n\t    }\n\t  }]);\n\t  return ApplyShim;\n\t}();\n\t\n\tvar applyShim = new ApplyShim();\n\twindow['ApplyShim'] = applyShim;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar flush = function flush() {};\n\t\n\tif (!nativeShadow) {\n\t  (function () {\n\t    var handler = function handler(mxns) {\n\t      for (var x = 0; x < mxns.length; x++) {\n\t        var mxn = mxns[x];\n\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t          var n = mxn.addedNodes[i];\n\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t            var root = n.getRootNode();\n\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t              // may no longer be in a shadowroot\n\t              var host = root.host;\n\t              if (host) {\n\t                var scope = host.is || host.localName;\n\t                StyleTransformer.dom(n, scope);\n\t              }\n\t            }\n\t          }\n\t        }\n\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t          var _n = mxn.removedNodes[_i];\n\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t            if (classIdx >= 0) {\n\t              // NOTE: relies on the scoping class always being adjacent to the\n\t              // SCOPE_NAME class.\n\t              var _scope = _n.classList[classIdx + 1];\n\t              if (_scope) {\n\t                StyleTransformer.dom(_n, _scope, true);\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var observer = new MutationObserver(handler);\n\t    var startState = 'interactive';\n\t\n\t    var start = function start() {\n\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t    };\n\t    if (window.HTMLImports) {\n\t      window.HTMLImports.whenReady(start);\n\t    } else if (document.readyState === startState) {\n\t      requestAnimationFrame(start);\n\t    } else {\n\t      document.addEventListener('readystatechange', function () {\n\t        if (document.readyState === startState) {\n\t          start();\n\t        }\n\t      });\n\t    }\n\t\n\t    flush = function flush() {\n\t      handler(observer.takeRecords());\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(dfreedm): consider spliting into separate global\n\tvar styleCache = new StyleCache();\n\t\n\tvar ShadyCSS = {\n\t  flush: flush,\n\t  scopeCounter: {},\n\t  nativeShadow: nativeShadow,\n\t  nativeCss: nativeCssVariables,\n\t  nativeCssApply: nativeCssApply,\n\t  _documentOwner: document.documentElement,\n\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t    return name + '-' + id;\n\t  },\n\t  getStyleAst: function getStyleAst(style) {\n\t    return rulesForStyle(style);\n\t  },\n\t  styleAstToString: function styleAstToString(ast) {\n\t    return toCssText(ast);\n\t  },\n\t  _gatherStyles: function _gatherStyles(template) {\n\t    var styles = template.content.querySelectorAll('style');\n\t    var cssText = [];\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var s = styles[i];\n\t      cssText.push(s.textContent);\n\t      s.parentNode.removeChild(s);\n\t    }\n\t    return cssText.join('').trim();\n\t  },\n\t  _getCssBuild: function _getCssBuild(template) {\n\t    var style = template.content.querySelector('style');\n\t    if (!style) {\n\t      return '';\n\t    }\n\t    return style.getAttribute('css-build') || '';\n\t  },\n\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t    if (template._prepared) {\n\t      return;\n\t    }\n\t    template._prepared = true;\n\t    template.name = elementName;\n\t    template.extends = typeExtension;\n\t    templateMap[elementName] = template;\n\t    var cssBuild = this._getCssBuild(template);\n\t    var cssText = this._gatherStyles(template);\n\t    var info = {\n\t      is: elementName,\n\t      extends: typeExtension,\n\t      __cssBuild: cssBuild\n\t    };\n\t    if (!this.nativeShadow) {\n\t      StyleTransformer.dom(template.content, elementName);\n\t    }\n\t    var ast = parse(cssText);\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      applyShim.transformRules(ast, elementName);\n\t    }\n\t    template._styleAst = ast;\n\t\n\t    var ownPropertyNames = [];\n\t    if (!this.nativeCss) {\n\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t    }\n\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t      var root = this.nativeShadow ? template.content : null;\n\t      var placeholder = placeholderMap[elementName];\n\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t      template._style = style;\n\t    }\n\t    template._ownPropertyNames = ownPropertyNames;\n\t  },\n\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t    if (cssText.length) {\n\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t    }\n\t  },\n\t  _prepareHost: function _prepareHost(host) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var typeExtension = void 0;\n\t    if (is !== host.localName) {\n\t      typeExtension = host.localName;\n\t    }\n\t    var placeholder = placeholderMap[is];\n\t    var template = templateMap[is];\n\t    var ast = void 0;\n\t    var ownStylePropertyNames = void 0;\n\t    var cssBuild = void 0;\n\t    if (template) {\n\t      ast = template._styleAst;\n\t      ownStylePropertyNames = template._ownPropertyNames;\n\t      cssBuild = template._cssBuild;\n\t    }\n\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t  },\n\t  applyStyle: function applyStyle(host, overrideProps) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    if (window.CustomStyle) {\n\t      var CS = window.CustomStyle;\n\t      if (CS._documentDirty) {\n\t        CS.findStyles();\n\t        if (!this.nativeCss) {\n\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t        } else if (!this.nativeCssApply) {\n\t          CS._revalidateApplyShim();\n\t        }\n\t        CS.applyStyles();\n\t        CS._documentDirty = false;\n\t      }\n\t    }\n\t    var styleInfo = StyleInfo.get(host);\n\t    if (!styleInfo) {\n\t      styleInfo = this._prepareHost(host);\n\t    }\n\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t    if (this.nativeCss) {\n\t      var template = templateMap[is];\n\t      if (template && template.__applyShimInvalid && template._style) {\n\t        // update template\n\t        applyShim.transformRules(template._styleAst, is);\n\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        // update instance if native shadowdom\n\t        if (this.nativeShadow) {\n\t          var style = host.shadowRoot.querySelector('style');\n\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        }\n\t        styleInfo.styleRules = template._styleAst;\n\t      }\n\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t    } else {\n\t      this._updateProperties(host, styleInfo);\n\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t        // TODO: use caching\n\t        this._applyStyleProperties(host, styleInfo);\n\t      }\n\t    }\n\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t    // note: some elements may not have a root!\n\t    if (root) {\n\t      this._applyToDescendants(root);\n\t    }\n\t  },\n\t  _applyToDescendants: function _applyToDescendants(root) {\n\t    var c$ = root.children;\n\t    for (var i = 0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (c.shadowRoot) {\n\t        this.applyStyle(c);\n\t      }\n\t      this._applyToDescendants(c);\n\t    }\n\t  },\n\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t    var root = node.getRootNode();\n\t    var host = root.host;\n\t    if (host) {\n\t      if (StyleInfo.get(host)) {\n\t        return host;\n\t      } else {\n\t        return this._styleOwnerForNode(host);\n\t      }\n\t    }\n\t    return this._documentOwner;\n\t  },\n\t  _isRootOwner: function _isRootOwner(node) {\n\t    return node === this._documentOwner;\n\t  },\n\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t    // only generate new scope if cached style is not found\n\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t    if (!this.nativeShadow) {\n\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t    }\n\t    if (!cacheEntry) {\n\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t    }\n\t    return style;\n\t  },\n\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t    var owner = this._styleOwnerForNode(host);\n\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t    var props = Object.create(ownerProperties || null);\n\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t    var propertiesMatchingHost = propertyData.properties;\n\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t    StyleProperties.reify(props);\n\t    styleInfo.styleProperties = props;\n\t  },\n\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t    for (var p in overrides) {\n\t      var v = overrides[p];\n\t      // skip override props if they are not truthy or 0\n\t      // in order to fall back to inherited values\n\t      if (v || v === 0) {\n\t        props[p] = v;\n\t      }\n\t    }\n\t  },\n\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t    // remove previous properties\n\t    for (var p in properties) {\n\t      // NOTE: for bc with shim, don't apply null values.\n\t      if (p === null) {\n\t        element.style.removeProperty(p);\n\t      } else {\n\t        element.style.setProperty(p, properties[p]);\n\t      }\n\t    }\n\t  },\n\t  updateStyles: function updateStyles(properties) {\n\t    if (window.CustomStyle) {\n\t      window.CustomStyle._documentDirty = true;\n\t    }\n\t    this.applyStyle(this._documentOwner, properties);\n\t  },\n\t\n\t  /* Custom Style operations */\n\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t    var _this = this;\n\t\n\t    var ast = rulesForStyle(style);\n\t    forEachRule(ast, function (rule) {\n\t      if (nativeShadow) {\n\t        StyleTransformer.normalizeRootSelector(rule);\n\t      } else {\n\t        StyleTransformer.documentRule(rule);\n\t      }\n\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t        applyShim.transformRule(rule);\n\t      }\n\t    });\n\t    if (this.nativeCss) {\n\t      style.textContent = toCssText(ast);\n\t    } else {\n\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t    }\n\t  },\n\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      var ast = rulesForStyle(style);\n\t      applyShim.transformRules(ast);\n\t      style.textContent = toCssText(ast);\n\t    }\n\t  },\n\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t    if (!this.nativeCss) {\n\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t    }\n\t  },\n\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t    var value = void 0;\n\t    if (!this.nativeCss) {\n\t      // element is either a style host, or an ancestor of a style host\n\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t      value = styleInfo.styleProperties[property];\n\t    }\n\t    // fall back to the property value from the computed styling\n\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t    // trim whitespace that can come after the `:` in css\n\t    // example: padding: 2px -> \" 2px\"\n\t    return value.trim();\n\t  },\n\t\n\t  // given an element and a classString, replaces\n\t  // the element's class with the provided classString and adds\n\t  // any necessary ShadyCSS static and property based scoping selectors\n\t  // NOTE: this method is suitable to be called in an environment in which\n\t  // setAttribute('class', ...) and className setter have been overridden so\n\t  // it cannot rely on those methods.\n\t  setElementClass: function setElementClass(element, classString) {\n\t    var _element$classList;\n\t\n\t    // use classList to clear existing classes\n\t    while (element.classList.length) {\n\t      element.classList.remove(element.classList[0]);\n\t    }\n\t    // add user classString\n\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t    // add static scoping: scope by shadyRoot\n\t    var root = element.getRootNode();\n\t    if (root.host) {\n\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t    }\n\t    // add property scoping: scope by special selector\n\t    if (!this.nativeCss) {\n\t      var styleInfo = StyleInfo.get(element);\n\t      if (styleInfo && styleInfo.scopeSelector) {\n\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t      }\n\t    }\n\t  },\n\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t    return StyleInfo.get(node);\n\t  }\n\t};\n\t\n\twindow['ShadyCSS'] = ShadyCSS;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\n\tExample:\n\t<shady-style>\n\t  <style>\n\t  ...\n\t  </style>\n\t</shady-style>\n\t*/\n\t\n\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\n\tvar enqueued = false;\n\t\n\tvar customStyles = [];\n\t\n\tvar hookFn = null;\n\t\n\t/*\n\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\tas all the instances will boot asynchronously after page load.\n\t\n\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t*/\n\tfunction enqueueDocumentValidation() {\n\t  if (enqueued) {\n\t    return;\n\t  }\n\t  enqueued = true;\n\t  if (window.HTMLImports) {\n\t    window.HTMLImports.whenReady(validateDocument);\n\t  } else if (document.readyState === 'complete') {\n\t    requestAnimationFrame(validateDocument);\n\t  } else {\n\t    document.addEventListener('readystatechange', function () {\n\t      if (document.readyState === 'complete') {\n\t        validateDocument();\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t// helps ensure that the first run of validateDocument will actually\n\t// have access to all the custom-style's created via loading imports.\n\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t// then the enqueue immediately calls validateDocument and work that could be\n\t// batched is not.\n\tenqueueDocumentValidation();\n\t\n\tfunction validateDocument() {\n\t  if (enqueued) {\n\t    ShadyCSS$1.updateStyles();\n\t    enqueued = false;\n\t  }\n\t}\n\t\n\tfunction CustomStyle() {\n\t  /*\n\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t  CustomElement polyfill replacement that can be `.call`ed\n\t  */\n\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t  customStyles.push(self);\n\t  enqueueDocumentValidation();\n\t  return self;\n\t}\n\t\n\tObject.defineProperties(CustomStyle, {\n\t  /*\n\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t   The function must take a <style> element as input, and return nothing.\n\t  */\n\t  processHook: {\n\t    get: function get() {\n\t      return hookFn;\n\t    },\n\t    set: function set(fn) {\n\t      hookFn = fn;\n\t      return fn;\n\t    }\n\t  },\n\t  _customStyles: {\n\t    get: function get() {\n\t      return customStyles;\n\t    }\n\t  },\n\t  _documentDirty: {\n\t    get: function get() {\n\t      return enqueued;\n\t    },\n\t    set: function set(value) {\n\t      enqueued = value;\n\t      return value;\n\t    }\n\t  }\n\t});\n\t\n\tCustomStyle.findStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._findStyle();\n\t  }\n\t};\n\t\n\tCustomStyle._revalidateApplyShim = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    var s = customStyles[i];\n\t    if (s._style) {\n\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t    }\n\t  }\n\t};\n\t\n\tCustomStyle.applyStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._applyStyle();\n\t  }\n\t};\n\t\n\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t  'constructor': {\n\t    value: CustomStyle,\n\t    configurable: true,\n\t    writable: true\n\t  }\n\t});\n\t\n\tCustomStyle.prototype._findStyle = function () {\n\t  if (!this._style) {\n\t    var style = this.querySelector('style');\n\t    if (!style) {\n\t      return;\n\t    }\n\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t    // which is referenced with __appliedElement.\n\t    // Also, we must copy over the attributes.\n\t    if (style.__appliedElement) {\n\t      for (var i = 0; i < style.attributes.length; i++) {\n\t        var attr = style.attributes[i];\n\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t      }\n\t    }\n\t    this._style = style.__appliedElement || style;\n\t    if (hookFn) {\n\t      hookFn(this._style);\n\t    }\n\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t  }\n\t};\n\t\n\tCustomStyle.prototype._applyStyle = function () {\n\t  if (this._style) {\n\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t  }\n\t};\n\t\n\twindow.customElements.define('custom-style', CustomStyle);\n\twindow['CustomStyle'] = CustomStyle;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/*\n\tSmall module to load ShadyCSS and CustomStyle together\n\t*/\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadycss.min.js.map\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs-web-components/dist/index.js\n// module id = 1\n// module chunks = 0 1","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('incremental-dom'), require('window-or-global')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n}(this, (function (exports,incrementalDom,root) {\n\nroot = 'default' in root ? root['default'] : root;\n\nfunction keys() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref$enumOnly = _ref.enumOnly;\n  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\n  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n}\n\n// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\nvar assign = (function (obj) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  args.forEach(function (arg) {\n    return keys(arg).forEach(function (name) {\n      return obj[name] = arg[name];\n    });\n  }); // eslint-disable-line no-return-assign\n  return obj;\n});\n\nvar empty = function (val) {\n  return typeof val === 'undefined' || val === null;\n};\n\nvar alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {\n  return isNaN(val) ? undefined : Number(val);\n};\nvar alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n  return empty(val) ? undefined : String(val);\n};\n\nfunction create(def) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.unshift({}, def);\n    return assign.apply(undefined, args);\n  };\n}\n\nvar array = create({\n  coerce: function coerce(val) {\n    return Array.isArray(val) ? val : [val];\n  },\n  default: function _default() {\n    return [];\n  },\n  deserialize: JSON.parse,\n  serialize: JSON.stringify\n});\n\nvar boolean = create({\n  coerce: function coerce(value) {\n    return !!value;\n  },\n  default: false,\n  deserialize: function deserialize(value) {\n    return !(value === null);\n  },\n  serialize: function serialize(value) {\n    return value ? '' : undefined;\n  }\n});\n\nvar number = create({\n  default: 0,\n  coerce: alwaysUndefinedIfNotANumberOrNumber,\n  deserialize: alwaysUndefinedIfNotANumberOrNumber,\n  serialize: alwaysUndefinedIfNotANumberOrNumber\n});\n\nvar string = create({\n  default: '',\n  coerce: alwaysUndefinedIfEmptyOrString,\n  deserialize: alwaysUndefinedIfEmptyOrString,\n  serialize: alwaysUndefinedIfEmptyOrString\n});\n\nvar prop = Object.freeze({\n\tcreate: create,\n\tarray: array,\n\tboolean: boolean,\n\tnumber: number,\n\tstring: string\n});\n\nvar connected = '____skate_connected';\nvar created$1 = '____skate_created';\n\n// DEPRECATED\n//\n// This is the only \"symbol\" that must stay a string. This is because it is\n// relied upon across several versions. We should remove it, but ensure that\n// it's considered a breaking change that whatever version removes it cannot\n// be passed to vdom functions as tag names.\nvar name = '____skate_name';\n\n// Used on the Constructor\nvar ctorCreateInitProps = '____skate_ctor_createInitProps';\nvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\nvar ctorProps = '____skate_ctor_props';\nvar ctorPropsMap = '____skate_ctor_propsMap';\n\n// Used on the Element\nvar props = '____skate_props';\nvar ref$1 = '____skate_ref';\nvar renderer$1 = '____skate_renderer';\nvar rendering = '____skate_rendering';\nvar rendererDebounced = '____skate_rendererDebounced';\nvar updated$1 = '____skate_updated';\n\n// DEPRECTAED\n//\n// We should not be relying on internals for symbols as this creates version\n// coupling. We will move forward with platform agnostic ways of doing this.\n\n\nvar symbols$1 = Object.freeze({\n\tname: name\n});\n\nfunction enter(object, props) {\n  var saved = {};\n  Object.keys(props).forEach(function (key) {\n    saved[key] = object[key];\n    object[key] = props[key];\n  });\n  return saved;\n}\n\nfunction exit(object, saved) {\n  assign(object, saved);\n}\n\n// Decorates a function with a side effect that changes the properties of an\n// object during its execution, and restores them after. There is no error\n// handling here, if the wrapped function throws an error, properties are not\n// restored and all bets are off.\nvar propContext = function (object, props) {\n  return function (func) {\n    return function () {\n      var saved = enter(object, props);\n      var result = func.apply(undefined, arguments);\n      exit(object, saved);\n      return result;\n    };\n  };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/* eslint no-plusplus: 0 */\n\nvar customElements = root.customElements;\nvar HTMLElement = root.HTMLElement;\n\nvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\n// A stack of children that corresponds to the current function helper being\n// executed.\nvar stackChren = [];\n\nvar $skip = '__skip';\nvar $currentEventHandlers = '__events';\nvar $stackCurrentHelperProps = '__props';\n\n// The current function helper in the stack.\nvar stackCurrentHelper = void 0;\n\n// This is used for the Incremental DOM overrides to keep track of what args\n// to pass the main elementOpen() function.\nvar overrideArgs = void 0;\n\n// The number of levels deep after skipping a tree.\nvar skips = 0;\n\nvar noop = function noop() {};\n\n// Adds or removes an event listener for an element.\nfunction applyEvent(elem, ename, newFunc) {\n  var events = elem[$currentEventHandlers];\n\n  if (!events) {\n    events = elem[$currentEventHandlers] = {};\n  }\n\n  // Undefined indicates that there is no listener yet.\n  if (typeof events[ename] === 'undefined') {\n    // We only add a single listener once. Originally this was a workaround for\n    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n    // also a simpler model for binding / unbinding events because you only\n    // have a single handler you need to worry about and a single place where\n    // you only store one event handler\n    elem.addEventListener(ename, function (e) {\n      if (events[ename]) {\n        events[ename].call(this, e);\n      }\n    });\n  }\n\n  // Not undefined indicates that we have set a listener, so default to null.\n  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n}\n\nvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n  // Attributes that shouldn't be applied to the DOM.\n  key: noop,\n  statics: noop,\n\n  // Attributes that *must* be set via a property on all elements.\n  checked: incrementalDom.applyProp,\n  className: incrementalDom.applyProp,\n  disabled: incrementalDom.applyProp,\n  value: incrementalDom.applyProp,\n\n  // Ref handler.\n  ref: function ref(elem, name$$1, value) {\n    elem[ref$1] = value;\n  },\n\n\n  // Skip handler.\n  skip: function skip(elem, name$$1, value) {\n    if (value) {\n      elem[$skip] = true;\n    } else {\n      delete elem[$skip];\n    }\n  }\n}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n  var _ref = customElements.get(elem.localName) || {\n    props: {},\n    prototype: {}\n  };\n\n  var props$$1 = _ref.props;\n  var prototype = _ref.prototype;\n\n  // TODO when refactoring properties to not have to workaround the old\n  // WebKit bug we can remove the \"name in props\" check below.\n  //\n  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n  // elements that set a property that isn't explicitly specified in \"props\"\n  // or \"prototype\" unless it is added to the element explicitly as a\n  // property prior to passing the prop to the vdom function. For example, if\n  // it were added in a lifecycle callback because it wouldn't have been\n  // upgraded yet.\n  //\n  // We prefer setting props, so we do this if there's a property matching\n  // name that was passed. However, certain props on SVG elements are\n  // readonly and error when you try to set them.\n\n  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n    incrementalDom.applyProp(elem, name$$1, value);\n    return;\n  }\n\n  // Explicit false removes the attribute.\n  if (value === false) {\n    applyDefault(elem, name$$1);\n    return;\n  }\n\n  // Handle built-in and custom events.\n  if (name$$1.indexOf('on') === 0) {\n    var firstChar = name$$1[2];\n    var eventName = void 0;\n\n    if (firstChar === '-') {\n      eventName = name$$1.substring(3);\n    } else if (firstChar === firstChar.toUpperCase()) {\n      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n    }\n\n    if (eventName) {\n      applyEvent(elem, eventName, value);\n      return;\n    }\n  }\n\n  applyDefault(elem, name$$1, value);\n}));\n\nfunction resolveTagName(name$$1) {\n  // We return falsy values as some wrapped IDOM functions allow empty values.\n  if (!name$$1) {\n    return name$$1;\n  }\n\n  // We try and return the cached tag name, if one exists.\n  if (name$$1[name]) {\n    return name$$1[name];\n  }\n\n  // If it's a custom element, we get the tag name by constructing it and\n  // caching it.\n  if (name$$1.prototype instanceof HTMLElement) {\n    // eslint-disable-next-line\n    var elem = new name$$1();\n    return name$$1[name] = elem.localName;\n  }\n\n  // Pass all other values through so IDOM gets what it's expecting.\n  return name$$1;\n}\n\n// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n// so it's the only function we need to execute in the context of our attributes.\nvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\nfunction elementOpenStart(tag) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  overrideArgs = [tag, key, statics];\n}\n\nfunction elementOpenEnd() {\n  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n  overrideArgs = null;\n  return node;\n}\n\nfunction wrapIdomFunc(func) {\n  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n  return function wrap() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args[0] = resolveTagName(args[0]);\n    stackCurrentHelper = null;\n    if (typeof args[0] === 'function') {\n      // If we've encountered a function, handle it according to the type of\n      // function that is being wrapped.\n      stackCurrentHelper = args[0];\n      return tnameFuncHandler.apply(undefined, args);\n    } else if (stackChren.length) {\n      // We pass the wrap() function in here so that when it's called as\n      // children, it will queue up for the next stack, if there is one.\n      stackChren[stackChren.length - 1].push([wrap, args]);\n    } else {\n      if (func === elementOpen$1) {\n        if (skips) {\n          return ++skips;\n        }\n\n        var elem = func.apply(undefined, args);\n\n        if (elem[$skip]) {\n          ++skips;\n        }\n\n        return elem;\n      }\n\n      if (func === incrementalDom.elementClose) {\n        if (skips === 1) {\n          incrementalDom.skip();\n        }\n\n        // We only want to skip closing if it's not the last closing tag in the\n        // skipped tree because we keep the element that initiated the skpping.\n        if (skips && --skips) {\n          return;\n        }\n\n        var _elem = func.apply(undefined, args);\n        var ref$$1 = _elem[ref$1];\n\n        // We delete so that it isn't called again for the same element. If the\n        // ref changes, or the element changes, this will be defined again.\n        delete _elem[ref$1];\n\n        // Execute the saved ref after esuring we've cleand up after it.\n        if (typeof ref$$1 === 'function') {\n          ref$$1(_elem);\n        }\n\n        return _elem;\n      }\n\n      // We must call elementOpenStart and elementOpenEnd even if we are\n      // skipping because they queue up attributes and then call elementClose.\n      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n        return func.apply(undefined, args);\n      }\n    }\n  };\n}\n\nfunction newAttr() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (stackCurrentHelper) {\n    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n  } else if (stackChren.length) {\n    stackChren[stackChren.length - 1].push([newAttr, args]);\n  } else {\n    overrideArgs.push(args[0]);\n    overrideArgs.push(args[1]);\n  }\n}\n\nfunction stackOpen(tname, key, statics) {\n  var props$$1 = { key: key, statics: statics };\n\n  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n    attrs[_key3 - 3] = arguments[_key3];\n  }\n\n  for (var a = 0; a < attrs.length; a += 2) {\n    props$$1[attrs[a]] = attrs[a + 1];\n  }\n  tname[$stackCurrentHelperProps] = props$$1;\n  stackChren.push([]);\n}\n\nfunction stackClose(tname) {\n  var chren = stackChren.pop();\n  var props$$1 = tname[$stackCurrentHelperProps];\n  delete tname[$stackCurrentHelperProps];\n  var elemOrFn = tname(props$$1, function () {\n    return chren.forEach(function (args) {\n      return args[0].apply(args, toConsumableArray(args[1]));\n    });\n  });\n  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n}\n\n// Incremental DOM overrides\n// -------------------------\n\n// We must override internal functions that call internal Incremental DOM\n// functions because we can't override the internal references. This means\n// we must roughly re-implement their behaviour. Luckily, they're fairly\n// simple.\nvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\nvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\n// Standard open / closed overrides don't need to reproduce internal behaviour\n// because they are the ones referenced from *End and *Start.\nvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\nvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\n// Ensure we call our overridden functions instead of the internal ones.\nfunction newElementVoid(tag) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  newElementOpen.apply(undefined, [tag].concat(args));\n  return newElementClose(tag);\n}\n\n// Text override ensures their calls can queue if using function helpers.\nvar newText = wrapIdomFunc(incrementalDom.text);\n\n// Convenience function for declaring an Incremental DOM element using\n// hyperscript-style syntax.\nfunction element(tname, attrs) {\n  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\n  // If attributes are a function, then they should be treated as children.\n\n  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n    chren[_key5 - 2] = arguments[_key5];\n  }\n\n  if (atype === 'function' || atype === 'string' || atype === 'number') {\n    chren.unshift(attrs);\n  }\n\n  // Ensure the attributes are an object. Null is considered an object so we\n  // have to test for this explicitly.\n  if (attrs === null || atype !== 'object') {\n    attrs = {};\n  }\n\n  // We open the element so we can set attrs after.\n  newElementOpenStart(tname, attrs.key, attrs.statics);\n\n  // Delete so special attrs don't actually get set.\n  delete attrs.key;\n  delete attrs.statics;\n\n  // Set attributes.\n  Object.keys(attrs).forEach(function (name$$1) {\n    return newAttr(name$$1, attrs[name$$1]);\n  });\n\n  // Close before we render the descendant tree.\n  newElementOpenEnd(tname);\n\n  chren.forEach(function (ch) {\n    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n    if (ctype === 'function') {\n      ch();\n    } else if (ctype === 'string' || ctype === 'number') {\n      newText(ch);\n    } else if (Array.isArray(ch)) {\n      ch.forEach(function (sch) {\n        return sch();\n      });\n    }\n  });\n\n  return newElementClose(tname);\n}\n\n// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n// transpiles for JSX (React.createElement() / h).\nfunction builder() {\n  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    tags[_key6] = arguments[_key6];\n  }\n\n  if (tags.length === 0) {\n    return function () {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return element.bind.apply(element, [null].concat(args));\n    };\n  }\n  return tags.map(function (tag) {\n    return function () {\n      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      return element.bind.apply(element, [null, tag].concat(args));\n    };\n  });\n}\n\n\n\nvar vdom = Object.freeze({\n\telement: element,\n\tbuilder: builder,\n\tattr: newAttr,\n\telementClose: newElementClose,\n\telementOpen: newElementOpen,\n\telementOpenEnd: newElementOpenEnd,\n\telementOpenStart: newElementOpenStart,\n\telementVoid: newElementVoid,\n\ttext: newText\n});\n\nfunction createSymbol(description) {\n  return typeof Symbol === 'function' ? Symbol(description) : description;\n}\n\nvar data = function (element) {\n  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n};\n\nvar dashCase = function (str) {\n  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    return '' + one + dash + two.toLowerCase();\n  });\n};\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\nvar native = (function (fn) {\n  return nativeHints.map(function (hint) {\n    return (fn || '').toString().indexOf([hint]) > -1;\n  }).reduce(function (a, b) {\n    return a || b;\n  });\n});\n\nvar MutationObserver = root.MutationObserver;\n\n\nfunction microtaskDebounce(cbFunc) {\n  var scheduled = false;\n  var i = 0;\n  var cbArgs = [];\n  var elem = document.createElement('span');\n  var observer = new MutationObserver(function () {\n    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n    scheduled = false;\n    cbArgs = null;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = '' + i;\n      i += 1;\n    }\n  };\n}\n\n// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n// polyfill requires that the element be in the document to trigger Mutation\n// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n//\n// The soonest we can set the timeout for in IE is 1 as they have issues when\n// setting to 0.\nfunction taskDebounce(cbFunc) {\n  var scheduled = false;\n  var cbArgs = [];\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n      }, 1);\n    }\n  };\n}\nvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\nvar getOwnPropertyDescriptors = function () {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return keys(obj).reduce(function (prev, curr) {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n};\n\n/**\n * This is needed to avoid IE11 \"stack size errors\" when creating\n * a new property on the constructor of an HTMLElement\n */\nfunction setCtorNativeProperty(Ctor, propName, value) {\n  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n}\n\n/**\n * Returns a cached map of property options for the given component class.\n * Keys in the map are the properties name which can a string or a symbol.\n *\n * The map is created by caching the result of: static get props\n */\nfunction getPropsMap(Ctor) {\n  // Must be defined on constructor and not from a superclass\n  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n    (function () {\n      var props$$1 = Ctor.props || {};\n\n      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n        result[propNameOrSymbol] = props$$1[propNameOrSymbol];\n        return result;\n      }, {});\n      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n    })();\n  }\n\n  return Ctor[ctorPropsMap];\n}\n\nfunction get$2(elem) {\n  var props$$1 = {};\n  keys(getPropsMap(elem.constructor)).forEach(function (key) {\n    props$$1[key] = elem[key];\n  });\n\n  return props$$1;\n}\n\nfunction set$2(elem, newProps) {\n  assign(elem, newProps);\n  if (elem[renderer$1]) {\n    elem[renderer$1]();\n  }\n}\n\nvar props$1 = function (elem, newProps) {\n  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n};\n\nfunction getDefaultValue(elem, name, opts) {\n  return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n}\n\nfunction getInitialValue(elem, name, opts) {\n  return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n}\n\nfunction getPropData(elem, name) {\n  var elemData = data(elem, 'props');\n  return elemData[name] || (elemData[name] = {});\n}\n\nfunction syncFirstTimeProp(elem, prop, propName, attributeName, propData) {\n  var syncAttrValue = propData.lastAssignedValue;\n  if (empty(syncAttrValue)) {\n    if ('initial' in prop) {\n      syncAttrValue = getInitialValue(elem, propName, prop);\n    } else if ('default' in prop) {\n      syncAttrValue = getDefaultValue(elem, propName, prop);\n    }\n  }\n  if (!empty(syncAttrValue) && prop.serialize) {\n    syncAttrValue = prop.serialize(syncAttrValue);\n  }\n  if (!empty(syncAttrValue)) {\n    propData.syncingAttribute = true;\n    elem.setAttribute(attributeName, syncAttrValue);\n  }\n}\n\nfunction syncExistingProp(elem, prop, propName, attributeName, propData) {\n  if (attributeName && !propData.settingAttribute) {\n    var internalValue = propData.internalValue;\n\n    var serializedValue = prop.serialize(internalValue);\n    var currentAttrValue = elem.getAttribute(attributeName);\n    var serializedIsEmpty = empty(serializedValue);\n    var attributeChanged = !(serializedIsEmpty && empty(currentAttrValue) || serializedValue === currentAttrValue);\n\n    propData.syncingAttribute = true;\n\n    var shouldRemoveAttribute = empty(propData.lastAssignedValue);\n    if (shouldRemoveAttribute || serializedIsEmpty) {\n      elem.removeAttribute(attributeName);\n    } else {\n      elem.setAttribute(attributeName, serializedValue);\n    }\n\n    if (!attributeChanged && propData.syncingAttribute) {\n      propData.syncingAttribute = false;\n    }\n  }\n\n  // Allow the attribute to be linked again.\n  propData.settingAttribute = false;\n}\n\nfunction syncPropToAttr(elem, prop, propName, isFirstSync) {\n  var attributeName = data(elem, 'propertyLinks')[propName];\n  var propData = getPropData(elem, propName);\n\n  if (attributeName) {\n    if (isFirstSync) {\n      syncFirstTimeProp(elem, prop, propName, attributeName, propData);\n    } else {\n      syncExistingProp(elem, prop, propName, attributeName, propData);\n    }\n  }\n}\n\nfunction createNativePropertyDefinition(name$$1, opts) {\n  var prop = {\n    configurable: true,\n    enumerable: true\n  };\n\n  prop.created = function created(elem) {\n    var propData = getPropData(elem, name$$1);\n    var attributeName = opts.attribute === true ? dashCase(name$$1) : opts.attribute;\n    var initialValue = elem[name$$1];\n\n    // Store property to attribute link information.\n    data(elem, 'attributeLinks')[attributeName] = name$$1;\n    data(elem, 'propertyLinks')[name$$1] = attributeName;\n\n    // Set up initial value if it wasn't specified.\n    if (empty(initialValue)) {\n      if (attributeName && elem.hasAttribute(attributeName)) {\n        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n      } else if ('initial' in opts) {\n        initialValue = getInitialValue(elem, name$$1, opts);\n      } else if ('default' in opts) {\n        initialValue = getDefaultValue(elem, name$$1, opts);\n      }\n    }\n\n    propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n  };\n\n  prop.get = function get() {\n    var propData = getPropData(this, name$$1);\n    var internalValue = propData.internalValue;\n\n    return typeof opts.get === 'function' ? opts.get(this, { name: name$$1, internalValue: internalValue }) : internalValue;\n  };\n\n  prop.set = function set(newValue) {\n    var propData = getPropData(this, name$$1);\n    propData.lastAssignedValue = newValue;\n    var oldValue = propData.oldValue;\n\n\n    if (empty(oldValue)) {\n      oldValue = null;\n    }\n\n    if (empty(newValue)) {\n      newValue = getDefaultValue(this, name$$1, opts);\n    }\n\n    if (typeof opts.coerce === 'function') {\n      newValue = opts.coerce(newValue);\n    }\n\n    var changeData = { name: name$$1, newValue: newValue, oldValue: oldValue };\n\n    if (typeof opts.set === 'function') {\n      opts.set(this, changeData);\n    }\n\n    // Queue a re-render.\n    this[rendererDebounced](this);\n\n    // Update prop data so we can use it next time.\n    propData.internalValue = propData.oldValue = newValue;\n\n    // Link up the attribute.\n    if (this[connected]) {\n      syncPropToAttr(this, opts, name$$1, false);\n    }\n  };\n\n  return prop;\n}\n\nvar initProps = function (opts) {\n  opts = opts || {};\n\n  if (typeof opts === 'function') {\n    opts = { coerce: opts };\n  }\n\n  return function (name$$1) {\n    return createNativePropertyDefinition(name$$1, assign({\n      default: null,\n      deserialize: function deserialize(value) {\n        return value;\n      },\n      serialize: function serialize(value) {\n        return value;\n      }\n    }, opts));\n  };\n};\n\nvar HTMLElement$1 = root.HTMLElement || function () {\n  function _class() {\n    classCallCheck(this, _class);\n  }\n\n  return _class;\n}();\nvar _prevName = createSymbol('prevName');\nvar _prevOldValue = createSymbol('prevOldValue');\nvar _prevNewValue = createSymbol('prevNewValue');\n\nfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n}\n\nfunction syncPropsToAttrs(elem) {\n  var props$$1 = getPropsMap(elem.constructor);\n  Object.keys(props$$1).forEach(function (propName) {\n    var prop = props$$1[propName];\n    syncPropToAttr(elem, prop, propName, true);\n  });\n}\n\n// TODO remove when not catering to Safari < 10.\n//\n// Ensures that definitions passed as part of the constructor are functions\n// that return property definitions used on the element.\nfunction ensurePropertyFunctions(Ctor) {\n  var props$$1 = getPropsMap(Ctor);\n  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = props$$1[descriptorName];\n    if (typeof descriptors[descriptorName] !== 'function') {\n      descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n    }\n    return descriptors;\n  }, {});\n}\n\n// TODO remove when not catering to Safari < 10.\n//\n// This can probably be simplified into createInitProps().\nfunction ensurePropertyDefinitions(Ctor) {\n  var props$$1 = ensurePropertyFunctions(Ctor);\n  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = props$$1[descriptorName](descriptorName);\n    return descriptors;\n  }, {});\n}\n\n// TODO refactor when not catering to Safari < 10.\n//\n// We should be able to simplify this where all we do is Object.defineProperty().\nfunction createInitProps(Ctor) {\n  var props$$1 = ensurePropertyDefinitions(Ctor);\n\n  return function (elem) {\n    if (!props$$1) {\n      return;\n    }\n\n    keys(props$$1).forEach(function (name$$1) {\n      var prop = props$$1[name$$1];\n      prop.created(elem);\n\n      // We check here before defining to see if the prop was specified prior\n      // to upgrading.\n      var hasPropBeforeUpgrading = name$$1 in elem;\n\n      // This is saved prior to defining so that we can set it after it it was\n      // defined prior to upgrading. We don't want to invoke the getter if we\n      // don't need to, so we only get the value if we need to re-sync.\n      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      //\n      // When Webkit fixes that bug so that native property accessors can be\n      // retrieved, we can move defining the property to the prototype and away\n      // from having to do if for every instance as all other browsers support\n      // this.\n      Object.defineProperty(elem, name$$1, prop);\n\n      // DEPRECATED\n      //\n      // We'll be removing get / set callbacks on properties. Use the\n      // updatedCallback() instead.\n      //\n      // We re-set the prop if it was specified prior to upgrading because we\n      // need to ensure set() is triggered both in polyfilled environments and\n      // in native where the definition may be registerd after elements it\n      // represents have already been created.\n      if (hasPropBeforeUpgrading) {\n        elem[name$$1] = valueBeforeUpgrading;\n      }\n    });\n  };\n}\n\nvar _class2 = function (_HTMLElement) {\n  inherits(_class2, _HTMLElement);\n  createClass(_class2, null, [{\n    key: 'observedAttributes',\n\n\n    /**\n     * Returns unique attribute names configured with props and\n     * those set on the Component constructor if any\n     */\n    get: function get() {\n      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n\n      var props$$1 = getPropsMap(this);\n      var attrsFromLinkedProps = Object.keys(props$$1).map(function (key) {\n        var attribute = props$$1[key].attribute;\n\n        return attribute === true ? dashCase(key) : attribute;\n      }).filter(Boolean);\n\n      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n\n      return all.filter(function (item, index) {\n        return all.indexOf(item) === index;\n      });\n    },\n    set: function set(value) {\n      value = Array.isArray(value) ? value : [];\n      setCtorNativeProperty(this, 'observedAttributes', value);\n    }\n\n    // Returns superclass props overwritten with this Component props\n\n  }, {\n    key: 'props',\n    get: function get() {\n      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n    },\n    set: function set(value) {\n      setCtorNativeProperty(this, ctorProps, value);\n    }\n  }]);\n\n  function _class2() {\n    classCallCheck(this, _class2);\n\n    var _this = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this));\n\n    var constructor = _this.constructor;\n\n    // Used for the ready() function so it knows when it can call its callback.\n\n    _this[created$1] = true;\n\n    // TODO refactor to not cater to Safari < 10. This means we can depend on\n    // built-in property descriptors.\n    // Must be defined on constructor and not from a superclass\n    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n    }\n\n    // Set up a renderer that is debounced for property sets to call directly.\n    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\n    // Set up property lifecycle.\n    var propConfigsCount = keys(getPropsMap(constructor)).length;\n    if (propConfigsCount && constructor[ctorCreateInitProps]) {\n      constructor[ctorCreateInitProps](_this);\n    }\n\n    // DEPRECATED\n    //\n    // static render()\n    if (!_this.renderCallback && constructor.render) {\n      _this.renderCallback = constructor.render.bind(constructor, _this);\n    }\n\n    // DEPRECATED\n    //\n    // static created()\n    //\n    // Props should be set up before calling this.\n    if (typeof constructor.created === 'function') {\n      constructor.created(_this);\n    }\n\n    // DEPRECATED\n    //\n    // Feature has rarely been used.\n    //\n    // Created should be set before invoking the ready listeners.\n    var elemData = data(_this);\n    var readyCallbacks = elemData.readyCallbacks;\n    if (readyCallbacks) {\n      readyCallbacks.forEach(function (cb) {\n        return cb(_this);\n      });\n      delete elemData.readyCallbacks;\n    }\n    return _this;\n  }\n\n  // Custom Elements v1\n\n\n  createClass(_class2, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var constructor = this.constructor;\n\n      // DEPRECATED\n      //\n      // No more reflecting back to attributes in favour of one-way reflection.\n\n      syncPropsToAttrs(this);\n\n      // Used to check whether or not the component can render.\n      this[connected] = true;\n\n      // Render!\n      this[rendererDebounced]();\n\n      // DEPRECATED\n      //\n      // static attached()\n      if (typeof constructor.attached === 'function') {\n        constructor.attached(this);\n      }\n\n      // DEPRECATED\n      //\n      // We can remove this once all browsers support :defined.\n      this.setAttribute('defined', '');\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      var constructor = this.constructor;\n\n      // Ensures the component can't be rendered while disconnected.\n\n      this[connected] = false;\n\n      // DEPRECATED\n      //\n      // static detached()\n      if (typeof constructor.detached === 'function') {\n        constructor.detached(this);\n      }\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n      // Polyfill calls this twice.\n      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n        return;\n      }\n\n      // Set data so we can prevent double calling if the polyfill.\n      this[_prevName] = name$$1;\n      this[_prevOldValue] = oldValue;\n      this[_prevNewValue] = newValue;\n\n      var attributeChanged = this.constructor.attributeChanged;\n\n      var propertyName = data(this, 'attributeLinks')[name$$1];\n\n      if (propertyName) {\n        var propData = data(this, 'props')[propertyName];\n\n        // This ensures a property set doesn't cause the attribute changed\n        // handler to run again once we set this flag. This only ever has a\n        // chance to run when you set an attribute, it then sets a property and\n        // then that causes the attribute to be set again.\n        if (propData.syncingAttribute) {\n          propData.syncingAttribute = false;\n        } else {\n          // Sync up the property.\n          var propOpts = getPropsMap(this.constructor)[propertyName];\n          propData.settingAttribute = true;\n          var newPropVal = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n          this[propertyName] = newPropVal;\n        }\n      }\n\n      if (attributeChanged) {\n        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n      }\n    }\n\n    // Skate\n    //\n    // Maps to the static updated() callback. That logic should be moved here\n    // when that is finally removed.\n\n  }, {\n    key: 'updatedCallback',\n    value: function updatedCallback(prev) {\n      return this.constructor.updated(this, prev);\n    }\n\n    // Skate\n    //\n    // Maps to the static rendered() callback. That logic should be moved here\n    // when that is finally removed.\n\n  }, {\n    key: 'renderedCallback',\n    value: function renderedCallback() {\n      return this.constructor.rendered(this);\n    }\n\n    // Skate\n    //\n    // Maps to the static renderer() callback. That logic should be moved here\n    // when that is finally removed.\n\n  }, {\n    key: 'rendererCallback',\n    value: function rendererCallback() {\n      return this.constructor.renderer(this);\n    }\n\n    // Skate\n    //\n    // Invokes the complete render lifecycle.\n\n  }, {\n    key: renderer$1,\n    value: function value() {\n      if (this[rendering] || !this[connected]) {\n        return;\n      }\n\n      // Flag as rendering. This prevents anything from trying to render - or\n      // queueing a render - while there is a pending render.\n      this[rendering] = true;\n\n      if (this[updated$1]() && typeof this.renderCallback === 'function') {\n        this.rendererCallback();\n        this.renderedCallback();\n      }\n\n      this[rendering] = false;\n    }\n\n    // Skate\n    //\n    // Calls the user-defined updated() lifecycle callback.\n\n  }, {\n    key: updated$1,\n    value: function value() {\n      var prev = this[props];\n      this[props] = props$1(this);\n      return this.updatedCallback(prev);\n    }\n\n    // Skate\n\n  }], [{\n    key: 'extend',\n    value: function extend() {\n      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n      // Create class for the user.\n      var Ctor = function (_Base) {\n        inherits(Ctor, _Base);\n\n        function Ctor() {\n          classCallCheck(this, Ctor);\n          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n        }\n\n        return Ctor;\n      }(Base);\n\n      // For inheriting from the object literal.\n\n\n      var opts = getOwnPropertyDescriptors(definition);\n      var prot = getOwnPropertyDescriptors(definition.prototype);\n\n      // Prototype is non configurable (but is writable).\n      delete opts.prototype;\n\n      // Pass on static and instance members from the definition.\n      Object.defineProperties(Ctor, opts);\n      Object.defineProperties(Ctor.prototype, prot);\n\n      return Ctor;\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'updated',\n    value: function updated(elem, prev) {\n      if (!prev) {\n        return true;\n      }\n\n      // use get all keys so that we check Symbols as well as regular props\n      // using a for loop so we can break early\n      var allKeys = keys(prev);\n      for (var i = 0; i < allKeys.length; i += 1) {\n        if (prev[allKeys[i]] !== elem[allKeys[i]]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'rendered',\n    value: function rendered() {}\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'renderer',\n    value: function renderer(elem) {\n      if (!elem.shadowRoot) {\n        elem.attachShadow({ mode: 'open' });\n      }\n      incrementalDom.patchInner(elem.shadowRoot, function () {\n        var possibleFn = elem.renderCallback();\n        if (typeof possibleFn === 'function') {\n          possibleFn();\n        } else if (Array.isArray(possibleFn)) {\n          possibleFn.forEach(function (fn) {\n            if (typeof fn === 'function') {\n              fn();\n            }\n          });\n        }\n      });\n    }\n  }]);\n  return _class2;\n}(HTMLElement$1);\n\nfunction uniqueId(prefix) {\n  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    // eslint-disable-next-line no-mixed-operators\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n  return (prefix || 'x') + '-' + rand;\n}\n\nvar define = function () {\n  var customElements = root.customElements;\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var name$$1 = args[0];\n  var Ctor = args[1];\n\n\n  if (!customElements) {\n    throw new Error('Skate requires native custom element support or a polyfill.');\n  }\n\n  // Support passing an anonymous definition.\n  if (args.length === 1) {\n    // We are checking string for now, but once we remove the ability to pass\n    // an object literal, we can change this to check \"function\" and invert the\n    // blocks of logic.\n    if (typeof name$$1 === 'string') {\n      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n    } else {\n      Ctor = name$$1;\n      name$$1 = uniqueId();\n    }\n  }\n\n  // Ensure there's no conflicts.\n  if (customElements.get(name$$1)) {\n    name$$1 = uniqueId(name$$1);\n  }\n\n  // DEPRECATED\n  //\n  // Object literals.\n  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n    Ctor = _class2.extend(Ctor);\n  }\n\n  // This allows us to check this before instantiating the custom element to\n  // find its name from the constructor in the vdom module, thus improving\n  // performance but still falling back to a robust method.\n  Ctor[name] = name$$1;\n\n  // Sipmle define. Not supporting customised built-ins yet.\n  customElements.define(name$$1, Ctor);\n\n  // The spec doesn't return but this allows for a simpler, more concise API.\n  return Ctor;\n};\n\nvar Event = function (TheEvent) {\n  if (TheEvent) {\n    try {\n      new TheEvent('emit-init'); // eslint-disable-line no-new\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return TheEvent;\n}(root.Event);\n\nfunction createCustomEvent(name) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var detail = opts.detail;\n\n  delete opts.detail;\n\n  var e = void 0;\n  if (Event) {\n    e = new Event(name, opts);\n    Object.defineProperty(e, 'detail', { value: detail });\n  } else {\n    e = document.createEvent('CustomEvent');\n    Object.defineProperty(e, 'composed', { value: opts.composed });\n    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n  }\n  return e;\n}\n\nvar emit = function (elem, name) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (opts.bubbles === undefined) {\n    opts.bubbles = true;\n  }\n  if (opts.cancelable === undefined) {\n    opts.cancelable = true;\n  }\n  if (opts.composed === undefined) {\n    opts.composed = true;\n  }\n  return elem.dispatchEvent(createCustomEvent(name, opts));\n};\n\nfunction getValue(elem) {\n  var type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nvar link = function (elem, target) {\n  return function (e) {\n    var value = getValue(e.target);\n    var localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      var parts = localTarget.split('.');\n      var firstPart = parts[0];\n      var propName = parts.pop();\n      var obj = parts.reduce(function (prev, curr) {\n        return prev && prev[curr];\n      }, elem);\n\n      obj[propName || e.target.name] = value;\n      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n    } else {\n      props$1(elem, defineProperty({}, localTarget, value));\n    }\n  };\n};\n\nvar ready = function (elem, done) {\n  var info = data(elem);\n  if (elem[created$1]) {\n    done(elem);\n  } else if (info.readyCallbacks) {\n    info.readyCallbacks.push(done);\n  } else {\n    info.readyCallbacks = [done];\n  }\n};\n\nvar h = builder();\n\nexports.Component = _class2;\nexports.define = define;\nexports.emit = emit;\nexports.h = h;\nexports.link = link;\nexports.prop = prop;\nexports.props = props$1;\nexports.ready = ready;\nexports.symbols = symbols$1;\nexports.vdom = vdom;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs/dist/index.js\n// module id = 2\n// module chunks = 0 1","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/incremental-dom/dist/incremental-dom-cjs.js\n// module id = 3\n// module chunks = 0 1","'use strict'\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n  (typeof global === 'object' && global.global === global && global) ||\n  this\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/window-or-global/lib/index.js\n// module id = 4\n// module chunks = 0 1"],"sourceRoot":""}