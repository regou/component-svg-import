{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///dist/index-with-deps.min.js","webpack:///webpack/bootstrap ad59821860eedd756661?d3ce","webpack:///./src/index.js?9552","webpack:///./~/skatejs-web-components/dist/index.js?d957","webpack:///./~/skatejs/dist/index.js?6821","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js?18a5","webpack:///./~/window-or-global/lib/index.js?d7c1","webpack:///./~/rxjs/BehaviorSubject.js?84cb","webpack:///./~/rxjs/Subject.js?c1c6","webpack:///./~/rxjs/Observable.js?4e06","webpack:///./~/rxjs/util/root.js?93c3","webpack:///./~/rxjs/util/toSubscriber.js?f8fe","webpack:///./~/rxjs/Subscriber.js?215e","webpack:///./~/rxjs/util/isFunction.js?51c0","webpack:///./~/rxjs/Subscription.js?5c58","webpack:///./~/rxjs/util/isArray.js?b0ea","webpack:///./~/rxjs/util/isObject.js?aa2e","webpack:///./~/rxjs/util/tryCatch.js?7694","webpack:///./~/rxjs/util/errorObject.js?f49b","webpack:///./~/rxjs/util/UnsubscriptionError.js?bc9d","webpack:///./~/rxjs/Observer.js?f098","webpack:///./~/rxjs/symbol/rxSubscriber.js?112c","webpack:///./~/rxjs/symbol/observable.js?1f24","webpack:///./~/rxjs/util/ObjectUnsubscribedError.js?e559","webpack:///./~/rxjs/SubjectSubscription.js?d351","webpack:///./~/rxjs/Observable/dom/ajax.js?8997","webpack:///./~/rxjs/Observable/dom/AjaxObservable.js?e6d9","webpack:///./~/rxjs/operator/map.js?9cf8","webpack:///./~/rxjs/add/observable/empty.js?6892","webpack:///./~/rxjs/observable/empty.js?f721","webpack:///./~/rxjs/observable/EmptyObservable.js?dd31","webpack:///./~/rxjs/add/operator/filter.js?5af9","webpack:///./~/rxjs/operator/filter.js?0cb7","webpack:///./~/rxjs/add/operator/map.js?94b1","webpack:///./~/rxjs/add/operator/catch.js?33c3","webpack:///./~/rxjs/operator/catch.js?75c4","webpack:///./~/rxjs/OuterSubscriber.js?4197","webpack:///./~/rxjs/util/subscribeToResult.js?c011","webpack:///./~/rxjs/util/isPromise.js?68d7","webpack:///./~/rxjs/symbol/iterator.js?6b44","webpack:///./~/rxjs/InnerSubscriber.js?7259","webpack:///./~/rxjs/add/operator/switchMap.js?ff90","webpack:///./~/rxjs/operator/switchMap.js?8193","webpack:///./~/rxjs/add/operator/distinct.js?669d","webpack:///./~/rxjs/operator/distinct.js?5f80","webpack:///./~/rxjs/util/Set.js?75d1"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","_skatejs","_BehaviorSubject","_Observable","_ajax","React","createElement","customElements","_Component","_class","_this","src$","BehaviorSubject","src","filter","val","distinct","switchMap","fetchXml","xml","prop","string","attribute","inner-style","ajax","url","cache","crossDomain","responseType","map","response","jQuery","parseXML","catch","err","console","error","Observable","empty","shadowRoot","find","comp","$","$svg","svg","removeAttribute","width","height","setAttribute","wraper","getWraper","innerHTML","appendChild","_this2","srcSubscription","subscribe","updateXml","name","oldValue","newValue","next","unsubscribe","defBoxStyle","role","className","Component","fixSafari","newAttachShadow","opts","sr","oldAttachShadow","mo","observe","moOpts","HTMLElement","attachShadow","childList","subtree","MutationObserver","muts","forEach","mut","tagName","nextSibling","parentNode","removeChild","insertBefore","_window","window","navigator","userAgent","safari","indexOf","safariVersion","match","safariVersions","v","concat","patch","default","eval","a","Map","j","h","o","Set","C","D","bind","f","F","enableFlush","s","g","k","test","q","Error","l","b","d","e","toLowerCase","u","n","getAttribute","__$CE_upgraded","localName","A","document","forcePolyfill","split","L","has","set","w","observedAttributes","K","resolve","delete","M","Promise","reject","N","takeRecords","childNodes","HTMLImports","whenReady","I","__$CE_observer","add","J","disconnect","type","removedNodes","addedNodes","H","nodeType","Node","ELEMENT_NODE","createTreeWalker","NodeFilter","SHOW_ELEMENT","G","currentNode","nextNode","__$CE_attached","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","host","rel","B","import","href","removeEventListener","addEventListener","assert","attributes","attributeOldValue","attributeFilter","hasAttribute","attributeName","attributeNamespace","CustomElementRegistry","whenDefined","flush","polyfilled","_observeRoot","_addImport","r","t","createElementNS","Element","importNode","CustomElements","isShadyRoot","obj","Boolean","__localName","matchesSelector","element","selector","matches","copyOwnProperty","source","pd","extend","n$","getOwnPropertyNames","extendAll","sources","len","arguments","mixin","patchPrototype","proto","hasOwnProperty","patchProto","__sourceProto","__patchProto","newSplice","index","removed","addedCount","getNativeProperty","descriptors","enqueue","callback","scheduled","promish","then","flush$1","flushList","push","flushCount","shift","isFlushedMaxed","flushMax","escapeReplace","escapeAttr","replace","escapeAttrRegExp","escapeData","escapeDataRegExp","makeSet","arr","getOuterHTML","node","composed","attr","attrs","voidElements","getInnerHTML","TEXT_NODE","data","plaintextParents","COMMENT_NODE","content","child","c$","filterMutations","mutations","targetRootNode","getRootNode","mutation","mutationInScope","nodes","Array","from","patchNode","settings","inUse","isNodePatched","patchImpl","canPatchNode","tree","saveChildNodes","unpatchNode","unpatch","__patched","pathComposer","startNode","composedPath","current","startRoot","assignedSlot","retarget","refNode","path","ancestor","lastRoot","rootIdx","refNodePath","p$","mixinComposedFlag","Base","klazz","options","event","__composed","fireHandlers","phase","hs","__handlers","fn","__immediatePropagationStopped","retargetNonBubblingEvent","__propagationStopped","Event","AT_TARGET","lastFiredRoot","i$1","optionsOrCapture","this$1","capture","once","passive","__eventWrappers","wrapperFn","__target","__relatedTarget","relatedTarget","EventMixin","eventPhase","BUBBLING_PHASE","stopImmediatePropagation","nonBubblingEventsToRetarget","bubble","origAddEventListener","splice","origRemoveEventListener","idx","activateFocusEventOverrides","ev","ShadyDOM","hasNativeShadowDOM","force","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","common","cb","twiddle","createTextNode","observer","characterData","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","ArraySplice","calcEditDistances","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","j$1","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","calcSplices","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","splices","oldIndex","searchLength","index1","index2","count","calculateSplices","previous","currentValue","previousValue","nativeInsertBefore","nativeAppendChild","nativeRemoveChild","arrayCopyChildNodes","copy","firstChild","arrayCopyChildren","firstElementChild","nextElementSibling","arrayCopy","a$","Logical","Composed","hasParentNode","saveComposedData","__dom","hasChildNodes","getChildNodes","_getChildNodes","getFirstChild","getNextSibling","getParentNode","getLastChild","lastChild","getPreviousSibling","previousSibling","getFirstElementChild","_getFirstElementChild","getLastElementChild","_getLastElementChild","getNextElementSibling","_getNextElementSibling","getPreviousElementSibling","_getPreviousElementSibling","recordInsertBefore","container","ref_node","_linkNode","recordRemoveChild","$parentNode","$childNodes","$firstChild","$nextSibling","getComposedChildNodes","$lastChild","$previousSibling","lastElementChild","previousElementSibling","clearChildNodes","saveParentNode","newChild","refChild","_addChild","currentParent","_removeChild","isFrag","oldParent","NormalizedEvent","inType","params","createEvent","initEvent","bubbles","cancelable","Distributor","anonymous","insertionPointTag","getInsertionPoints","querySelectorAll","hasInsertionPoint","_insertionPoints","isInsertionPoint","distribute","distributePool","collectPool","pool","dirtyRoots","distributeInsertionPoint","shadyRoot","p$1","_assignedSlot","parent$1","insertionPoint","prevAssignedNodes","_assignedNodes","clearAssignedSlots","needsSlotChange","anyDistributed","matchesInsertionPoint","__prevAssignedSlot","distributeNodeInto","node$1","children","setDistributedNodesOnInsertionPoint","_fireSlotChange","slot","savePrevious","slotName","trim","_distributedNodes","d$","dispatchEvent","isFinalDestination","ShadyRoot","frag","createDocumentFragment","ShadyFragmentMixin","_init","ShadyMixin","_clean","_hasRendered","_distributor","update","distributionRoot","_findDistributionRoot","render","_elementNeedsDistribution","_skipUpdateInsertionPoints","updateInsertionPoints","compose","forceRender","i$","__insertionPoints","c$1","insertionPoints","_composeTree","_updateChildNodes","_composeNode","distributedNodes","distributedNode","s$1","n$1","getInsertionPointTag","DocumentFragment","list","mixinImpl","addNode","ownerRoot","ownerShadyRootForNode","__noInsertionPoint","ipAdded","_maybeAddInsertionPoint","handled","_maybeDistribute","removeNode","distributed","logicalParent","maybeDistributeParent","_removeDistributedChildren","_removeOwnerShadyRoot","_scheduleObserver","addedNode","removedNode","schedule","removeNodeFromParent","_hasCachedOwnerRoot","__ownerShadyRoot","documentElement","contains","fragContent","querySelector","wrappedContent","hasContent","needsDist","_nodeNeedsDistribution","added","np","na","hostNeedsDist","ip$","_contains","dc$","assignedNodes","flatten","firstComposedNode","clearNode","maybeDistributeAttributeChange","query","matcher","halter","_queryElements","elements","_queryElement","result","activeElementForNode","active","activeElement","isShadyRoot$$1","activeRoot","nativeCloneNode","cloneNode","nativeImportNode","Document","nativeSetAttribute","nativeRemoveAttribute","ShadyCSS","setElementClass","NodeMixin","parentElement","FragmentMixin","replaceChild","deep","nc","externalNode","doc","ownerDocument","isArray","textContent","tc","cn","join","text","ElementMixin","activeElementDescriptor","ActiveElementMixin","UnderActiveElementMixin","_activeElement","Mixins","Fragment","AsyncObserver","_scheduled","callbacks","observeChildren","_callback","_observer","_node","unobserveChildren","handle","size","patchedCount","log","head","hasPrototypeDescriptors","warn","mixinForObject","mixinForNode","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","isTrusted","__composedPath","currentTarget","__relatedTargetComposedPath","stopPropagation","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","isPatched","createRootAndEnsurePatched","parse","clean","parseCss","lex","cssText","RX","comments","port","start","end","OPEN_BRACE","rules","CLOSE_BRACE","substring","parsedCssText","ss","_expandUnicodeEscapes","multipleSpaces","lastIndexOf","parsedSelector","atRule","AT_START","MEDIA_START","types","MEDIA_RULE","keyframesRule","KEYFRAMES_RULE","keyframesName","pop","VAR_START","MIXIN_RULE","STYLE_RULE","r$","code","repeat","stringify","preserveProperties","_hasMixinRules","removeCustomProps","removeCustomPropAssignment","removeCustomPropApply","customProp","mixinProp","mixinApply","varApply","parseSettings","nativeCssVariables","shimcssproperties","nativeShadow","shimshadow","toCssText","forEachRule","rulesForStyle","style","__cssRules","isKeyframesSelector","rule","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","matchMedia","rx","MEDIA_MATCH","applyCss","moniker","contextNode","createScopeStyle","applyStyle$1","after","lastHeadApplyNode","applyStylePlaceHolder","placeHolder","createComment","scope","findMatchingParen","level","processVariableAndFallback","str","inner","prefix","suffix","comma","fallback","addToBitMask","bits","parseInt","enqueueDocumentValidation","enqueued","validateDocument","readyState","requestAnimationFrame","ShadyCSS$1","updateStyles","CustomStyle","Reflect","construct","customStyles","CSS","supports","nativeCssApply","WebComponents","flags","VAR_ASSIGN","MIXIN_MATCH","VAR_CONSUMED","ANIMATION_MATCH","IS_VAR","BRACKETED","HOST_PREFIX","HOST_SUFFIX","SCOPE_NAME","StyleTransformer","dom","shouldRemoveScope","__styleScoped","_transformDom","classList","_content","_element","remove","CLASS","elementStyles","styleRules","cssBuildType","__cssBuild","css","is","extends","ext","hostScope","_calcHostScope","_calcElementScope","isScoped","CSS_CLASS_PREFIX","_rule","_transformRule","_transformComplexSelector","transformer","transformedSelector","_transformRuleCss","COMPLEX_SELECTOR_SEP","stop","NTH","SLOTTED_START","HOST","SIMPLE_SELECTOR_SEP","info","_transformCompoundSelector","combinator","slottedIndex","SLOTTED","_transformHostSelector","_transformSimpleSelector","slotted","SLOTTED_PAREN","paren","DIR_PAREN","before","dir","PSEUDO_PREFIX","HOST_PAREN","SIMPLE_SELECTOR_PREFIX","typeSelector","SELECTOR_NO_MATCH","documentRule","normalizeRootSelector","_transformDocumentSelector","ROOT","SCOPE_DOC_SELECTOR","RegExp","classCallCheck","createClass","toConsumableArray","arr2","StyleInfo","ast","placeholder","ownStylePropertyNames","elementName","typeExtension","cssBuild","overrideStyleProperties","styleProperties","scopeSelector","customStyle","__styleInfo","styleInfo","IS_IE","StyleProperties","decorateStyles","keyframes","ruleIndex","decorateRule","collectPropertiesInCssText","propertyInfo","_keyframes","names","properties","hasProperties","collectProperties","collectCssText","rx$$1","any","exec","assign","collectConsumingCssText","reify","valueForProperty","valueForProperties","propertyValue","_p","parts","lastIndex","colon","pp","slice","applyProperties","output","applyKeyframeTransforms","keyframeTransforms","hasAnimations","transform","keyframeNamesToTransform","keyframe","propertyDataFromStyles","selectorToMatch","whenHostOrRootRule","isRoot","isHost","hostAndRootPropertiesForScope","hostProps","rootProps","transformStyles","hostSelector","rxHostSelector","hostRx","_elementKeyframeTransforms","_scopeSelector","keyframesRules","_scopeKeyframes","_keyframesRuleTransformer","keyframesNameRx","transformedKeyframesName","scopeId","_p2","applyElementScopeSelector","XSCOPE_NAME","applyElementStyle","_useCount","applyCustomStyle","templateMap","placeholderMap","ce","origDefine","clazz","StyleCache","typeMax","cacheEntry","ownPropertyNames","pn","tagname","styleElement","entry","_validate","APPLY_NAME_CLEAN","INITIAL_INHERIT","MIXIN_VAR_SEP","MixinMap","_map","dependants","ApplyShim","_currentTemplate","_measureElement","_separator","_boundProduceCssProperties","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","transformRules","transformRule","__applyShimInvalid","transformCssText","_consumeCssProperties","all","getComputedStyle","getPropertyValue","mixinName","applyPos","afterApplyPos","textBeforeApply","textAfterApply","defaults$$1","_cssTextToMap","replacement","_atApplyToCssProperties","fallbacks","vars","mixinEntry","_getInitialValueForProperty","sp","out","_replaceInitialOrInherit","_this3","mixinAsProperties","mixinValues","combinedProps","oldProps","needToInvalidate","_invalidateMixinEntry","applyShim","handler","mxns","x","mxn","_i","_n","classIdx","_scope","startState","body","styleCache","scopeCounter","nativeCss","_documentOwner","_documentOwnerStyleInfo","_generateScopeSelector","getStyleAst","styleAstToString","_gatherStyles","template","styles","_getCssBuild","prepareTemplate","_prepared","_styleAst","_generateStaticStyle","_style","_ownPropertyNames","shadowroot","_prepareHost","_cssBuild","applyStyle","overrideProps","CS","_documentDirty","findStyles","_revalidateApplyShim","_updateProperties","applyStyles","_updateNativeProperties","_applyStyleProperties","_isRootOwner","_applyToDescendants","_styleOwnerForNode","fetch","cachedScopeSelector","cachedStyle","oldScopeSelector","store","owner","ownerStyleInfo","ownerProperties","hostAndRootProps","propertyData","propertiesMatchingHost","_mixinOverrideStyles","overrides","removeProperty","setProperty","_transformCustomStyleForDocument","_applyCustomStyleToDocument","getComputedStyleValue","classString","_element$classList","apply","_styleInfoForNode","hookFn","processHook","_customStyles","_findStyle","_applyStyle","__appliedElement","global","incrementalDom","keys","_ref","_ref$enumOnly","enumOnly","listOfKeys","getOwnPropertySymbols","def","_len","args","_key","unshift","enter","saved","exit","applyEvent","elem","ename","newFunc","events","$currentEventHandlers","resolveTagName","name$$1","elementOpenStart","tag","statics","overrideArgs","elementOpenEnd","newElementOpen","wrapIdomFunc","func","tnameFuncHandler","noop","wrap","stackCurrentHelper","stackChren","elementOpen$1","skips","$skip","elementClose","skip","_elem","ref$$1","ref$1","newAttr","_len2","_key2","$stackCurrentHelperProps","stackOpen","tname","props$$1","_len3","_key3","stackClose","chren","elemOrFn","newElementVoid","_len4","_key4","newElementClose","atype","_typeof","_len5","_key5","newElementOpenStart","newElementOpenEnd","ch","ctype","newText","sch","builder","_len6","tags","_key6","_len7","_key7","_len8","_key8","createSymbol","description","Symbol","microtaskDebounce","cbFunc","cbArgs","taskDebounce","setTimeout","setCtorNativeProperty","Ctor","propName","getPropsMap","ctorPropsMap","propsMap","reduce","propNameOrSymbol","get$2","set$2","newProps","renderer$1","getDefaultValue","getInitialValue","initial","getPropData","elemData","syncFirstTimeProp","propData","syncAttrValue","lastAssignedValue","serialize","syncingAttribute","syncExistingProp","settingAttribute","internalValue","serializedValue","currentAttrValue","serializedIsEmpty","attributeChanged","shouldRemoveAttribute","syncPropToAttr","isFirstSync","createNativePropertyDefinition","created","dashCase","initialValue","deserialize","coerce","changeData","rendererDebounced","connected","preventDoubleCalling","_prevName","_prevOldValue","_prevNewValue","syncPropsToAttrs","ensurePropertyFunctions","descriptorName","initProps","ensurePropertyDefinitions","createInitProps","hasPropBeforeUpgrading","valueBeforeUpgrading","uniqueId","rand","random","toString","createCustomEvent","detail","initCustomEvent","getValue","checked","arg","alwaysUndefinedIfNotANumberOrNumber","isNaN","Number","alwaysUndefinedIfEmptyOrString","String","array","JSON","boolean","number","freeze","created$1","ctorCreateInitProps","ctorObservedAttributes","ctorProps","rendering","updated$1","symbols$1","propContext","iterator","AwaitValue","AsyncGenerator","gen","send","request","back","front","resume","settle","done","_invoke","return","asyncIterator","throw","await","get$1","inherits","possibleConstructorReturn","applyDefault","symbols","attributesContext","applyProp","disabled","ref","firstChar","eventName","toUpperCase","elementOpen","vdom","elementVoid","namespace","__SKATE_DATA","one","two","dash","nativeHints","native","hint","debounce","getOwnPropertyDescriptors","prev","curr","props$1","HTMLElement$1","_class2","_HTMLElement","propConfigsCount","renderCallback","readyCallbacks","attrsOnCtor","attrsFromLinkedProps","item","attached","detached","propOpts","newPropVal","updated","rendered","renderer","rendererCallback","renderedCallback","updatedCallback","definition","_Base","prot","allKeys","mode","patchInner","possibleFn","TheEvent","emit","link","localTarget","firstPart","ready","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMap","keyMapValid","Context","notifications","nodesCreated","deleted","nodesDeleted","initData","getData","getNamespace","applyAttr","el","attrNS","setAttributeNS","elStyle","applyAttributeTyped","updateAttribute","mutator","getNamespaceForTag","namespaceURI","createText","createKeyMap","getKeyMap","getChild","registerChild","markCreated","markDeleted","notifyChanges","context","patchFactory","run","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","enterNode","exitNode","patchOuter","alignWithDOM","clearUnvisitedDOM","coreElementOpen","coreElementClose","coreText","currentElement","ATTRIBUTES_OFFSET","argsBuilder","const_args","attrsChanged","_attr","elementPlaceholder","formatted","__extends","__","Subject_1","ObjectUnsubscribedError_1","_super","_value","_subscribe","subscriber","subscription","closed","hasError","thrownError","ObjectUnsubscribedError","Subject","Observable_1","Subscriber_1","Subscription_1","SubjectSubscription_1","rxSubscriber_1","SubjectSubscriber","destination","Subscriber","observers","isStopped","$$rxSubscriber","lift","operator","subject","AnonymousSubject","complete","Subscription","EMPTY","SubjectSubscription","asObservable","observable","root_1","toSubscriber_1","observable_1","_isScalar","observerOrNext","sink","toSubscriber","syncErrorThrowable","syncErrorThrown","syncErrorValue","PromiseCtor","Rx","config","$$observable","nextOrObserver","Observer_1","isFunction_1","destinationOrNext","SafeSubscriber","_next","_error","_complete","_parent","isFunction","_context","__tryOrSetError","__tryOrUnsub","_unsubscribe","isArray_1","isObject_1","tryCatch_1","errorObject_1","UnsubscriptionError_1","errors","hasErrors","_a","_subscriptions","trial","tryCatch","errorObject","sub","isObject","UnsubscriptionError","teardown","subscriptions","subscriptionIndex","tryCatcher","tryCatchTarget","stack","message","for","getSymbolObservable","subscriberIndex","AjaxObservable_1","AjaxObservable","getCORSRequest","XMLHttpRequest","xhr","withCredentials","XDomainRequest","getXMLHttpRequest","progId","progIds","ActiveXObject","ajaxGet","headers","method","ajaxPost","ajaxDelete","ajaxPut","ajaxGetJSON","map_1","MapOperator","urlOrRequest","async","createXHR","timeout","AjaxSubscriber","post","put","getJSON","FormData","serializeBody","AjaxResponse","_b","user","password","open","setHeaders","setupEvents","contentType","splitIndex","encodeURI","setRequestHeader","xhrTimeout","progressSubscriber","AjaxTimeoutError","xhrReadyStateChange","status_1","status","responseText","AjaxError","ontimeout","upload","xhrProgress_1","onprogress","xhrError_1","onerror","onreadystatechange","abort","originalEvent","responseXML","project","thisArg","MapSubscriber","empty_1","EmptyObservable_1","EmptyObservable","scheduler","dispatch","filter_1","predicate","FilterOperator","FilterSubscriber","catch_1","_catch","CatchOperator","caught","OuterSubscriber_1","subscribeToResult_1","CatchSubscriber","subscribeToResult","OuterSubscriber","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","outerSubscriber","InnerSubscriber_1","InnerSubscriber","isPromise_1","isPromise","iterator_1","$$iterator","obs","symbolIteratorPonyfill","Set_1","Map_1","switchMap_1","resultSelector","SwitchMapOperator","SwitchMapSubscriber","_innerSub","innerSubscription","_tryNotifyNext","distinct_1","keySelector","flushes","DistinctOperator","DistinctSubscriber","values","clear","_useKeySelector","_finalizeNext","minimalSetImpl","MinimalSet","_values"],"mappings":"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","file":"dist/index-with-deps.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"componentSvgImport\"] = factory();\n\telse\n\t\troot[\"componentSvgImport\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"componentSvgImport\"] = factory();\n\telse\n\t\troot[\"componentSvgImport\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(1);\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _BehaviorSubject = __webpack_require__(5);\n\t\n\tvar _Observable = __webpack_require__(7);\n\t\n\tvar _ajax = __webpack_require__(23);\n\t\n\t__webpack_require__(26);\n\t\n\t__webpack_require__(29);\n\t\n\t__webpack_require__(31);\n\t\n\t__webpack_require__(32);\n\t\n\t__webpack_require__(39);\n\t\n\t__webpack_require__(41);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar React = { createElement: _skatejs.h };\n\t\n\tcustomElements.define('svg-import', function (_Component) {\n\t\t_inherits(_class, _Component);\n\t\n\t\t_createClass(_class, null, [{\n\t\t\tkey: 'props',\n\t\t\tget: function get() {\n\t\t\t\treturn {\n\t\t\t\t\t// By declaring the property an attribute, we can now pass an initial value\n\t\t\t\t\t// for the count as part of the HTML.\n\t\t\t\t\tsrc: _skatejs.prop.string({ attribute: true }),\n\t\t\t\t\t'inner-style': _skatejs.prop.string({ attribute: true })\n\t\t\t\t};\n\t\t\t}\n\t\t}]);\n\t\n\t\tfunction _class() {\n\t\t\t_classCallCheck(this, _class);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));\n\t\n\t\t\t_this.src$ = new _BehaviorSubject.BehaviorSubject(_this.src).filter(function (val) {\n\t\t\t\treturn val && typeof val === 'string';\n\t\t\t}).distinct(function (src) {\n\t\t\t\treturn src + _this['inner-style'];\n\t\t\t}).switchMap(function (src) {\n\t\t\t\treturn _this.fetchXml(src);\n\t\t\t}).filter(function (xml) {\n\t\t\t\treturn !!xml;\n\t\t\t});\n\t\t\treturn _this;\n\t\t}\n\t\n\t\t_createClass(_class, [{\n\t\t\tkey: 'fetchXml',\n\t\t\tvalue: function fetchXml(src) {\n\t\n\t\t\t\treturn (0, _ajax.ajax)({ url: src, cache: true, crossDomain: true, responseType: 'text' }).map(function (response) {\n\t\t\t\t\treturn jQuery.parseXML(response.response);\n\t\t\t\t}).catch(function (err) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\treturn _Observable.Observable.empty();\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'getWraper',\n\t\t\tvalue: function getWraper() {\n\t\t\t\treturn jQuery(this.shadowRoot).find('.svg-import-wrap').get(0);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'updateXml',\n\t\t\tvalue: function updateXml(xml) {\n\t\t\t\tvar comp = this;\n\t\t\t\tif (!xml) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar $ = jQuery;\n\t\n\t\t\t\tvar $svg = $(xml).find('svg');\n\t\t\t\tvar svg = $svg.get(0);\n\t\n\t\t\t\tsvg.removeAttribute('xmlns:a');\n\t\t\t\tif (comp.width && comp.height) {\n\t\t\t\t\t// svg.hasAttribute('viewBox') ? svg.setAttribute('viewBox', '0 0 ' + comp.height + ' ' + comp.width) : '';\n\t\t\t\t\tsvg.setAttribute('width', '100%');\n\t\t\t\t\tsvg.setAttribute('height', '100%');\n\t\t\t\t}\n\t\n\t\t\t\tvar wraper = comp.getWraper();\n\t\n\t\t\t\tif (wraper) {\n\t\t\t\t\twraper.innerHTML = '';\n\t\t\t\t\twraper.appendChild(svg);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'connectedCallback',\n\t\t\tvalue: function connectedCallback() {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\t// Ensure we call the parent.\n\t\t\t\t_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'connectedCallback', this).call(this);\n\t\t\t\t//this.updateXml();\n\t\t\t\tif (!jQuery) {\n\t\t\t\t\tthrow new TypeError('svg-import require jQuery to work!');\n\t\t\t\t}\n\t\n\t\t\t\tthis.srcSubscription = this.src$.subscribe(function (src) {\n\t\t\t\t\treturn _this2.updateXml(src);\n\t\t\t\t}, function (err) {\n\t\t\t\t\treturn console.error(err);\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'attributeChangedCallback',\n\t\t\tvalue: function attributeChangedCallback(name, oldValue, newValue) {\n\t\t\t\t_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'attributeChangedCallback', this).call(this, name, oldValue, newValue);\n\t\t\t\tif (name === 'src') {\n\t\t\t\t\tthis.src$.next(newValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'disconnectedCallback',\n\t\t\tvalue: function disconnectedCallback() {\n\t\t\t\t// Ensure we callback the parent.\n\t\t\t\t_get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'disconnectedCallback', this).call(this);\n\t\t\t\tif (this.srcSubscription) {\n\t\t\t\t\tthis.srcSubscription.unsubscribe();\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'renderCallback',\n\t\t\tvalue: function renderCallback() {\n\t\t\t\t// By separating the strings (and not using template literals or string\n\t\t\t\t// concatenation) it ensures the strings are diffed indepenedently. If\n\t\t\t\t// you select \"Count\" with your mouse, it will not deselect whenr endered.\n\t\t\t\tvar comp = this;\n\t\n\t\t\t\tvar defBoxStyle = '\\n\\t\\t\\t:host{display:inline-block;}\\n\\t\\t\\t.svg-import-wrap{\\n\\t\\t\\t\\toverflow:hidden;\\n\\t\\t\\t\\tmargin:0;\\n\\t\\t\\t\\tpadding:0;\\n\\t\\t\\t\\twidth:100%;\\n\\t\\t\\t\\theight:100%;\\n\\t\\t\\t\\tmin-width:5px;\\n\\t\\t\\t\\tmin-height:5px;\\n\\t\\t\\t\\tdisplay:block;\\n\\t\\t\\t}\\n\\t\\t\\tsvg{\\n\\t\\t\\t\\twidth:100%;\\n\\t\\t\\t\\theight:100%;\\n\\t\\t\\t}\\n\\t\\t';\n\t\n\t\t\t\tthis.src$.next(comp.src);\n\t\n\t\t\t\treturn React.createElement(\n\t\t\t\t\t'div',\n\t\t\t\t\tnull,\n\t\t\t\t\tReact.createElement(\n\t\t\t\t\t\t'style',\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tdefBoxStyle + comp['inner-style']\n\t\t\t\t\t),\n\t\t\t\t\tReact.createElement('figure', { role: 'image', className: 'svg-import-wrap' })\n\t\t\t\t);\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn _class;\n\t}(_skatejs.Component));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"skatejsWebComponents\"] = factory();\n\t\telse\n\t\t\troot[\"skatejsWebComponents\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\t\n\t\t// We load the Safari fix first because the custom element polyfill overrides\n\t\t// attachShadow() to observe the shadow root.\n\t\t__webpack_require__(1);\n\t\t\n\t\t// We have to include this first so that it can patch native.\n\t\t__webpack_require__(2);\n\t\t\n\t\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t\t// ShadyDOM polyfill be loaded first.\n\t\t__webpack_require__(3);\n\t\t__webpack_require__(4);\n\t\t__webpack_require__(5);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\tvar _window = window,\n\t\t    HTMLElement = _window.HTMLElement,\n\t\t    MutationObserver = _window.MutationObserver,\n\t\t    navigator = _window.navigator;\n\t\tvar userAgent = navigator.userAgent;\n\t\t\n\t\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\t\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\t\tvar safariVersions = [0, 1].map(function (v) {\n\t\t  return '10.0.' + v;\n\t\t}).concat(['10.0']);\n\t\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\t\n\t\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\t\tfunction fixSafari() {\n\t\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\t\n\t\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t\t  // element as this is the only scenario where styles aren't recalculated.\n\t\t  var moOpts = { childList: true, subtree: true };\n\t\t  var mo = new MutationObserver(function (muts) {\n\t\t    muts.forEach(function (mut) {\n\t\t      var target = mut.target;\n\t\t\n\t\t      if (target.tagName === 'STYLE') {\n\t\t        var nextSibling = target.nextSibling,\n\t\t            parentNode = target.parentNode;\n\t\t\n\t\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t\t        // as it seems that doesn't trigger a recalc.\n\t\t\n\t\t        parentNode.removeChild(target);\n\t\t        parentNode.insertBefore(target, nextSibling);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t\n\t\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t\t  function newAttachShadow(opts) {\n\t\t    var sr = oldAttachShadow.call(this, opts);\n\t\t    mo.observe(sr, moOpts);\n\t\t    return sr;\n\t\t  }\n\t\t\n\t\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t\t    // Ensure polyfills can override it (hoping they call it back).\n\t\t    configurable: true,\n\t\t    enumerable: true,\n\t\t    value: newAttachShadow,\n\t\t    writable: true\n\t\t  });\n\t\t}\n\t\t\n\t\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t\t// fixes the bug.\n\t\tif (patch) {\n\t\t  fixSafari();\n\t\t}\n\t\t\n\t\texports.default = patch;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t\n\t\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\t/*\n\t\t\n\t\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\t Code distributed by Google as part of the polymer project is also\n\t\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\t\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\t\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\t\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\t\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\t\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\t\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\t\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\t\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\t\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\t\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\t\n\t\t//# sourceMappingURL=custom-elements.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar settings = window.ShadyDOM || {};\n\t\t\n\t\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\t\n\t\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\t\n\t\tfunction isShadyRoot(obj) {\n\t\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t\t}\n\t\t\n\t\tvar p = Element.prototype;\n\t\tvar matches = p.matches || p.matchesSelector ||\n\t\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tfunction matchesSelector(element, selector) {\n\t\t  return matches.call(element, selector);\n\t\t}\n\t\t\n\t\tfunction copyOwnProperty(name, source, target) {\n\t\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t\t  if (pd) {\n\t\t    Object.defineProperty(target, name, pd);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction extend(target, source) {\n\t\t  if (target && source) {\n\t\t    var n$ = Object.getOwnPropertyNames(source);\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t\t      copyOwnProperty(n, source, target);\n\t\t    }\n\t\t  }\n\t\t  return target || source;\n\t\t}\n\t\t\n\t\tfunction extendAll(target) {\n\t\t  var sources = [], len = arguments.length - 1;\n\t\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\t\n\t\t  for (var i=0; i < sources.length; i++) {\n\t\t    extend(target, sources[i]);\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tfunction mixin(target, source) {\n\t\t  for (var i in source) {\n\t\t    target[i] = source[i];\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t\t  obj.__proto__ = proto;\n\t\t  return obj;\n\t\t}\n\t\t\n\t\tfunction patchPrototype(obj, mixin) {\n\t\t  var proto = Object.getPrototypeOf(obj);\n\t\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t\t    var patchProto = Object.create(proto);\n\t\t    patchProto.__sourceProto = proto;\n\t\t    extend(patchProto, mixin);\n\t\t    proto.__patchProto = patchProto;\n\t\t  }\n\t\t  setPrototypeOf(obj, proto.__patchProto);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvar common = {};\n\t\t\n\t\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\t\tvar promish;\n\t\tif (window.Promise) {\n\t\t  promish = Promise.resolve();\n\t\t} else {\n\t\t  promish = {\n\t\t    then: function(cb) {\n\t\t      var twiddle = document.createTextNode('');\n\t\t      var observer = new MutationObserver(function() {\n\t\t        observer.disconnect();\n\t\t        cb();\n\t\t      });\n\t\t      observer.observe(twiddle, {characterData: true});\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction newSplice(index, removed, addedCount) {\n\t\t  return {\n\t\t    index: index,\n\t\t    removed: removed,\n\t\t    addedCount: addedCount\n\t\t  };\n\t\t}\n\t\t\n\t\tvar EDIT_LEAVE = 0;\n\t\tvar EDIT_UPDATE = 1;\n\t\tvar EDIT_ADD = 2;\n\t\tvar EDIT_DELETE = 3;\n\t\t\n\t\tvar ArraySplice = {\n\t\t\n\t\t  // Note: This function is *based* on the computation of the Levenshtein\n\t\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t\t  // edits - not one. With Array splices, an update is really a delete\n\t\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t\t  // maximum array items in the original array. For example:\n\t\t  //\n\t\t  //   'xxxx123' -> '123yyyy'\n\t\t  //\n\t\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t\t  // leaves the substring '123' intact.\n\t\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t\t                              old, oldStart, oldEnd) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // \"Deletion\" columns\n\t\t    var rowCount = oldEnd - oldStart + 1;\n\t\t    var columnCount = currentEnd - currentStart + 1;\n\t\t    var distances = new Array(rowCount);\n\t\t\n\t\t    // \"Addition\" rows. Initialize null column.\n\t\t    for (var i = 0; i < rowCount; i++) {\n\t\t      distances[i] = new Array(columnCount);\n\t\t      distances[i][0] = i;\n\t\t    }\n\t\t\n\t\t    // Initialize null row\n\t\t    for (var j = 0; j < columnCount; j++)\n\t\t      distances[0][j] = j;\n\t\t\n\t\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t\t        else {\n\t\t          var north = distances[i$1 - 1][j$1] + 1;\n\t\t          var west = distances[i$1][j$1 - 1] + 1;\n\t\t          distances[i$1][j$1] = north < west ? north : west;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t\n\t\t    return distances;\n\t\t  },\n\t\t\n\t\t  // This starts at the final weight, and walks \"backward\" by finding\n\t\t  // the minimum previous weight recursively until the origin of the weight\n\t\t  // matrix.\n\t\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t\t    var i = distances.length - 1;\n\t\t    var j = distances[0].length - 1;\n\t\t    var current = distances[i][j];\n\t\t    var edits = [];\n\t\t    while (i > 0 || j > 0) {\n\t\t      if (i == 0) {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        continue;\n\t\t      }\n\t\t      if (j == 0) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        continue;\n\t\t      }\n\t\t      var northWest = distances[i - 1][j - 1];\n\t\t      var west = distances[i - 1][j];\n\t\t      var north = distances[i][j - 1];\n\t\t\n\t\t      var min;\n\t\t      if (west < north)\n\t\t        min = west < northWest ? west : northWest;\n\t\t      else\n\t\t        min = north < northWest ? north : northWest;\n\t\t\n\t\t      if (min == northWest) {\n\t\t        if (northWest == current) {\n\t\t          edits.push(EDIT_LEAVE);\n\t\t        } else {\n\t\t          edits.push(EDIT_UPDATE);\n\t\t          current = northWest;\n\t\t        }\n\t\t        i--;\n\t\t        j--;\n\t\t      } else if (min == west) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        current = west;\n\t\t      } else {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        current = north;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    edits.reverse();\n\t\t    return edits;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t   * Splice Projection functions:\n\t\t   *\n\t\t   * A splice map is a representation of how a previous array of items\n\t\t   * was transformed into a new array of items. Conceptually it is a list of\n\t\t   * tuples of\n\t\t   *\n\t\t   *   <index, removed, addedCount>\n\t\t   *\n\t\t   * which are kept in ascending index order of. The tuple represents that at\n\t\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t\t   * from |index|, |addedCount| items were added.\n\t\t   */\n\t\t\n\t\t  /**\n\t\t   * Lacking individual splice mutation information, the minimal set of\n\t\t   * splices can be synthesized given the previous state and final state of an\n\t\t   * array. The basic approach is to calculate the edit distance matrix and\n\t\t   * choose the shortest path through it.\n\t\t   *\n\t\t   * Complexity: O(l * p)\n\t\t   *   l: The length of the current array\n\t\t   *   p: The length of the old array\n\t\t   */\n\t\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t\t                        old, oldStart, oldEnd) {\n\t\t    var prefixCount = 0;\n\t\t    var suffixCount = 0;\n\t\t    var splice;\n\t\t\n\t\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t\t    if (currentStart == 0 && oldStart == 0)\n\t\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\t\n\t\t    if (currentEnd == current.length && oldEnd == old.length)\n\t\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\t\n\t\t    currentStart += prefixCount;\n\t\t    oldStart += prefixCount;\n\t\t    currentEnd -= suffixCount;\n\t\t    oldEnd -= suffixCount;\n\t\t\n\t\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t\t      return [];\n\t\t\n\t\t    if (currentStart == currentEnd) {\n\t\t      splice = newSplice(currentStart, [], 0);\n\t\t      while (oldStart < oldEnd)\n\t\t        splice.removed.push(old[oldStart++]);\n\t\t\n\t\t      return [ splice ];\n\t\t    } else if (oldStart == oldEnd)\n\t\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\t\n\t\t    var ops = this.spliceOperationsFromEditDistances(\n\t\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t\t                               old, oldStart, oldEnd));\n\t\t\n\t\t    splice = undefined;\n\t\t    var splices = [];\n\t\t    var index = currentStart;\n\t\t    var oldIndex = oldStart;\n\t\t    for (var i = 0; i < ops.length; i++) {\n\t\t      switch(ops[i]) {\n\t\t        case EDIT_LEAVE:\n\t\t          if (splice) {\n\t\t            splices.push(splice);\n\t\t            splice = undefined;\n\t\t          }\n\t\t\n\t\t          index++;\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_UPDATE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_ADD:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t          break;\n\t\t        case EDIT_DELETE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    if (splice) {\n\t\t      splices.push(splice);\n\t\t    }\n\t\t    return splices;\n\t\t  },\n\t\t\n\t\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i = 0; i < searchLength; i++)\n\t\t      if (!this$1.equals(current[i], old[i]))\n\t\t        return i;\n\t\t    return searchLength;\n\t\t  },\n\t\t\n\t\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t\t    var index1 = current.length;\n\t\t    var index2 = old.length;\n\t\t    var count = 0;\n\t\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t\t      count++;\n\t\t\n\t\t    return count;\n\t\t  },\n\t\t\n\t\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t\t                            previous.length);\n\t\t  },\n\t\t\n\t\t  equals: function equals(currentValue, previousValue) {\n\t\t    return currentValue === previousValue;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t\t// for now this is stuck on `utils`\n\t\t//import {patchNode} from './patch'\n\t\t// native add/remove\n\t\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\t\tvar nativeAppendChild = Element.prototype.appendChild;\n\t\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\t\n\t\t/**\n\t\t * `tree` is a dom manipulation library used by ShadyDom to\n\t\t * manipulate composed and logical trees.\n\t\t */\n\t\tvar tree = {\n\t\t\n\t\t  // sad but faster than slice...\n\t\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopy: function arrayCopy(a$) {\n\t\t    var l = a$.length;\n\t\t    var copy = new Array(l);\n\t\t    for (var i=0; i < l; i++) {\n\t\t      copy[i] = a$[i];\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes(node) {\n\t\t    tree.Logical.saveChildNodes(node);\n\t\t    if (!tree.Composed.hasParentNode(node)) {\n\t\t      tree.Composed.saveComposedData(node);\n\t\t      //tree.Composed.saveParentNode(node);\n\t\t    }\n\t\t    tree.Composed.saveChildNodes(node);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\ttree.Logical = {\n\t\t\n\t\t  hasParentNode: function hasParentNode(node) {\n\t\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes(node) {\n\t\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes(node) {\n\t\t    // note: we're distinguishing here between undefined and false-y:\n\t\t    // hasChildNodes uses undefined check to see if this element has logical\n\t\t    // children; the false-y check indicates whether or not we should rebuild\n\t\t    // the cached childNodes array.\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      tree.Composed.getChildNodes(node);\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes(node) {\n\t\t    if (!node.__dom.childNodes) {\n\t\t      node.__dom.childNodes = [];\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        node.__dom.childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.childNodes;\n\t\t  },\n\t\t\n\t\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t\t  // element will store firstChild/lastChild, and in case (2), the element\n\t\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t\t  // the mere existence of __dom is not enough to know if the requested\n\t\t  // logical data is available and instead we do an explicit undefined check.\n\t\t  getParentNode: function getParentNode(node) {\n\t\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      this._getFirstElementChild(node) :\n\t\t      tree.Composed.getFirstElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t\t    var n = node.__dom.firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t\t      this._getLastElementChild(node) :\n\t\t      tree.Composed.getLastElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild(node) {\n\t\t    var n = node.__dom.lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t\t      this._getNextElementSibling(node) :\n\t\t      tree.Composed.getNextElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t\t      this._getPreviousElementSibling(node) :\n\t\t      tree.Composed.getPreviousElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  // Capture the list of light children. It's important to do this before we\n\t\t  // start transforming the DOM into \"rendered\" state.\n\t\t  // Children may be added to this list dynamically. It will be treated as the\n\t\t  // source of truth for the light children of the element. This element's\n\t\t  // actual children will be treated as the rendered state once this function\n\t\t  // has been called.\n\t\t  saveChildNodes: function saveChildNodes$1(node) {\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.firstChild;\n\t\t      node.__dom.lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        n.__dom = n.__dom || {};\n\t\t        n.__dom.parentNode = node;\n\t\t        n.__dom.nextSibling = c$[i+1] || null;\n\t\t        n.__dom.previousSibling = c$[i-1] || null;\n\t\t        common.patchNode(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t\t  // already been distributed.\n\t\t  // NOTE: ensure `node` is patched...\n\t\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var c$ = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1._linkNode(c$[i], container, ref_node);\n\t\t      }\n\t\t      // cleanup logical dom in doc fragment.\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t\t      node.__dom.childNodes = null;\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t\t    common.patchNode(node);\n\t\t    ref_node = ref_node || null;\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t\t      container.__dom.lastChild;\n\t\t    if (node.__dom.previousSibling) {\n\t\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.nextSibling = ref_node;\n\t\t    if (node.__dom.nextSibling) {\n\t\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.lastChild = node;\n\t\t      if (!container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.firstChild) {\n\t\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.lastChild) {\n\t\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.previousSibling;\n\t\t    var n = node.__dom.nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.previousSibling = p;\n\t\t    }\n\t\t    // When an element is removed, logical data is no longer tracked.\n\t\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t\t    // from `null` which is set if info is null.\n\t\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t\t      node.__dom.nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\t\n\t\t// TODO(sorvell): composed tree manipulation is made available\n\t\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t\t// to the tree for optional patching pluggability.\n\t\ttree.Composed = {\n\t\t\n\t\t  hasParentNode: function hasParentNode$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes$1(node) {\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes$1(node) {\n\t\t    if (!node.__dom.$childNodes) {\n\t\t      node.__dom.$childNodes = [];\n\t\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t\t        node.__dom.$childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getParentNode: function getParentNode$1(node) {\n\t\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t\t      (!node.__patched && node.parentNode);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t\t    return node.__patched ? this._getFirstElementChild(node) :\n\t\t      node.firstElementChild;\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t\t    var n = node.__dom.$firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild$1(node) {\n\t\t    return node.__patched ? this._getLastElementChild(node) :\n\t\t      node.lastElementChild;\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t\t    var n = node.__dom.$lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t\t    return node.__patched ? this._getNextElementSibling(node) :\n\t\t      node.nextElementSibling;\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t\t      node.previousElementSibling;\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes$2(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.$firstChild = node.firstChild;\n\t\t      node.__dom.$lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        this$1.saveComposedData(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveComposedData: function saveComposedData(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    if (node.__dom.$parentNode === undefined) {\n\t\t      node.__dom.$parentNode = node.parentNode;\n\t\t    }\n\t\t    if (node.__dom.$nextSibling === undefined) {\n\t\t      node.__dom.$nextSibling = node.nextSibling;\n\t\t    }\n\t\t    if (node.__dom.$previousSibling === undefined) {\n\t\t      node.__dom.$previousSibling = node.previousSibling;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.$childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      // TODO(sorvell): remember this for patching:\n\t\t      // the act of setting this info can affect patched nodes\n\t\t      // getters; therefore capture childNodes before patching.\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        this$1._linkNode(n, container, ref_node);\n\t\t      }\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t\t      container.__dom.$lastChild;\n\t\t    if (node.__dom.$previousSibling) {\n\t\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.$nextSibling = ref_node;\n\t\t    if (node.__dom.$nextSibling) {\n\t\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.$parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.$lastChild = node;\n\t\t      if (!container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.$firstChild) {\n\t\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.$lastChild) {\n\t\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.$previousSibling;\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.$nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.$previousSibling = p;\n\t\t    }\n\t\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t\t      node.__dom.$nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  clearChildNodes: function clearChildNodes(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = this.getChildNodes(node);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      this$1.recordRemoveChild(c, node);\n\t\t      nativeRemoveChild.call(node, c)\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveParentNode: function saveParentNode(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    node.__dom.$parentNode = node.parentNode;\n\t\t  },\n\t\t\n\t\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    // remove from current location.\n\t\t    this._addChild(parentNode, newChild, refChild);\n\t\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t\t  },\n\t\t\n\t\t  appendChild: function appendChild(parentNode, newChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._addChild(parentNode, newChild);\n\t\t    return nativeAppendChild.call(parentNode, newChild);\n\t\t  },\n\t\t\n\t\t  removeChild: function removeChild(parentNode, node) {\n\t\t    var currentParent = this.getParentNode(node);\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._removeChild(parentNode, node);\n\t\t    if (currentParent === parentNode) {\n\t\t      return nativeRemoveChild.call(parentNode, node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var oldParent = this.getParentNode(newChild);\n\t\t    if (oldParent) {\n\t\t      this._removeChild(oldParent, newChild);\n\t\t    }\n\t\t    if (isFrag) {\n\t\t      var c$ = this.getChildNodes(newChild);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        var c = c$[i];\n\t\t        // unlink document fragment children\n\t\t        this$1._removeChild(newChild, c);\n\t\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t\t      }\n\t\t    } else {\n\t\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeChild: function _removeChild(parentNode, node) {\n\t\t    this.recordRemoveChild(node, parentNode);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\t// for testing...\n\t\tvar descriptors = {};\n\t\tfunction getNativeProperty(element, property) {\n\t\t  if (!descriptors[property]) {\n\t\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t\t      HTMLElement.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Element.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Node.prototype, property);\n\t\t  }\n\t\t  return descriptors[property].get.call(element);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// NOTE: normalize event contruction where necessary (IE11)\n\t\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t\t  function(inType, params) {\n\t\t    params = params || {};\n\t\t    var e = document.createEvent('Event');\n\t\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t\t    return e;\n\t\t  };\n\t\t\n\t\tvar Distributor = (function () {\n\t\t  function anonymous(root) {\n\t\t    this.root = root;\n\t\t    this.insertionPointTag = 'slot';\n\t\t  }\n\t\t\n\t\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t\t    return Boolean(this.root._insertionPoints &&\n\t\t      this.root._insertionPoints.length);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t\t    return node.localName && node.localName == this.insertionPointTag;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distribute = function distribute () {\n\t\t    if (this.hasInsertionPoint()) {\n\t\t      return this.distributePool(this.root, this.collectPool());\n\t\t    }\n\t\t    return [];\n\t\t  };\n\t\t\n\t\t  // Gather the pool of nodes that should be distributed. We will combine\n\t\t  // these with the \"content root\" to arrive at the composed tree.\n\t\t  anonymous.prototype.collectPool = function collectPool () {\n\t\t    return tree.arrayCopy(\n\t\t      tree.Logical.getChildNodes(this.root.host));\n\t\t  };\n\t\t\n\t\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t\t  // instead elements are distributed into storage\n\t\t  // array where applicable.\n\t\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var dirtyRoots = [];\n\t\t    var p$ = this.root._insertionPoints;\n\t\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t\t      this$1.distributeInsertionPoint(p, pool);\n\t\t      // provoke redistribution on insertion point parents\n\t\t      // must do this on all candidate hosts since distribution in this\n\t\t      // scope invalidates their distribution.\n\t\t      // only get logical parent.\n\t\t      var parent = tree.Logical.getParentNode(p);\n\t\t      if (parent && parent.shadyRoot &&\n\t\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t\t        dirtyRoots.push(parent.shadyRoot);\n\t\t      }\n\t\t    }\n\t\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t\t      var p$1 = pool[i$1];\n\t\t      if (p$1) {\n\t\t        p$1._assignedSlot = undefined;\n\t\t        // remove undistributed elements from physical dom.\n\t\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t\t        if (parent$1) {\n\t\t          tree.Composed.removeChild(parent$1, p$1);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return dirtyRoots;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t\t    if (prevAssignedNodes) {\n\t\t      this.clearAssignedSlots(insertionPoint, true);\n\t\t    }\n\t\t    insertionPoint._assignedNodes = [];\n\t\t    var needsSlotChange = false;\n\t\t    // distribute nodes from the pool that this selector matches\n\t\t    var anyDistributed = false;\n\t\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t\t      node=pool[i];\n\t\t      // skip nodes that were already used\n\t\t      if (!node) {\n\t\t        continue;\n\t\t      }\n\t\t      // distribute this node if it matches\n\t\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node, insertionPoint)\n\t\t        // remove this node from the pool\n\t\t        pool[i] = undefined;\n\t\t        // since at least one node matched, we won't need fallback content\n\t\t        anyDistributed = true;\n\t\t      }\n\t\t    }\n\t\t    // Fallback content if nothing was distributed here\n\t\t    if (!anyDistributed) {\n\t\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t\t      for (var j = 0, node$1; j < children.length; j++) {\n\t\t        node$1 = children[j];\n\t\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t\t      }\n\t\t    }\n\t\t    // we're already dirty if a node was newly added to the slot\n\t\t    // and we're also dirty if the assigned count decreased.\n\t\t    if (prevAssignedNodes) {\n\t\t      // TODO(sorvell): the tracking of previously assigned slots\n\t\t      // could instead by done with a Set and then we could\n\t\t      // avoid needing to iterate here to clear the info.\n\t\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t\t      }\n\t\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t\t        needsSlotChange = true;\n\t\t      }\n\t\t    }\n\t\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t\t    if (needsSlotChange) {\n\t\t      this._fireSlotChange(insertionPoint);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t\t    var n$ = slot._assignedNodes;\n\t\t    if (n$) {\n\t\t      for (var i=0; i < n$.length; i++) {\n\t\t        var n = n$[i];\n\t\t        if (savePrevious) {\n\t\t          n.__prevAssignedSlot = n._assignedSlot;\n\t\t        }\n\t\t        // only clear if it was previously set to this slot;\n\t\t        // this helps ensure that if the node has otherwise been distributed\n\t\t        // ignore it.\n\t\t        if (n._assignedSlot === slot) {\n\t\t          n._assignedSlot = null;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t\t    var slotName = insertionPoint.getAttribute('name');\n\t\t    slotName = slotName ? slotName.trim() : '';\n\t\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t\t    slot = slot ? slot.trim() : '';\n\t\t    return (slot == slotName);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t\t    insertionPoint._assignedNodes.push(child);\n\t\t    child._assignedSlot = insertionPoint;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n$ = insertionPoint._assignedNodes;\n\t\t    insertionPoint._distributedNodes = [];\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t\t      if (this$1.isInsertionPoint(n)) {\n\t\t        var d$ = n._distributedNodes;\n\t\t        if (d$) {\n\t\t          for (var j=0; j < d$.length; j++) {\n\t\t            insertionPoint._distributedNodes.push(d$[j]);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        insertionPoint._distributedNodes.push(n$[i]);\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t\t    // Safari tech preview does not bubble but chrome does\n\t\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t\t    if (insertionPoint._assignedSlot) {\n\t\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t\t    return !(insertionPoint._assignedSlot);\n\t\t  };\n\t\t\n\t\t  return anonymous;\n\t\t}())\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t\t  polyfill across browsers.\n\t\t*/\n\t\tvar ShadyRoot = function ShadyRoot(host) {\n\t\t  if (!host) {\n\t\t    throw 'Must provide a host';\n\t\t  }\n\t\t  // NOTE: this strange construction is necessary because\n\t\t  // DocumentFragment cannot be subclassed on older browsers.\n\t\t  var frag = document.createDocumentFragment();\n\t\t  frag.__proto__ = ShadyFragmentMixin;\n\t\t  frag._init(host);\n\t\t  return frag;\n\t\t};\n\t\t\n\t\tvar ShadyMixin = {\n\t\t\n\t\t  _init: function _init(host) {\n\t\t    // NOTE: set a fake local name so this element can be\n\t\t    // distinguished from a DocumentFragment when patching.\n\t\t    // FF doesn't allow this to be `localName`\n\t\t    this.__localName = 'ShadyRoot';\n\t\t    // root <=> host\n\t\t    host.shadyRoot = this;\n\t\t    this.host = host;\n\t\t    // logical dom setup\n\t\t    tree.Logical.saveChildNodes(host);\n\t\t    tree.Logical.saveChildNodes(this);\n\t\t    // state flags\n\t\t    this._clean = true;\n\t\t    this._hasRendered = false;\n\t\t    this._distributor = new Distributor(this);\n\t\t    this.update();\n\t\t  },\n\t\t\n\t\t  // async render the \"top\" distributor (this is all that is needed to\n\t\t  // distribute this host).\n\t\t  update: function update() {\n\t\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t\t    if (distributionRoot._clean) {\n\t\t      distributionRoot._clean = false;\n\t\t      enqueue(function() {\n\t\t        distributionRoot.render();\n\t\t      });\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t\t  // this should only return a shadowRoot.\n\t\t  // returns the host that's the top of this host's distribution tree\n\t\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t\t    var root = element.shadyRoot;\n\t\t    while (element && this._elementNeedsDistribution(element)) {\n\t\t      root = element.getRootNode();\n\t\t      element = root && root.host;\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  // Return true if a host's children includes\n\t\t  // an insertion point that selects selectively\n\t\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = tree.Logical.getChildNodes(element);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t\t        return element.getRootNode();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  render: function render() {\n\t\t    if (!this._clean) {\n\t\t      this._clean = true;\n\t\t      if (!this._skipUpdateInsertionPoints) {\n\t\t        this.updateInsertionPoints();\n\t\t      } else if (!this._hasRendered) {\n\t\t        this._insertionPoints = [];\n\t\t      }\n\t\t      this._skipUpdateInsertionPoints = false;\n\t\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t\t      // that would avoid distribution for initial render if\n\t\t      // no insertion points exist. We cannot currently do this because\n\t\t      // it relies on elements being in the physical shadowRoot element\n\t\t      // so that native methods will be used. The current append code\n\t\t      // simply provokes distribution in this case and does not put the\n\t\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t\t      // consider if the special processing is worth the perf gain.\n\t\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t\t      //   tree.Composed.clearChildNodes(this.host);\n\t\t      //   tree.Composed.appendChild(this.host, this);\n\t\t      // } else {\n\t\t      // logical\n\t\t      this.distribute();\n\t\t      // physical\n\t\t      this.compose();\n\t\t      this._hasRendered = true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  forceRender: function forceRender() {\n\t\t    this._clean = false;\n\t\t    this.render();\n\t\t  },\n\t\t\n\t\t  distribute: function distribute() {\n\t\t    var dirtyRoots = this._distributor.distribute();\n\t\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t\t      dirtyRoots[i].forceRender();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  updateInsertionPoints: function updateInsertionPoints() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var i$ = this.__insertionPoints;\n\t\t    // if any insertion points have been removed, clear their distribution info\n\t\t    if (i$) {\n\t\t      for (var i=0, c; i < i$.length; i++) {\n\t\t        c = i$[i];\n\t\t        if (c.getRootNode() !== this$1) {\n\t\t          this$1._distributor.clearAssignedSlots(c);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t\t    // ensure insertionPoints's and their parents have logical dom info.\n\t\t    // save logical tree info\n\t\t    // a. for shadyRoot\n\t\t    // b. for insertion points (fallback)\n\t\t    // c. for parents of insertion points\n\t\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t\t      c$1 = i$[i$1];\n\t\t      tree.Logical.saveChildNodes(c$1);\n\t\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  get _insertionPoints() {\n\t\t    if (!this.__insertionPoints) {\n\t\t      this.updateInsertionPoints();\n\t\t    }\n\t\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t\t  },\n\t\t\n\t\t  set _insertionPoints(insertionPoints) {\n\t\t    this.__insertionPoints = insertionPoints;\n\t\t  },\n\t\t\n\t\t  hasInsertionPoint: function hasInsertionPoint() {\n\t\t    return this._distributor.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  compose: function compose() {\n\t\t    // compose self\n\t\t    // note: it's important to mark this clean before distribution\n\t\t    // so that attachment that provokes additional distribution (e.g.\n\t\t    // adding something to your parentNode) works\n\t\t    this._composeTree();\n\t\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t\t    // (these seem unnecessary)\n\t\t  },\n\t\t\n\t\t  // Reify dom such that it is at its correct rendering position\n\t\t  // based on logical distribution.\n\t\t  _composeTree: function _composeTree() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t\t    var p$ = this._insertionPoints || [];\n\t\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t\t      parent = tree.Logical.getParentNode(p);\n\t\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // Returns the list of nodes which should be rendered inside `node`.\n\t\t  _composeNode: function _composeNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var children = [];\n\t\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t\t    for (var i = 0; i < c$.length; i++) {\n\t\t      var child = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t\t        var distributedNodes = child._distributedNodes ||\n\t\t          (child._distributedNodes = []);\n\t\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t\t          var distributedNode = distributedNodes[j];\n\t\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t\t            children.push(distributedNode);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        children.push(child);\n\t\t      }\n\t\t    }\n\t\t    return children;\n\t\t  },\n\t\t\n\t\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t\t    return this._distributor.isFinalDestination(\n\t\t      insertionPoint, node);\n\t\t  },\n\t\t\n\t\t  // Ensures that the rendered node list inside `container` is `children`.\n\t\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t\t    var composed = tree.Composed.getChildNodes(container);\n\t\t    var splices = calculateSplices(children, composed);\n\t\t    // process removals\n\t\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t\t        // check if the node is still where we expect it is before trying\n\t\t        // to remove it; this can happen if we move a node and\n\t\t        // then schedule its previous host for distribution resulting in\n\t\t        // the node being removed here.\n\t\t        if (tree.Composed.getParentNode(n) === container) {\n\t\t          tree.Composed.removeChild(container, n);\n\t\t        }\n\t\t        composed.splice(s.index + d, 1);\n\t\t      }\n\t\t      d -= s.addedCount;\n\t\t    }\n\t\t    // process adds\n\t\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t\t      next = composed[s$1.index];\n\t\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t\t        n$1 = children[j$1];\n\t\t        tree.Composed.insertBefore(container, n$1, next);\n\t\t        // TODO(sorvell): is this splice strictly needed?\n\t\t        composed.splice(j$1, 0, n$1);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  getInsertionPointTag: function getInsertionPointTag() {\n\t\t    return this._distributor.insertionPointTag;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\t\textend(ShadyFragmentMixin, ShadyMixin);\n\t\t\n\t\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\t\n\t\t// function upgradeLogicalChildren(children) {\n\t\t//   if (needsUpgrade && children) {\n\t\t//     for (let i=0; i < children.length; i++) {\n\t\t//       CustomElements.upgrade(children[i]);\n\t\t//     }\n\t\t//   }\n\t\t// }\n\t\t\n\t\t// render enqueuer/flusher\n\t\tvar customElements = window.customElements;\n\t\tvar flushList = [];\n\t\tvar scheduled;\n\t\tvar flushCount = 0;\n\t\tvar flushMax = 100;\n\t\tfunction enqueue(callback) {\n\t\t  if (!scheduled) {\n\t\t    scheduled = true;\n\t\t    promish.then(flush$1);\n\t\t  }\n\t\t  flushList.push(callback);\n\t\t}\n\t\t\n\t\tfunction flush$1() {\n\t\t  scheduled = false;\n\t\t  flushCount++;\n\t\t  while (flushList.length) {\n\t\t    flushList.shift()();\n\t\t  }\n\t\t  if (customElements && customElements.flush) {\n\t\t    customElements.flush();\n\t\t  }\n\t\t  // continue flushing after elements are upgraded...\n\t\t  var isFlushedMaxed = (flushCount > flushMax);\n\t\t  if (flushList.length && !isFlushedMaxed) {\n\t\t      flush$1();\n\t\t  }\n\t\t  flushCount = 0;\n\t\t  if (isFlushedMaxed) {\n\t\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t\t  }\n\t\t}\n\t\t\n\t\tflush$1.list = flushList;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// Cribbed from ShadowDOM polyfill\n\t\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t\t/////////////////////////////////////////////////////////////////////////////\n\t\t// innerHTML and outerHTML\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\t\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\t\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\t\n\t\tfunction escapeReplace(c) {\n\t\t  switch (c) {\n\t\t    case '&':\n\t\t      return '&amp;';\n\t\t    case '<':\n\t\t      return '&lt;';\n\t\t    case '>':\n\t\t      return '&gt;';\n\t\t    case '\"':\n\t\t      return '&quot;';\n\t\t    case '\\u00A0':\n\t\t      return '&nbsp;';\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction escapeAttr(s) {\n\t\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction escapeData(s) {\n\t\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction makeSet(arr) {\n\t\t  var set = {};\n\t\t  for (var i = 0; i < arr.length; i++) {\n\t\t    set[arr[i]] = true;\n\t\t  }\n\t\t  return set;\n\t\t}\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\t\tvar voidElements = makeSet([\n\t\t  'area',\n\t\t  'base',\n\t\t  'br',\n\t\t  'col',\n\t\t  'command',\n\t\t  'embed',\n\t\t  'hr',\n\t\t  'img',\n\t\t  'input',\n\t\t  'keygen',\n\t\t  'link',\n\t\t  'meta',\n\t\t  'param',\n\t\t  'source',\n\t\t  'track',\n\t\t  'wbr'\n\t\t]);\n\t\t\n\t\tvar plaintextParents = makeSet([\n\t\t  'style',\n\t\t  'script',\n\t\t  'xmp',\n\t\t  'iframe',\n\t\t  'noembed',\n\t\t  'noframes',\n\t\t  'plaintext',\n\t\t  'noscript'\n\t\t]);\n\t\t\n\t\tfunction getOuterHTML(node, parentNode, composed) {\n\t\t  switch (node.nodeType) {\n\t\t    case Node.ELEMENT_NODE: {\n\t\t      var tagName = node.localName;\n\t\t      var s = '<' + tagName;\n\t\t      var attrs = node.attributes;\n\t\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t\t      }\n\t\t      s += '>';\n\t\t      if (voidElements[tagName]) {\n\t\t        return s;\n\t\t      }\n\t\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t\t    }\n\t\t    case Node.TEXT_NODE: {\n\t\t      var data = node.data;\n\t\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t\t        return data;\n\t\t      }\n\t\t      return escapeData(data);\n\t\t    }\n\t\t    case Node.COMMENT_NODE: {\n\t\t      return '<!--' + node.data + '-->';\n\t\t    }\n\t\t    default: {\n\t\t      window.console.error(node);\n\t\t      throw new Error('not implemented');\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction getInnerHTML(node, composed) {\n\t\t  if (node.localName === 'template') {\n\t\t    node = node.content;\n\t\t  }\n\t\t  var s = '';\n\t\t  var c$ = composed ? composed(node) : node.childNodes;\n\t\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t\t    s += getOuterHTML(child, node, composed);\n\t\t  }\n\t\t  return s;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar mixinImpl = {\n\t\t\n\t\t  // Try to add node. Record logical info, track insertion points, perform\n\t\t  // distribution iff needed. Return true if the add is handled.\n\t\t  addNode: function addNode(container, node, ref_node) {\n\t\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t\t    if (ownerRoot) {\n\t\t      // optimization: special insertion point tracking\n\t\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t\t      }\n\t\t      // note: we always need to see if an insertion point is added\n\t\t      // since this saves logical tree info; however, invalidation state\n\t\t      // needs\n\t\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t\t      // invalidate insertion points IFF not already invalid!\n\t\t      if (ipAdded) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t      }\n\t\t    }\n\t\t    if (tree.Logical.hasChildNodes(container)) {\n\t\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t\t    }\n\t\t    // if not distributing and not adding to host, do a fast path addition\n\t\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t\t      container.shadyRoot;\n\t\t    return handled;\n\t\t  },\n\t\t\n\t\t  // Try to remove node: update logical info and perform distribution iff\n\t\t  // needed. Return true if the removal has been handled.\n\t\t  // note that it's possible for both the node's host and its parent\n\t\t  // to require distribution... both cases are handled here.\n\t\t  removeNode: function removeNode(node) {\n\t\t    // important that we want to do this only if the node has a logical parent\n\t\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t\t      tree.Logical.getParentNode(node);\n\t\t    var distributed;\n\t\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t\t    if (logicalParent) {\n\t\t      // distribute node's parent iff needed\n\t\t      distributed = this.maybeDistributeParent(node);\n\t\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t\t      // remove node from root and distribute it iff needed\n\t\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    this._removeOwnerShadyRoot(node);\n\t\t    return distributed;\n\t\t  },\n\t\t\n\t\t\n\t\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t\t    var observer = node.__dom && node.__dom.observer;\n\t\t    if (observer) {\n\t\t      if (addedNode) {\n\t\t        observer.addedNodes.push(addedNode);\n\t\t      }\n\t\t      if (removedNode) {\n\t\t        observer.removedNodes.push(removedNode);\n\t\t      }\n\t\t      observer.schedule();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t\t    if (parent) {\n\t\t      this._scheduleObserver(parent, null, node);\n\t\t      this.removeNode(node);\n\t\t    } else {\n\t\t      this._removeOwnerShadyRoot(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t\t  },\n\t\t\n\t\t  getRootNode: function getRootNode$1(node) {\n\t\t    if (!node || !node.nodeType) {\n\t\t      return;\n\t\t    }\n\t\t    var root = node.__ownerShadyRoot;\n\t\t    if (root === undefined) {\n\t\t      if (isShadyRoot(node)) {\n\t\t        root = node;\n\t\t      } else {\n\t\t        var parent = tree.Logical.getParentNode(node);\n\t\t        root = parent ? this.getRootNode(parent) : node;\n\t\t      }\n\t\t      // memo-ize result for performance but only memo-ize\n\t\t      // result if node is in the document. This avoids a problem where a root\n\t\t      // can be cached while an element is inside a fragment.\n\t\t      // If this happens and we cache the result, the value can become stale\n\t\t      // because for perf we avoid processing the subtree of added fragments.\n\t\t      if (document.documentElement.contains(node)) {\n\t\t        node.__ownerShadyRoot = root;\n\t\t      }\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t\t    var root = this.getRootNode(node);\n\t\t    if (isShadyRoot(root)) {\n\t\t      return root;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t\t    // <content> children but since this case is assumed to be exceedingly\n\t\t    // rare, we avoid the cost and will address with some specific api\n\t\t    // when the need arises.  For now, the user must call\n\t\t    // distributeContent(true), which updates insertion points manually\n\t\t    // and forces distribution.\n\t\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t\t      !node.__noInsertionPoint &&\n\t\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t\t    var wrappedContent = fragContent &&\n\t\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t\t    // There are 3 possible cases where a distribution may need to occur:\n\t\t    // 1. <content> being inserted (the host of the shady root where\n\t\t    //    content is inserted needs distribution)\n\t\t    // 2. children being inserted into parent with a shady root (parent\n\t\t    //    needs distribution)\n\t\t    // 3. container is an insertionPoint\n\t\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t\t      if (ownerRoot) {\n\t\t        // note, insertion point list update is handled after node\n\t\t        // mutations are complete\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    var needsDist = this._nodeNeedsDistribution(container);\n\t\t    if (needsDist) {\n\t\t      container.shadyRoot.update();\n\t\t    }\n\t\t    // Return true when distribution will fully handle the composition\n\t\t    // Note that if a content was being inserted that was wrapped by a node,\n\t\t    // and the parent does not need distribution, return false to allow\n\t\t    // the nodes to be added directly, after which children may be\n\t\t    // distributed and composed into the wrapping node(s)\n\t\t    return needsDist || (hasContent && !wrappedContent);\n\t\t  },\n\t\t\n\t\t  /* note: parent argument is required since node may have an out\n\t\t  of date parent at this point; returns true if a <content> is being added */\n\t\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var added;\n\t\t    var insertionPointTag = root.getInsertionPointTag();\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t\t      !node.__noInsertionPoint) {\n\t\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        np = tree.Logical.getParentNode(n);\n\t\t        // don't allow node's parent to be fragment itself\n\t\t        if (np === node) {\n\t\t          np = parent;\n\t\t        }\n\t\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t\t        added = added || na;\n\t\t      }\n\t\t    } else if (node.localName === insertionPointTag) {\n\t\t      tree.Logical.saveChildNodes(parent);\n\t\t      tree.Logical.saveChildNodes(node);\n\t\t      added = true;\n\t\t    }\n\t\t    return added;\n\t\t  },\n\t\t\n\t\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t\t    return node && node.shadyRoot &&\n\t\t      node.shadyRoot.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var hostNeedsDist;\n\t\t    var ip$ = root._insertionPoints;\n\t\t    for (var i=0; i<ip$.length; i++) {\n\t\t      var insertionPoint = ip$[i];\n\t\t      if (this$1._contains(container, insertionPoint)) {\n\t\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t\t        for (var j=0; j<dc$.length; j++) {\n\t\t          hostNeedsDist = true;\n\t\t          var node = dc$[j];\n\t\t          var parent = tree.Composed.getParentNode(node);\n\t\t          if (parent) {\n\t\t            tree.Composed.removeChild(parent, node);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return hostNeedsDist;\n\t\t  },\n\t\t\n\t\t  _contains: function _contains(container, node) {\n\t\t    while (node) {\n\t\t      if (node == container) {\n\t\t        return true;\n\t\t      }\n\t\t      node = tree.Logical.getParentNode(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // optimization: only reset the tree if node is actually in a root\n\t\t    if (this._hasCachedOwnerRoot(node)) {\n\t\t      var c$ = tree.Logical.getChildNodes(node);\n\t\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t\t        this$1._removeOwnerShadyRoot(n);\n\t\t      }\n\t\t    }\n\t\t    node.__ownerShadyRoot = undefined;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): This will fail if distribution that affects this\n\t\t  // question is pending; this is expected to be exceedingly rare, but if\n\t\t  // the issue comes up, we can force a flush in this case.\n\t\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t\t    var root = this.getRootNode(insertionPoint);\n\t\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t\t      // means that we're composed to this spot.\n\t\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t\t        return n;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  clearNode: function clearNode(node) {\n\t\t    while (node.firstChild) {\n\t\t      node.removeChild(node.firstChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t\t    var parent = tree.Logical.getParentNode(node);\n\t\t    if (this._nodeNeedsDistribution(parent)) {\n\t\t      parent.shadyRoot.update();\n\t\t      return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t\t    if (name === 'slot') {\n\t\t      this.maybeDistributeParent(node);\n\t\t    } else if (node.localName === 'slot' && name === 'name') {\n\t\t      var root = this.ownerShadyRootForNode(node);\n\t\t      if (root) {\n\t\t        root.update();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t\t  // but it's also generally useful to recurse through the element tree\n\t\t  // and is used by Polymer's styling system.\n\t\t  query: function query(node, matcher, halter) {\n\t\t    var list = [];\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t    return list;\n\t\t  },\n\t\t\n\t\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t\t          this$1._queryElement(c, matcher, halter, list)) {\n\t\t        return true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t\t    var result = matcher(node);\n\t\t    if (result) {\n\t\t      list.push(node);\n\t\t    }\n\t\t    if (halter && halter(result)) {\n\t\t      return result;\n\t\t    }\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t  },\n\t\t\n\t\t  activeElementForNode: function activeElementForNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var active = document.activeElement;\n\t\t    if (!active) {\n\t\t      return null;\n\t\t    }\n\t\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t\t    if (node !== document) {\n\t\t      // If this node isn't a document or shady root, then it doesn't have\n\t\t      // an active element.\n\t\t      if (!isShadyRoot$$1) {\n\t\t        return null;\n\t\t      }\n\t\t      // If this shady root's host is the active element or the active\n\t\t      // element is not a descendant of the host (in the composed tree),\n\t\t      // then it doesn't have an active element.\n\t\t      if (node.host === active ||\n\t\t          !node.host.contains(active)) {\n\t\t        return null;\n\t\t      }\n\t\t    }\n\t\t    // This node is either the document or a shady root of which the active\n\t\t    // element is a (composed) descendant of its host; iterate upwards to\n\t\t    // find the active element's most shallow host within it.\n\t\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t\t    while (activeRoot && activeRoot !== node) {\n\t\t      active = activeRoot.host;\n\t\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t\t    }\n\t\t    if (node === document) {\n\t\t      // This node is the document, so activeRoot should be null.\n\t\t      return activeRoot ? null : active;\n\t\t    } else {\n\t\t      // This node is a non-document shady root, and it should be\n\t\t      // activeRoot.\n\t\t      return activeRoot === node ? active : null;\n\t\t    }\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar nativeCloneNode = Element.prototype.cloneNode;\n\t\tvar nativeImportNode = Document.prototype.importNode;\n\t\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\t\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\t\n\t\tvar setAttribute = function(attr, value) {\n\t\t  if (window.ShadyCSS && attr === 'class') {\n\t\t    window.ShadyCSS.setElementClass(this, value);\n\t\t  } else {\n\t\t    nativeSetAttribute.call(this, attr, value);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar NodeMixin = {};\n\t\t\n\t\tObject.defineProperties(NodeMixin, {\n\t\t\n\t\t  parentElement: {\n\t\t    get: function get() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  parentNode: {\n\t\t    get: function get$1() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextSibling: {\n\t\t    get: function get$2() {\n\t\t      return tree.Logical.getNextSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousSibling: {\n\t\t    get: function get$3() {\n\t\t      return tree.Logical.getPreviousSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextElementSibling: {\n\t\t    get: function get$4() {\n\t\t      return tree.Logical.getNextElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousElementSibling: {\n\t\t    get: function get$5() {\n\t\t      return tree.Logical.getPreviousElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  assignedSlot: {\n\t\t    get: function get$6() {\n\t\t      return this._assignedSlot;\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tvar FragmentMixin = {\n\t\t\n\t\t  appendChild: function appendChild(node) {\n\t\t    return this.insertBefore(node);\n\t\t  },\n\t\t\n\t\t  // cases in which we may not be able to just do standard native call\n\t\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t\t  // has an insertion point)\n\t\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t\t  // container to container.host.\n\t\t  // 3. node is <content> (host of container needs distribution)\n\t\t  insertBefore: function insertBefore(node, ref_node) {\n\t\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t\t        'of this node');\n\t\t    }\n\t\t    // remove node from its current position iff it's in a tree.\n\t\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var parent = tree.Logical.getParentNode(node);\n\t\t      mixinImpl.removeNodeFromParent(node, parent);\n\t\t    }\n\t\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t\t      if (ref_node) {\n\t\t        // if ref_node is an insertion point replace with first distributed node\n\t\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t\t        if (root) {\n\t\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t\t        }\n\t\t      }\n\t\t      // if adding to a shadyRoot, add to host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host : this;\n\t\t      if (ref_node) {\n\t\t        tree.Composed.insertBefore(container, node, ref_node);\n\t\t      } else {\n\t\t        tree.Composed.appendChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t    Removes the given `node` from the element's `lightChildren`.\n\t\t    This method also performs dom composition.\n\t\t  */\n\t\t  removeChild: function removeChild(node) {\n\t\t    if (tree.Logical.getParentNode(node) !== this) {\n\t\t      throw Error('The node to be removed is not a child of this node: ' +\n\t\t        node);\n\t\t    }\n\t\t    if (!mixinImpl.removeNode(node)) {\n\t\t      // if removing from a shadyRoot, remove form host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host :\n\t\t        this;\n\t\t      // not guaranteed to physically be in container; e.g.\n\t\t      // undistributed nodes.\n\t\t      var parent = tree.Composed.getParentNode(node);\n\t\t      if (container === parent) {\n\t\t        tree.Composed.removeChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, null, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  replaceChild: function replaceChild(node, ref_node) {\n\t\t    this.insertBefore(node, ref_node);\n\t\t    this.removeChild(ref_node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t\t  querySelector: function querySelector(selector) {\n\t\t    // match selector and halt on first result.\n\t\t    var result = mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    }, function(n) {\n\t\t      return Boolean(n);\n\t\t    })[0];\n\t\t    return result || null;\n\t\t  },\n\t\t\n\t\t  querySelectorAll: function querySelectorAll(selector) {\n\t\t    return mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    });\n\t\t  },\n\t\t\n\t\t  cloneNode: function cloneNode(deep) {\n\t\t    if (this.localName == 'template') {\n\t\t      return nativeCloneNode.call(this, deep);\n\t\t    } else {\n\t\t      var n = nativeCloneNode.call(this, false);\n\t\t      if (deep) {\n\t\t        var c$ = this.childNodes;\n\t\t        for (var i=0, nc; i < c$.length; i++) {\n\t\t          nc = c$[i].cloneNode(true);\n\t\t          n.appendChild(nc);\n\t\t        }\n\t\t      }\n\t\t      return n;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  importNode: function importNode(externalNode, deep) {\n\t\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t\t    var doc = this instanceof Document ? this :\n\t\t      this.ownerDocument;\n\t\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t\t    if (deep) {\n\t\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t\t      common.patchNode(n);\n\t\t      for (var i=0, nc; i < c$.length; i++) {\n\t\t        nc = doc.importNode(c$[i], true);\n\t\t        n.appendChild(nc);\n\t\t      }\n\t\t    }\n\t\t    return n;\n\t\t  }\n\t\t};\n\t\t\n\t\tObject.defineProperties(FragmentMixin, {\n\t\t\n\t\t  childNodes: {\n\t\t    get: function get$7() {\n\t\t      var c$ = tree.Logical.getChildNodes(this);\n\t\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  children: {\n\t\t    get: function get$8() {\n\t\t      if (tree.Logical.hasChildNodes(this)) {\n\t\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t\t        });\n\t\t      } else {\n\t\t        return tree.arrayCopyChildren(this);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstChild: {\n\t\t    get: function get$9() {\n\t\t      return tree.Logical.getFirstChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastChild: {\n\t\t    get: function get$10() {\n\t\t      return tree.Logical.getLastChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstElementChild: {\n\t\t    get: function get$11() {\n\t\t      return tree.Logical.getFirstElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastElementChild: {\n\t\t    get: function get$12() {\n\t\t      return tree.Logical.getLastElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t\t  // textContent / innerHTML\n\t\t  textContent: {\n\t\t    get: function get$13() {\n\t\t      if (this.childNodes) {\n\t\t        var tc = [];\n\t\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t\t            tc.push(c.textContent);\n\t\t          }\n\t\t        }\n\t\t        return tc.join('');\n\t\t      }\n\t\t      return '';\n\t\t    },\n\t\t    set: function set(text) {\n\t\t      mixinImpl.clearNode(this);\n\t\t      if (text) {\n\t\t        this.appendChild(document.createTextNode(text));\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  innerHTML: {\n\t\t    get: function get$14() {\n\t\t      return getInnerHTML(this);\n\t\t    },\n\t\t    set: function set$1(text) {\n\t\t      var this$1 = this;\n\t\t\n\t\t      mixinImpl.clearNode(this);\n\t\t      var d = document.createElement('div');\n\t\t      d.innerHTML = text;\n\t\t      // here, appendChild may move nodes async so we cannot rely\n\t\t      // on node position when copying\n\t\t      var c$ = tree.arrayCopyChildNodes(d);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1.appendChild(c$[i]);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar ElementMixin = {\n\t\t\n\t\t  // TODO(sorvell): should only exist on <slot>\n\t\t  assignedNodes: function assignedNodes(options) {\n\t\t    return (options && options.flatten ? this._distributedNodes :\n\t\t      this._assignedNodes) || [];\n\t\t  },\n\t\t\n\t\t\n\t\t  setAttribute: function setAttribute$1(name, value) {\n\t\t    setAttribute.call(this, name, value);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  },\n\t\t\n\t\t  removeAttribute: function removeAttribute(name) {\n\t\t    nativeRemoveAttribute.call(this, name);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tObject.defineProperties(ElementMixin, {\n\t\t\n\t\t  shadowRoot: {\n\t\t    get: function get$15() {\n\t\t      return this.shadyRoot;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  slot: {\n\t\t    get: function get$16() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set$2(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar activeElementDescriptor = {\n\t\t  get: function get$17() {\n\t\t    return mixinImpl.activeElementForNode(this);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar ActiveElementMixin = {};\n\t\tObject.defineProperties(ActiveElementMixin, {\n\t\t  activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar UnderActiveElementMixin = {};\n\t\tObject.defineProperties(UnderActiveElementMixin, {\n\t\t  _activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar Mixins = {\n\t\t\n\t\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\t\n\t\t  Fragment: extendAll({__patched: 'Fragment'},\n\t\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\t\n\t\t  Element: extendAll({__patched: 'Element'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\t\n\t\t  // Note: activeElement cannot be patched on document!\n\t\t  Document: extendAll({__patched: 'Document'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\t\n\t\t};\n\t\t\n\t\tvar getRootNode = function(node) {\n\t\t  return mixinImpl.getRootNode(node);\n\t\t}\n\t\t\n\t\tfunction filterMutations(mutations, target) {\n\t\t  var targetRootNode = getRootNode(target);\n\t\t  return mutations.filter(function(mutation) {\n\t\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t\t    if (mutationInScope && mutation.addedNodes) {\n\t\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t\t        return (targetRootNode === getRootNode(n));\n\t\t      });\n\t\t      Object.defineProperty(mutation, 'addedNodes', {\n\t\t        value: nodes,\n\t\t        configurable: true\n\t\t      });\n\t\t    }\n\t\t    return mutationInScope &&\n\t\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t\t  });\n\t\t}\n\t\t\n\t\t// const promise = Promise.resolve();\n\t\t\n\t\tvar AsyncObserver = function AsyncObserver() {\n\t\t  this._scheduled = false;\n\t\t  this.addedNodes = [];\n\t\t  this.removedNodes = [];\n\t\t  this.callbacks = new Set();\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.schedule = function schedule () {\n\t\t    var this$1 = this;\n\t\t\n\t\t  if (!this._scheduled) {\n\t\t    this._scheduled = true;\n\t\t    promish.then(function () {\n\t\t      this$1.flush();\n\t\t    });\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.flush = function flush () {\n\t\t  if (this._scheduled) {\n\t\t    this._scheduled = false;\n\t\t    var mutations = this.takeRecords();\n\t\t    if (mutations.length) {\n\t\t      this.callbacks.forEach(function(cb) {\n\t\t        cb(mutations);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t\t    var mutations = [{\n\t\t      addedNodes: this.addedNodes,\n\t\t      removedNodes: this.removedNodes\n\t\t    }];\n\t\t    this.addedNodes = [];\n\t\t    this.removedNodes = [];\n\t\t    return mutations;\n\t\t  }\n\t\t  return [];\n\t\t};\n\t\t\n\t\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t\t// directly so that users do not have to fork their code.\n\t\t// Supporting the entire api may be challenging: e.g. filtering out\n\t\t// removed nodes in the wrong scope and seeing non-distributing\n\t\t// subtree child mutations.\n\t\tvar observeChildren = function(node, callback) {\n\t\t  common.patchNode(node);\n\t\t  if (!node.__dom.observer) {\n\t\t    node.__dom.observer = new AsyncObserver();\n\t\t  }\n\t\t  node.__dom.observer.callbacks.add(callback);\n\t\t  var observer = node.__dom.observer;\n\t\t  return {\n\t\t    _callback: callback,\n\t\t    _observer: observer,\n\t\t    _node: node,\n\t\t    takeRecords: function takeRecords() {\n\t\t      return observer.takeRecords()\n\t\t    }\n\t\t  };\n\t\t}\n\t\t\n\t\tvar unobserveChildren = function(handle) {\n\t\t  var observer = handle && handle._observer;\n\t\t  if (observer) {\n\t\t    observer.callbacks.delete(handle._callback);\n\t\t    if (!observer.callbacks.size) {\n\t\t      handle._node.__dom.observer = null;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tvar patchedCount = 0;\n\t\t\n\t\tvar log = false;\n\t\t\n\t\tvar patchImpl = {\n\t\t\n\t\t  canPatchNode: function(node) {\n\t\t    switch (node) {\n\t\t      case document.head:\n\t\t      case document.documentElement:\n\t\t        return false;\n\t\t      default:\n\t\t        return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t\t    window.Node.prototype, 'textContent')),\n\t\t\n\t\t  patch: function(node) {\n\t\t    patchedCount++;\n\t\t    log && window.console.warn('patch node', node);\n\t\t    if (this.hasPrototypeDescriptors) {\n\t\t      patchPrototype(node, this.mixinForObject(node));\n\t\t    } else {\n\t\t      window.console.warn('Patching instance rather than prototype', node);\n\t\t      extend(node, this.mixinForNode(node));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  mixinForObject: function(obj) {\n\t\t    switch (obj.nodeType) {\n\t\t      case Node.ELEMENT_NODE:\n\t\t        return Mixins.Element;\n\t\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t\t        return Mixins.Fragment;\n\t\t      case Node.DOCUMENT_NODE:\n\t\t        return Mixins.Document;\n\t\t      case Node.TEXT_NODE:\n\t\t      case Node.COMMENT_NODE:\n\t\t        return Mixins.Node;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  unpatch: function(obj) {\n\t\t    if (obj.__sourceProto) {\n\t\t      obj.__proto__ = obj.__sourceProto;\n\t\t\n\t\t    }\n\t\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction patchNode(node) {\n\t\t  if (!settings.inUse) {\n\t\t    return;\n\t\t  }\n\t\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t\t    tree.saveChildNodes(node);\n\t\t    patchImpl.patch(node);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction unpatchNode(node) {\n\t\t  patchImpl.unpatch(node);\n\t\t}\n\t\t\n\t\tfunction isNodePatched(node) {\n\t\t  return Boolean(node.__patched);\n\t\t}\n\t\t\n\t\t// TODO(sorvell): fake export\n\t\tcommon.patchNode = patchNode;\n\t\tcommon.isNodePatched = isNodePatched;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar origAddEventListener = Element.prototype.addEventListener;\n\t\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\t\n\t\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\t\tvar alwaysComposed = {\n\t\t  blur: true,\n\t\t  focus: true,\n\t\t  focusin: true,\n\t\t  focusout: true,\n\t\t  click: true,\n\t\t  dblclick: true,\n\t\t  mousedown: true,\n\t\t  mouseenter: true,\n\t\t  mouseleave: true,\n\t\t  mousemove: true,\n\t\t  mouseout: true,\n\t\t  mouseover: true,\n\t\t  mouseup: true,\n\t\t  wheel: true,\n\t\t  beforeinput: true,\n\t\t  input: true,\n\t\t  keydown: true,\n\t\t  keyup: true,\n\t\t  compositionstart: true,\n\t\t  compositionupdate: true,\n\t\t  compositionend: true,\n\t\t  touchstart: true,\n\t\t  touchend: true,\n\t\t  touchmove: true,\n\t\t  touchcancel: true,\n\t\t  pointerover: true,\n\t\t  pointerenter: true,\n\t\t  pointerdown: true,\n\t\t  pointermove: true,\n\t\t  pointerup: true,\n\t\t  pointercancel: true,\n\t\t  pointerout: true,\n\t\t  pointerleave: true,\n\t\t  gotpointercapture: true,\n\t\t  lostpointercapture: true,\n\t\t  dragstart: true,\n\t\t  drag: true,\n\t\t  dragenter: true,\n\t\t  dragleave: true,\n\t\t  dragover: true,\n\t\t  drop: true,\n\t\t  dragend: true,\n\t\t  DOMActivate: true,\n\t\t  DOMFocusIn: true,\n\t\t  DOMFocusOut: true,\n\t\t  keypress: true\n\t\t};\n\t\t\n\t\tfunction pathComposer(startNode, composed) {\n\t\t  var composedPath = [];\n\t\t  var current = startNode;\n\t\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t\t  while (current) {\n\t\t    composedPath.push(current);\n\t\t    if (current.assignedSlot) {\n\t\t      current = current.assignedSlot;\n\t\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t\t      current = current.host;\n\t\t    } else {\n\t\t      current = current.parentNode;\n\t\t    }\n\t\t  }\n\t\t  // event composedPath includes window when startNode's ownerRoot is document\n\t\t  if (composedPath[composedPath.length - 1] === document) {\n\t\t    composedPath.push(window);\n\t\t  }\n\t\t  return composedPath;\n\t\t}\n\t\t\n\t\tfunction retarget(refNode, path) {\n\t\t  if (!isShadyRoot) {\n\t\t    return refNode;\n\t\t  }\n\t\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t\t  var refNodePath = pathComposer(refNode, true);\n\t\t  var p$ = path;\n\t\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t\t    ancestor = p$[i];\n\t\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t\t    if (root !== lastRoot) {\n\t\t      rootIdx = refNodePath.indexOf(root);\n\t\t      lastRoot = root;\n\t\t    }\n\t\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t\t      return ancestor;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tvar EventMixin = {\n\t\t\n\t\t  __patched: 'Event',\n\t\t\n\t\t  get composed() {\n\t\t    if (this.isTrusted && this.__composed === undefined) {\n\t\t      this.__composed = alwaysComposed[this.type];\n\t\t    }\n\t\t    return this.__composed || false;\n\t\t  },\n\t\t\n\t\t  composedPath: function composedPath() {\n\t\t    if (!this.__composedPath) {\n\t\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t\t    }\n\t\t    return this.__composedPath;\n\t\t  },\n\t\t\n\t\t  get target() {\n\t\t    return retarget(this.currentTarget, this.composedPath());\n\t\t  },\n\t\t\n\t\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t\t  get relatedTarget() {\n\t\t    if (!this.__relatedTarget) {\n\t\t      return null;\n\t\t    }\n\t\t    if (!this.__relatedTargetComposedPath) {\n\t\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t\t    }\n\t\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t\t  },\n\t\t  stopPropagation: function stopPropagation() {\n\t\t    Event.prototype.stopPropagation.call(this);\n\t\t    this.__propagationStopped = true;\n\t\t  },\n\t\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t\t    Event.prototype.stopImmediatePropagation.call(this);\n\t\t    this.__immediatePropagationStopped = true;\n\t\t    this.__propagationStopped = true;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction mixinComposedFlag(Base) {\n\t\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t\t  // try to do `Base.call` with a dom construtor.\n\t\t  var klazz = function(type, options) {\n\t\t    var event = new Base(type, options);\n\t\t    event.__composed = options && Boolean(options.composed);\n\t\t    return event;\n\t\t  }\n\t\t  // put constructor properties on subclass\n\t\t  mixin(klazz, Base);\n\t\t  klazz.prototype = Base.prototype;\n\t\t  return klazz;\n\t\t}\n\t\t\n\t\tvar nonBubblingEventsToRetarget = {\n\t\t  focus: true,\n\t\t  blur: true\n\t\t};\n\t\t\n\t\tfunction fireHandlers(event, node, phase) {\n\t\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t\t    node.__handlers[event.type][phase];\n\t\t  if (hs) {\n\t\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t\t      fn.call(node, event);\n\t\t      if (event.__immediatePropagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction retargetNonBubblingEvent(e) {\n\t\t  var path = e.composedPath();\n\t\t  var node;\n\t\t  // override `currentTarget` to let patched `target` calculate correctly\n\t\t  Object.defineProperty(e, 'currentTarget', {\n\t\t    get: function() {\n\t\t      return node;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t  for (var i = path.length - 1; i >= 0; i--) {\n\t\t    node = path[i];\n\t\t    // capture phase fires all capture handlers\n\t\t    fireHandlers(e, node, 'capture');\n\t\t    if (e.__propagationStopped) {\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t\n\t\t  // set the event phase to `AT_TARGET` as in spec\n\t\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\t\n\t\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t\t  // keep track of the last seen owner root\n\t\t  var lastFiredRoot;\n\t\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t\t    node = path[i$1];\n\t\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t\t      fireHandlers(e, node, 'bubble');\n\t\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t\t      if (node !== window) {\n\t\t        lastFiredRoot = node.getRootNode();\n\t\t      }\n\t\t      if (e.__propagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t\t  // It's more efficient to store the node/type/options information as Array in\n\t\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  if (fn.__eventWrappers) {\n\t\t    // Stop if the wrapper function has already been created.\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  } else {\n\t\t    fn.__eventWrappers = [];\n\t\t  }\n\t\t\n\t\t  var wrapperFn = function(e) {\n\t\t    // Support `once` option.\n\t\t    if (once) {\n\t\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t\t    }\n\t\t    if (!e.__target) {\n\t\t      e.__target = e.target;\n\t\t      e.__relatedTarget = e.relatedTarget;\n\t\t      patchPrototype(e, EventMixin);\n\t\t    }\n\t\t    // There are two critera that should stop events from firing on this node\n\t\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t\t        if (e.target === e.relatedTarget) {\n\t\t          e.stopImmediatePropagation();\n\t\t          return;\n\t\t        }\n\t\t      }\n\t\t      return fn(e);\n\t\t    }\n\t\t  };\n\t\t  // Store the wrapper information.\n\t\t  fn.__eventWrappers.push({\n\t\t    node: this,\n\t\t    type: type,\n\t\t    capture: capture,\n\t\t    once: once,\n\t\t    passive: passive,\n\t\t    wrapperFn: wrapperFn\n\t\t  });\n\t\t\n\t\t  if (nonBubblingEventsToRetarget[type]) {\n\t\t    this.__handlers = this.__handlers || {};\n\t\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t\t  } else {\n\t\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  // Search the wrapped function.\n\t\t  var wrapperFn = undefined;\n\t\t  if (fn.__eventWrappers) {\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t\t        // Cleanup.\n\t\t        if (!fn.__eventWrappers.length) {\n\t\t          fn.__eventWrappers = undefined;\n\t\t        }\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t\n\t\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t\t      this.__handlers && this.__handlers[type]) {\n\t\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t\t    var idx = arr.indexOf(wrapperFn);\n\t\t    if (idx > -1) {\n\t\t      arr.splice(idx, 1);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction activateFocusEventOverrides() {\n\t\t  for (var ev in nonBubblingEventsToRetarget) {\n\t\t    window.addEventListener(ev, function(e) {\n\t\t      if (!e.__target) {\n\t\t        e.__target = e.target;\n\t\t        e.__relatedTarget = e.relatedTarget;\n\t\t        patchPrototype(e, EventMixin);\n\t\t        retargetNonBubblingEvent(e);\n\t\t        e.stopImmediatePropagation();\n\t\t      }\n\t\t    }, true);\n\t\t  }\n\t\t}\n\t\t\n\t\t\n\t\tvar PatchedEvent = mixinComposedFlag(Event);\n\t\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\t\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tif (settings.inUse) {\n\t\t\n\t\t  window.ShadyDOM = {\n\t\t    tree: tree,\n\t\t    getNativeProperty: getNativeProperty,\n\t\t    patch: patchNode,\n\t\t    isPatched: isNodePatched,\n\t\t    unpatch: unpatchNode,\n\t\t    isShadyRoot: isShadyRoot,\n\t\t    enqueue: enqueue,\n\t\t    flush: flush$1,\n\t\t    inUse: settings.inUse,\n\t\t    filterMutations: filterMutations,\n\t\t    observeChildren: observeChildren,\n\t\t    unobserveChildren: unobserveChildren\n\t\t  };\n\t\t\n\t\t  var createRootAndEnsurePatched = function(node) {\n\t\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t\t    // a timing problem with gathering composed children.\n\t\t    // (1) currently the child list is crawled and patched when patching occurs\n\t\t    // (this needs to change)\n\t\t    // (2) we can only patch when an element has received its parsed children\n\t\t    // because we cannot detect them when inserted by parser.\n\t\t    // let ancestor = node;\n\t\t    // while (ancestor) {\n\t\t    //   patchNode(ancestor);\n\t\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t\t    // }\n\t\t    patchNode(node);\n\t\t    var root = new ShadyRoot(node);\n\t\t    patchNode(root);\n\t\t    return root;\n\t\t  }\n\t\t\n\t\t  Element.prototype.attachShadow = function() {\n\t\t    return createRootAndEnsurePatched(this);\n\t\t  }\n\t\t\n\t\t  Node.prototype.addEventListener = addEventListener;\n\t\t  Node.prototype.removeEventListener = removeEventListener;\n\t\t  Event = PatchedEvent;\n\t\t  CustomEvent = PatchedCustomEvent;\n\t\t  MouseEvent = PatchedMouseEvent;\n\t\t  activateFocusEventOverrides();\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t\t    get: function get() {\n\t\t      return document.documentElement.contains(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Node.prototype.getRootNode = function(options) {\n\t\t    return getRootNode(this, options);\n\t\t  }\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'slot', {\n\t\t    get: function get$1() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t\t    get: function get$2() {\n\t\t      return this._assignedSlot || null;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Element.prototype.setAttribute = setAttribute;\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'className', {\n\t\t    get: function get$3() {\n\t\t      return this.getAttribute('class');\n\t\t    },\n\t\t    set: function set$1(value) {\n\t\t      this.setAttribute('class', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t\t  // via appendChild. This either needs to be expanded or contracted.\n\t\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t\t  //   patchNode(this);\n\t\t  //   return this.appendChild(node);\n\t\t  // }\n\t\t\n\t\t}\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadydom.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tExtremely simple css parser. Intended to be not more than what we need\n\t\tand definitely not necessarily correct =).\n\t\t*/\n\t\t\n\t\t// given a string of css, return a simple rule tree\n\t\t\n\t\tfunction parse(text) {\n\t\t  text = clean(text);\n\t\t  return parseCss(lex(text), text);\n\t\t}\n\t\t\n\t\t// remove stuff we don't care about that may hinder parsing\n\t\tfunction clean(cssText) {\n\t\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t\t}\n\t\t\n\t\t// super simple {...} lexer that returns a node tree\n\t\tfunction lex(text) {\n\t\t  var root = {\n\t\t    start: 0,\n\t\t    end: text.length\n\t\t  };\n\t\t  var n = root;\n\t\t  for (var i = 0, l = text.length; i < l; i++) {\n\t\t    if (text[i] === OPEN_BRACE) {\n\t\t      if (!n.rules) {\n\t\t        n.rules = [];\n\t\t      }\n\t\t      var p = n;\n\t\t      var previous = p.rules[p.rules.length - 1];\n\t\t      n = {\n\t\t        start: i + 1,\n\t\t        parent: p,\n\t\t        previous: previous\n\t\t      };\n\t\t      p.rules.push(n);\n\t\t    } else if (text[i] === CLOSE_BRACE) {\n\t\t      n.end = i + 1;\n\t\t      n = n.parent || root;\n\t\t    }\n\t\t  }\n\t\t  return root;\n\t\t}\n\t\t\n\t\t// add selectors/cssText to node tree\n\t\tfunction parseCss(node, text) {\n\t\t  var t = text.substring(node.start, node.end - 1);\n\t\t  node.parsedCssText = node.cssText = t.trim();\n\t\t  if (node.parent) {\n\t\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t\t    t = text.substring(ss, node.start - 1);\n\t\t    t = _expandUnicodeEscapes(t);\n\t\t    t = t.replace(RX.multipleSpaces, ' ');\n\t\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t\t    // helps with mixin syntax\n\t\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t\t    var s = node.parsedSelector = node.selector = t.trim();\n\t\t    node.atRule = s.indexOf(AT_START) === 0;\n\t\t    // note, support a subset of rule types...\n\t\t    if (node.atRule) {\n\t\t      if (s.indexOf(MEDIA_START) === 0) {\n\t\t        node.type = types.MEDIA_RULE;\n\t\t      } else if (s.match(RX.keyframesRule)) {\n\t\t        node.type = types.KEYFRAMES_RULE;\n\t\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t\t      }\n\t\t    } else {\n\t\t      if (s.indexOf(VAR_START) === 0) {\n\t\t        node.type = types.MIXIN_RULE;\n\t\t      } else {\n\t\t        node.type = types.STYLE_RULE;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      parseCss(r, text);\n\t\t    }\n\t\t  }\n\t\t  return node;\n\t\t}\n\t\t\n\t\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t\t// expanded form that doesn't require trailing space `\\000033`\n\t\tfunction _expandUnicodeEscapes(s) {\n\t\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t\t    var code = arguments[1],\n\t\t        repeat = 6 - code.length;\n\t\t    while (repeat--) {\n\t\t      code = '0' + code;\n\t\t    }\n\t\t    return '\\\\' + code;\n\t\t  });\n\t\t}\n\t\t\n\t\t// stringify parsed css.\n\t\tfunction stringify(node, preserveProperties, text) {\n\t\t  text = text || '';\n\t\t  // calc rule cssText\n\t\t  var cssText = '';\n\t\t  if (node.cssText || node.rules) {\n\t\t    var r$ = node.rules;\n\t\t    if (r$ && !_hasMixinRules(r$)) {\n\t\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t        cssText = stringify(r, preserveProperties, cssText);\n\t\t      }\n\t\t    } else {\n\t\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t\t      cssText = cssText.trim();\n\t\t      if (cssText) {\n\t\t        cssText = '  ' + cssText + '\\n';\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  // emit rule if there is cssText\n\t\t  if (cssText) {\n\t\t    if (node.selector) {\n\t\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t\t    }\n\t\t    text += cssText;\n\t\t    if (node.selector) {\n\t\t      text += CLOSE_BRACE + '\\n\\n';\n\t\t    }\n\t\t  }\n\t\t  return text;\n\t\t}\n\t\t\n\t\tfunction _hasMixinRules(rules) {\n\t\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t\t}\n\t\t\n\t\tfunction removeCustomProps(cssText) {\n\t\t  cssText = removeCustomPropAssignment(cssText);\n\t\t  return removeCustomPropApply(cssText);\n\t\t}\n\t\t\n\t\tfunction removeCustomPropAssignment(cssText) {\n\t\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t\t}\n\t\t\n\t\tfunction removeCustomPropApply(cssText) {\n\t\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t\t}\n\t\t\n\t\tvar types = {\n\t\t  STYLE_RULE: 1,\n\t\t  KEYFRAMES_RULE: 7,\n\t\t  MEDIA_RULE: 4,\n\t\t  MIXIN_RULE: 1000\n\t\t};\n\t\t\n\t\tvar OPEN_BRACE = '{';\n\t\tvar CLOSE_BRACE = '}';\n\t\t\n\t\t// helper regexp's\n\t\tvar RX = {\n\t\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t\t  port: /@import[^;]*;/gim,\n\t\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t\t  multipleSpaces: /\\s+/g\n\t\t};\n\t\t\n\t\tvar VAR_START = '--';\n\t\tvar MEDIA_START = '@media';\n\t\tvar AT_START = '@';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\t\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\t\n\t\t// experimental support for native @apply\n\t\tfunction detectNativeApply() {\n\t\t  var style = document.createElement('style');\n\t\t  style.textContent = '.foo { @apply --foo }';\n\t\t  document.head.appendChild(style);\n\t\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t\t  document.head.removeChild(style);\n\t\t  return nativeCssApply;\n\t\t}\n\t\t\n\t\tvar nativeCssApply = false && detectNativeApply();\n\t\t\n\t\tfunction parseSettings(settings) {\n\t\t  if (settings) {\n\t\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t\t  }\n\t\t}\n\t\t\n\t\tif (window.ShadyCSS) {\n\t\t  parseSettings(window.ShadyCSS);\n\t\t} else if (window.WebComponents) {\n\t\t  parseSettings(window.WebComponents.flags);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction toCssText(rules, callback) {\n\t\t  if (typeof rules === 'string') {\n\t\t    rules = parse(rules);\n\t\t  }\n\t\t  if (callback) {\n\t\t    forEachRule(rules, callback);\n\t\t  }\n\t\t  return stringify(rules, nativeCssVariables);\n\t\t}\n\t\t\n\t\tfunction rulesForStyle(style) {\n\t\t  if (!style.__cssRules && style.textContent) {\n\t\t    style.__cssRules = parse(style.textContent);\n\t\t  }\n\t\t  return style.__cssRules;\n\t\t}\n\t\t\n\t\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t\t// like a normal selector but is not (it has nothing to do with scoping\n\t\t// for example).\n\t\tfunction isKeyframesSelector(rule) {\n\t\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t\t}\n\t\t\n\t\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t\t  if (!node) {\n\t\t    return;\n\t\t  }\n\t\t  var skipRules = false;\n\t\t  if (onlyActiveRules) {\n\t\t    if (node.type === types.MEDIA_RULE) {\n\t\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t\t      if (matchMedia) {\n\t\t        // if rule is a non matching @media rule, skip subrules\n\t\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t\t          skipRules = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  if (node.type === types.STYLE_RULE) {\n\t\t    styleRuleCallback(node);\n\t\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t\t    keyframesRuleCallback(node);\n\t\t  } else if (node.type === types.MIXIN_RULE) {\n\t\t    skipRules = true;\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$ && !skipRules) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t// add a string of cssText to the document.\n\t\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t\t  var style = createScopeStyle(cssText, moniker);\n\t\t  return applyStyle$1(style, target, contextNode);\n\t\t}\n\t\t\n\t\tfunction applyStyle$1(style, target, contextNode) {\n\t\t  target = target || document.head;\n\t\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t\t  lastHeadApplyNode = style;\n\t\t  return target.insertBefore(style, after);\n\t\t}\n\t\t\n\t\tfunction createScopeStyle(cssText, moniker) {\n\t\t  var style = document.createElement('style');\n\t\t  if (moniker) {\n\t\t    style.setAttribute('scope', moniker);\n\t\t  }\n\t\t  style.textContent = cssText;\n\t\t  return style;\n\t\t}\n\t\t\n\t\tvar lastHeadApplyNode = null;\n\t\t\n\t\t// insert a comment node as a styling position placeholder.\n\t\tfunction applyStylePlaceHolder(moniker) {\n\t\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t\t  var scope = document.head;\n\t\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t\t  lastHeadApplyNode = placeHolder;\n\t\t  return placeHolder;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t// cssBuildTypeForModule: function (module) {\n\t\t//   let dm = Polymer.DomModule.import(module);\n\t\t//   if (dm) {\n\t\t//     return getCssBuildType(dm);\n\t\t//   }\n\t\t// },\n\t\t//\n\t\t\n\t\t\n\t\t// Walk from text[start] matching parens\n\t\t// returns position of the outer end paren\n\t\tfunction findMatchingParen(text, start) {\n\t\t  var level = 0;\n\t\t  for (var i = start, l = text.length; i < l; i++) {\n\t\t    if (text[i] === '(') {\n\t\t      level++;\n\t\t    } else if (text[i] === ')') {\n\t\t      if (--level === 0) {\n\t\t        return i;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return -1;\n\t\t}\n\t\t\n\t\tfunction processVariableAndFallback(str, callback) {\n\t\t  // find 'var('\n\t\t  var start = str.indexOf('var(');\n\t\t  if (start === -1) {\n\t\t    // no var?, everything is prefix\n\t\t    return callback(str, '', '', '');\n\t\t  }\n\t\t  //${prefix}var(${inner})${suffix}\n\t\t  var end = findMatchingParen(str, start + 3);\n\t\t  var inner = str.substring(start + 4, end);\n\t\t  var prefix = str.substring(0, start);\n\t\t  // suffix may have other variables\n\t\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t\t  var comma = inner.indexOf(',');\n\t\t  // value and fallback args should be trimmed to match in property lookup\n\t\t  if (comma === -1) {\n\t\t    // variable, no fallback\n\t\t    return callback(prefix, inner.trim(), '', suffix);\n\t\t  }\n\t\t  // var(${value},${fallback})\n\t\t  var value = inner.substring(0, comma).trim();\n\t\t  var fallback = inner.substring(comma + 1).trim();\n\t\t  return callback(prefix, value, fallback, suffix);\n\t\t}\n\t\t\n\t\tvar rx = {\n\t\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t\t  IS_VAR: /^--/,\n\t\t  BRACKETED: /\\{[^}]*\\}/g,\n\t\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\t\n\t\t* scoping:\n\t\t\n\t\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t\t  * selectors re-written as follows:\n\t\t\n\t\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\t\n\t\t* :host -> scopeName\n\t\t\n\t\t* :host(...) -> scopeName...\n\t\t\n\t\t* ::slotted(...) -> scopeName > ...\n\t\t\n\t\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\t\n\t\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\t\n\t\t*/\n\t\tvar SCOPE_NAME = 'style-scope';\n\t\t\n\t\tvar StyleTransformer = {\n\t\t\n\t\t  // Given a node and scope name, add a scoping class to each node\n\t\t  // in the tree. This facilitates transforming css into scoped rules.\n\t\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t\t    // one time optimization to skip scoping...\n\t\t    if (node.__styleScoped) {\n\t\t      node.__styleScoped = null;\n\t\t    } else {\n\t\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t\t    if (node.classList) {\n\t\t      this.element(node, selector, shouldRemoveScope);\n\t\t    }\n\t\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t\t    if (c$) {\n\t\t      for (var i = 0; i < c$.length; i++) {\n\t\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  element: function element(_element, scope, shouldRemoveScope) {\n\t\t    // note: if using classes, we add both the general 'style-scope' class\n\t\t    // as well as the specific scope. This enables easy filtering of all\n\t\t    // `style-scope` elements\n\t\t    if (scope) {\n\t\t      // note: svg on IE does not have classList so fallback to class\n\t\t      if (_element.classList) {\n\t\t        if (shouldRemoveScope) {\n\t\t          _element.classList.remove(SCOPE_NAME);\n\t\t          _element.classList.remove(scope);\n\t\t        } else {\n\t\t          _element.classList.add(SCOPE_NAME);\n\t\t          _element.classList.add(scope);\n\t\t        }\n\t\t      } else if (_element.getAttribute) {\n\t\t        var c = _element.getAttribute(CLASS);\n\t\t        if (shouldRemoveScope) {\n\t\t          if (c) {\n\t\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t\t          }\n\t\t        } else {\n\t\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t\t    var cssBuildType = element.__cssBuild;\n\t\t    // no need to shim selectors if settings.useNativeShadow, also\n\t\t    // a shady css build will already have transformed selectors\n\t\t    // NOTE: This method may be called as part of static or property shimming.\n\t\t    // When there is a targeted build it will not be called for static shimming,\n\t\t    // but when the property shim is used it is called and should opt out of\n\t\t    // static shimming work when a proper build exists.\n\t\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t\t    return cssText.trim();\n\t\t  },\n\t\t\n\t\t  // Given a string of cssText and a scoping string (scope), returns\n\t\t  // a string of scoped css where each selector is transformed to include\n\t\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t\t  // (e.g. :host) to use the scoping selector.\n\t\t  css: function css(rules, scope, ext, callback) {\n\t\t    var hostScope = this._calcHostScope(scope, ext);\n\t\t    scope = this._calcElementScope(scope);\n\t\t    var self = this;\n\t\t    return toCssText(rules, function (rule) {\n\t\t      if (!rule.isScoped) {\n\t\t        self.rule(rule, scope, hostScope);\n\t\t        rule.isScoped = true;\n\t\t      }\n\t\t      if (callback) {\n\t\t        callback(rule, scope, hostScope);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _calcElementScope: function _calcElementScope(scope) {\n\t\t    if (scope) {\n\t\t      return CSS_CLASS_PREFIX + scope;\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t\t    return ext ? '[is=' + scope + ']' : scope;\n\t\t  },\n\t\t\n\t\t  rule: function rule(_rule, scope, hostScope) {\n\t\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  // transforms a css rule to a scoped rule.\n\t\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t\t    // against selectors (e.g. when calculating style properties)\n\t\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t\t    // we want to skip transformation of rules that appear in keyframes,\n\t\t    // because they are keyframe selectors, not element selectors.\n\t\t    if (!isKeyframesSelector(rule)) {\n\t\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t\t      }\n\t\t    }\n\t\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t\t  },\n\t\t\n\t\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t\t    var _this = this;\n\t\t\n\t\t    var stop = false;\n\t\t    selector = selector.trim();\n\t\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t\t    });\n\t\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t\t      if (!stop) {\n\t\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t\t        stop = stop || info.stop;\n\t\t        c = info.combinator;\n\t\t        s = info.value;\n\t\t      }\n\t\t      return c + s;\n\t\t    });\n\t\t    return selector;\n\t\t  },\n\t\t\n\t\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t\t    // replace :host with host scoping class\n\t\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t\t    if (selector.indexOf(HOST) >= 0) {\n\t\t      selector = this._transformHostSelector(selector, hostScope);\n\t\t      // replace other selectors with scoping class\n\t\t    } else if (slottedIndex !== 0) {\n\t\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t\t    }\n\t\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t\t    // also ignore left-side combinator\n\t\t    var slotted = false;\n\t\t    if (slottedIndex >= 0) {\n\t\t      combinator = '';\n\t\t      slotted = true;\n\t\t    }\n\t\t    // process scope jumping selectors up to the scope jump and then stop\n\t\t    var stop = void 0;\n\t\t    if (slotted) {\n\t\t      stop = true;\n\t\t      if (slotted) {\n\t\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t\t          return ' > ' + paren;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t\t    });\n\t\t    return { value: selector, combinator: combinator, stop: stop };\n\t\t  },\n\t\t\n\t\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t\t    p$[0] += scope;\n\t\t    return p$.join(PSEUDO_PREFIX);\n\t\t  },\n\t\t\n\t\t  // :host(...) -> scopeName...\n\t\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t\t    var m = selector.match(HOST_PAREN);\n\t\t    var paren = m && m[2].trim() || '';\n\t\t    if (paren) {\n\t\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t\t        // paren starts with a type selector\n\t\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t\t        // if the type selector is our hostScope then avoid pre-pending it\n\t\t        if (typeSelector === hostScope) {\n\t\t          return paren;\n\t\t          // otherwise, this selector should not match in this scope so\n\t\t          // output a bogus selector.\n\t\t        } else {\n\t\t          return SELECTOR_NO_MATCH;\n\t\t        }\n\t\t      } else {\n\t\t        // make sure to do a replace here to catch selectors like:\n\t\t        // `:host(.foo)::before`\n\t\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t\t          return hostScope + paren;\n\t\t        });\n\t\t      }\n\t\t      // if no paren, do a straight :host replacement.\n\t\t      // TODO(sorvell): this should not strictly be necessary but\n\t\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t\t      // which have been improperly used under Shady DOM. This should be\n\t\t      // deprecated.\n\t\t    } else {\n\t\t      return selector.replace(HOST, hostScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  documentRule: function documentRule(rule) {\n\t\t    // reset selector in case this is redone.\n\t\t    rule.selector = rule.parsedSelector;\n\t\t    this.normalizeRootSelector(rule);\n\t\t    this._transformRule(rule, this._transformDocumentSelector);\n\t\t  },\n\t\t\n\t\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t\t    if (rule.selector === ROOT) {\n\t\t      rule.selector = 'html';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t\t  },\n\t\t  SCOPE_NAME: SCOPE_NAME\n\t\t};\n\t\t\n\t\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\t\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\t\tvar COMPLEX_SELECTOR_SEP = ',';\n\t\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\t\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\t\tvar HOST = ':host';\n\t\tvar ROOT = ':root';\n\t\tvar SLOTTED = '::slotted';\n\t\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t\t// NOTE: this supports 1 nested () pair for things like\n\t\t// :host(:not([selected]), more general support requires\n\t\t// parsing which seems like overkill\n\t\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\t// similar to HOST_PAREN\n\t\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\t\tvar CSS_CLASS_PREFIX = '.';\n\t\tvar PSEUDO_PREFIX = ':';\n\t\tvar CLASS = 'class';\n\t\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\t\n\t\tvar classCallCheck = function (instance, Constructor) {\n\t\t  if (!(instance instanceof Constructor)) {\n\t\t    throw new TypeError(\"Cannot call a class as a function\");\n\t\t  }\n\t\t};\n\t\t\n\t\tvar createClass = function () {\n\t\t  function defineProperties(target, props) {\n\t\t    for (var i = 0; i < props.length; i++) {\n\t\t      var descriptor = props[i];\n\t\t      descriptor.enumerable = descriptor.enumerable || false;\n\t\t      descriptor.configurable = true;\n\t\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return function (Constructor, protoProps, staticProps) {\n\t\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t\t    return Constructor;\n\t\t  };\n\t\t}();\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar set$1 = function set$1(object, property, value, receiver) {\n\t\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\t\n\t\t  if (desc === undefined) {\n\t\t    var parent = Object.getPrototypeOf(object);\n\t\t\n\t\t    if (parent !== null) {\n\t\t      set$1(parent, property, value, receiver);\n\t\t    }\n\t\t  } else if (\"value\" in desc && desc.writable) {\n\t\t    desc.value = value;\n\t\t  } else {\n\t\t    var setter = desc.set;\n\t\t\n\t\t    if (setter !== undefined) {\n\t\t      setter.call(receiver, value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return value;\n\t\t};\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar toConsumableArray = function (arr) {\n\t\t  if (Array.isArray(arr)) {\n\t\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\t\n\t\t    return arr2;\n\t\t  } else {\n\t\t    return Array.from(arr);\n\t\t  }\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar StyleInfo = function () {\n\t\t  createClass(StyleInfo, null, [{\n\t\t    key: 'get',\n\t\t    value: function get(node) {\n\t\t      return node.__styleInfo;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'set',\n\t\t    value: function set(node, styleInfo) {\n\t\t      node.__styleInfo = styleInfo;\n\t\t      return styleInfo;\n\t\t    }\n\t\t  }]);\n\t\t\n\t\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t\t    classCallCheck(this, StyleInfo);\n\t\t\n\t\t    this.styleRules = ast || null;\n\t\t    this.placeholder = placeholder || null;\n\t\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t\t    this.overrideStyleProperties = {};\n\t\t    this.elementName = elementName || '';\n\t\t    this.cssBuild = cssBuild || '';\n\t\t    this.typeExtension = typeExtension || '';\n\t\t    this.styleProperties = null;\n\t\t    this.scopeSelector = null;\n\t\t    this.customStyle = null;\n\t\t  }\n\t\t\n\t\t  return StyleInfo;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO: dedupe with shady\n\t\tvar p = window.Element.prototype;\n\t\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\t\n\t\tvar StyleProperties = {\n\t\t\n\t\t  // decorates styles with rule info and returns an array of used style\n\t\t  // property names\n\t\t  decorateStyles: function decorateStyles(rules) {\n\t\t    var self = this,\n\t\t        props = {},\n\t\t        keyframes = [],\n\t\t        ruleIndex = 0;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      self.decorateRule(rule);\n\t\t      // mark in-order position of ast rule in styles block, used for cache key\n\t\t      rule.index = ruleIndex++;\n\t\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t\t    }, function onKeyframesRule(rule) {\n\t\t      keyframes.push(rule);\n\t\t    });\n\t\t    // Cache all found keyframes rules for later reference:\n\t\t    rules._keyframes = keyframes;\n\t\t    // return this list of property names *consumes* in these styles.\n\t\t    var names = [];\n\t\t    for (var i in props) {\n\t\t      names.push(i);\n\t\t    }\n\t\t    return names;\n\t\t  },\n\t\t\n\t\t  // decorate a single rule with property info\n\t\t  decorateRule: function decorateRule(rule) {\n\t\t    if (rule.propertyInfo) {\n\t\t      return rule.propertyInfo;\n\t\t    }\n\t\t    var info = {},\n\t\t        properties = {};\n\t\t    var hasProperties = this.collectProperties(rule, properties);\n\t\t    if (hasProperties) {\n\t\t      info.properties = properties;\n\t\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t\t      rule.rules = null;\n\t\t    }\n\t\t    info.cssText = this.collectCssText(rule);\n\t\t    rule.propertyInfo = info;\n\t\t    return info;\n\t\t  },\n\t\t\n\t\t  // collects the custom properties from a rule's cssText\n\t\t  collectProperties: function collectProperties(rule, properties) {\n\t\t    var info = rule.propertyInfo;\n\t\t    if (info) {\n\t\t      if (info.properties) {\n\t\t        Object.assign(properties, info.properties);\n\t\t        return true;\n\t\t      }\n\t\t    } else {\n\t\t      var m = void 0,\n\t\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t\t      var cssText = rule.parsedCssText;\n\t\t      var value = void 0;\n\t\t      var any = void 0;\n\t\t      while (m = rx$$1.exec(cssText)) {\n\t\t        // note: group 2 is var, 3 is mixin\n\t\t        value = (m[2] || m[3]).trim();\n\t\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t\t        if (value !== 'inherit' || value !== 'unset') {\n\t\t          properties[m[1].trim()] = value;\n\t\t        }\n\t\t        any = true;\n\t\t      }\n\t\t      return any;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // returns cssText of properties that consume variables/mixins\n\t\t  collectCssText: function collectCssText(rule) {\n\t\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t\t  },\n\t\t\n\t\t  // NOTE: we support consumption inside mixin assignment\n\t\t  // but not production, so strip out {...}\n\t\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t\t  },\n\t\t\n\t\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t\t    var m = void 0;\n\t\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t\t      var name = m[1];\n\t\t      // This regex catches all variable names, and following non-whitespace char\n\t\t      // If next char is not ':', then variable is a consumer\n\t\t      if (m[2] !== ':') {\n\t\t        props[name] = true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // turns custom properties into realized values.\n\t\t  reify: function reify(props) {\n\t\t    // big perf optimization here: reify only *own* properties\n\t\t    // since this object has __proto__ of the element's scope properties\n\t\t    var names = Object.getOwnPropertyNames(props);\n\t\t    for (var i = 0, n; i < names.length; i++) {\n\t\t      n = names[i];\n\t\t      props[n] = this.valueForProperty(props[n], props);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // given a property value, returns the reified value\n\t\t  // a property value may be:\n\t\t  // (1) a literal value like: red or 5px;\n\t\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t\t  // var(--a, var(--b));\n\t\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t\t  valueForProperty: function valueForProperty(property, props) {\n\t\t    var _this = this;\n\t\t\n\t\t    // case (1) default\n\t\t    // case (3) defines a mixin and we have to reify the internals\n\t\t    if (property) {\n\t\t      if (property.indexOf(';') >= 0) {\n\t\t        property = this.valueForProperties(property, props);\n\t\t      } else {\n\t\t        (function () {\n\t\t          // case (2) variable\n\t\t          var self = _this;\n\t\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t\t            if (!value) {\n\t\t              return prefix + suffix;\n\t\t            }\n\t\t            var propertyValue = self.valueForProperty(props[value], props);\n\t\t            // if value is \"initial\", then the variable should be treated as unset\n\t\t            if (!propertyValue || propertyValue === 'initial') {\n\t\t              // fallback may be --a or var(--a) or literal\n\t\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t\t              // for use with native css variables.\n\t\t              // Since we have full control, we can use `inherit` directly.\n\t\t              propertyValue = 'inherit';\n\t\t            }\n\t\t            return prefix + (propertyValue || '') + suffix;\n\t\t          };\n\t\t          property = processVariableAndFallback(property, fn);\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\t    return property && property.trim() || '';\n\t\t  },\n\t\t\n\t\t  // note: we do not yet support mixin within mixin\n\t\t  valueForProperties: function valueForProperties(property, props) {\n\t\t    var parts = property.split(';');\n\t\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t\t      if (_p = parts[i]) {\n\t\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t\t        if (m) {\n\t\t          _p = this.valueForProperty(props[m[1]], props);\n\t\t        } else {\n\t\t          var colon = _p.indexOf(':');\n\t\t          if (colon !== -1) {\n\t\t            var pp = _p.substring(colon);\n\t\t            pp = pp.trim();\n\t\t            pp = this.valueForProperty(pp, props) || pp;\n\t\t            _p = _p.substring(0, colon) + pp;\n\t\t          }\n\t\t        }\n\t\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t\t        // strip trailing ;\n\t\t        _p.slice(0, -1) : _p || '';\n\t\t      }\n\t\t    }\n\t\t    return parts.join(';');\n\t\t  },\n\t\t\n\t\t  applyProperties: function applyProperties(rule, props) {\n\t\t    var output = '';\n\t\t    // dynamically added sheets may not be decorated so ensure they are.\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (rule.propertyInfo.cssText) {\n\t\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t\t  // functions which take in cssText and spit out transformed cssText.\n\t\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t\t    var input = rule.cssText;\n\t\t    var output = rule.cssText;\n\t\t    if (rule.hasAnimations == null) {\n\t\t      // Cache whether or not the rule has any animations to begin with:\n\t\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t\t    }\n\t\t    // If there are no animations referenced, we can skip transforms:\n\t\t    if (rule.hasAnimations) {\n\t\t      var transform = void 0;\n\t\t      // If we haven't transformed this rule before, we iterate over all\n\t\t      // transforms:\n\t\t      if (rule.keyframeNamesToTransform == null) {\n\t\t        rule.keyframeNamesToTransform = [];\n\t\t        for (var keyframe in keyframeTransforms) {\n\t\t          transform = keyframeTransforms[keyframe];\n\t\t          output = transform(input);\n\t\t          // If the transform actually changed the CSS text, we cache the\n\t\t          // transform name for future use:\n\t\t          if (input !== output) {\n\t\t            input = output;\n\t\t            rule.keyframeNamesToTransform.push(keyframe);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        // If we already have a list of keyframe names that apply to this\n\t\t        // rule, we apply only those keyframe name transforms:\n\t\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t\t          input = transform(input);\n\t\t        }\n\t\t        output = input;\n\t\t      }\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Test if the rules in these styles matches the given `element` and if so,\n\t\t  // collect any custom properties into `props`.\n\t\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t\t    var props = {},\n\t\t        self = this;\n\t\t    // generates a unique key for these matches\n\t\t    var o = [];\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t\t      // time to only include ones that have properties\n\t\t      if (!rule.propertyInfo) {\n\t\t        self.decorateRule(rule);\n\t\t      }\n\t\t      // match element against transformedSelector: selector may contain\n\t\t      // unwanted uniquification and parsedSelector does not directly match\n\t\t      // for :host selectors.\n\t\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t\t          self.collectProperties(rule, props);\n\t\t          // produce numeric key for these matches for lookup\n\t\t          addToBitMask(rule.index, o);\n\t\t        }\n\t\t      }\n\t\t    }, null, true);\n\t\t    return { properties: props, key: o };\n\t\t  },\n\t\t\n\t\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (!rule.propertyInfo.properties) {\n\t\t      return;\n\t\t    }\n\t\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t\t    var parsedSelector = rule.parsedSelector;\n\t\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t\t    // build info is either in scope (when scope is an element) or in the style\n\t\t    // when scope is the default scope; note: this allows default scope to have\n\t\t    // mixed mode built and unbuilt styles.\n\t\t    if (cssBuild === 'shady') {\n\t\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t\t    }\n\t\t    if (cssBuild === 'shadow') {\n\t\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t      isHost = isHost && !isRoot;\n\t\t    }\n\t\t    if (!isRoot && !isHost) {\n\t\t      return;\n\t\t    }\n\t\t    var selectorToMatch = hostScope;\n\t\t    if (isHost) {\n\t\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t\t      if (nativeShadow && !rule.transformedSelector) {\n\t\t        // transform :host into a matchable selector\n\t\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t\t      }\n\t\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t\t    }\n\t\t    callback({\n\t\t      selector: selectorToMatch,\n\t\t      isHost: isHost,\n\t\t      isRoot: isRoot\n\t\t    });\n\t\t  },\n\t\t\n\t\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t\t    var hostProps = {},\n\t\t        rootProps = {},\n\t\t        self = this;\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    var cssBuild = rules && rules.__cssBuild;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t\t        var element = scope._element || scope;\n\t\t        if (matchesSelector.call(element, info.selector)) {\n\t\t          if (info.isHost) {\n\t\t            self.collectProperties(rule, hostProps);\n\t\t          } else {\n\t\t            self.collectProperties(rule, rootProps);\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }, null, true);\n\t\t    return { rootProps: rootProps, hostProps: hostProps };\n\t\t  },\n\t\t\n\t\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t\t    var self = this;\n\t\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t\t    var rules = StyleInfo.get(element).styleRules;\n\t\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t\t      self.applyProperties(rule, properties);\n\t\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t\t        // is not necessary to apply them in ShadowDOM.\n\t\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t\t    var keyframesRules = rules._keyframes;\n\t\t    var keyframeTransforms = {};\n\t\t    if (!nativeShadow && keyframesRules) {\n\t\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t\t      // advance for the current scope. This allows us to catch keyframes\n\t\t      // rules that appear anywhere in the stylesheet:\n\t\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t\t      }\n\t\t    }\n\t\t    return keyframeTransforms;\n\t\t  },\n\t\t\n\t\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t\t  // particular scoped keyframes rule.\n\t\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t\t    return function (cssText) {\n\t\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t\t    };\n\t\t  },\n\t\t\n\t\t  // Transforms `@keyframes` names to be unique for the current host.\n\t\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t\t  },\n\t\t\n\t\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t\t  // have low specificity. They are overrideable by class selectors but,\n\t\t  // unfortunately, not by type selectors (e.g. overriding via\n\t\t  // `.special` is ok, but not by `x-foo`).\n\t\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    var selector = rule.transformedSelector;\n\t\t    var scope = '.' + scopeId;\n\t\t    var parts = selector.split(',');\n\t\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t\t    }\n\t\t    rule.selector = parts.join(',');\n\t\t  },\n\t\t\n\t\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t\t    var c = element.getAttribute('class') || '';\n\t\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t\t    if (c !== v) {\n\t\t      element.setAttribute('class', v);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t\t    // calculate cssText to apply\n\t\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t\t    // if shady and we have a cached style that is not style, decrement\n\t\t    var styleInfo = StyleInfo.get(element);\n\t\t    var s = styleInfo.customStyle;\n\t\t    if (s && !nativeShadow && s !== style) {\n\t\t      s._useCount--;\n\t\t      if (s._useCount <= 0 && s.parentNode) {\n\t\t        s.parentNode.removeChild(s);\n\t\t      }\n\t\t    }\n\t\t    // apply styling always under native or if we generated style\n\t\t    // or the cached style is not in document(!)\n\t\t    if (nativeShadow) {\n\t\t      // update existing style only under native\n\t\t      if (styleInfo.customStyle) {\n\t\t        styleInfo.customStyle.textContent = cssText;\n\t\t        style = styleInfo.customStyle;\n\t\t        // otherwise, if we have css to apply, do so\n\t\t      } else if (cssText) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t\t      }\n\t\t    } else {\n\t\t      // shady and no cache hit\n\t\t      if (!style) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        if (cssText) {\n\t\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t\t        }\n\t\t        // shady and cache hit but not in document\n\t\t      } else if (!style.parentNode) {\n\t\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t\t      }\n\t\t    }\n\t\t    // ensure this style is our custom style and increment its use count.\n\t\t    if (style) {\n\t\t      style._useCount = style._useCount || 0;\n\t\t      // increment use count if we changed styles\n\t\t      if (styleInfo.customStyle != style) {\n\t\t        style._useCount++;\n\t\t      }\n\t\t      styleInfo.customStyle = style;\n\t\t    }\n\t\t    // @media rules may be stale in IE 10 and 11\n\t\t    if (IS_IE) {\n\t\t      style.textContent = style.textContent;\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t\n\t\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t\t    var rules = rulesForStyle(style);\n\t\t    var self = this;\n\t\t    style.textContent = toCssText(rules, function (rule) {\n\t\t      var css = rule.cssText = rule.parsedCssText;\n\t\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t\t        // remove property assignments\n\t\t        // so next function isn't confused\n\t\t        // NOTE: we have 3 categories of css:\n\t\t        // (1) normal properties,\n\t\t        // (2) custom property assignments (--foo: red;),\n\t\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t\t        // are not and this makes this case unique.\n\t\t        css = removeCustomPropAssignment(css);\n\t\t        // replace with reified properties, scenario is same as mixin\n\t\t        rule.cssText = self.valueForProperties(css, properties);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  rx: rx,\n\t\t  XSCOPE_NAME: 'x-scope'\n\t\t};\n\t\t\n\t\tfunction addToBitMask(n, bits) {\n\t\t  var o = parseInt(n / 32);\n\t\t  var v = 1 << n % 32;\n\t\t  bits[o] = (bits[o] || 0) | v;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar templateMap = {};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar placeholderMap = {};\n\t\t\n\t\tvar ce = window.customElements;\n\t\tif (ce && !nativeShadow) {\n\t\t  (function () {\n\t\t    var origDefine = ce.define;\n\t\t    ce.define = function (name, clazz, options) {\n\t\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t\t      return origDefine.call(ce, name, clazz, options);\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\tvar StyleCache = function () {\n\t\t  function StyleCache() {\n\t\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t\t    classCallCheck(this, StyleCache);\n\t\t\n\t\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t\t    this.cache = {};\n\t\t    this.typeMax = typeMax;\n\t\t  }\n\t\t\n\t\t  createClass(StyleCache, [{\n\t\t    key: '_validate',\n\t\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t\t        var pn = ownPropertyNames[idx];\n\t\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t\t          return false;\n\t\t        }\n\t\t      }\n\t\t      return true;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'store',\n\t\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t\t      var list = this.cache[tagname] || [];\n\t\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t\t      if (list.length > this.typeMax) {\n\t\t        list.shift();\n\t\t      }\n\t\t      this.cache[tagname] = list;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'fetch',\n\t\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t\t      var list = this.cache[tagname];\n\t\t      if (!list) {\n\t\t        return;\n\t\t      }\n\t\t      // reverse list for most-recent lookups\n\t\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t\t        var entry = list[idx];\n\t\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t\t          return entry;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }]);\n\t\t  return StyleCache;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/**\n\t\t * The apply shim simulates the behavior of `@apply` proposed at\n\t\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t\t * The approach is to convert a property like this:\n\t\t *\n\t\t *    --foo: {color: red; background: blue;}\n\t\t *\n\t\t * to this:\n\t\t *\n\t\t *    --foo_-_color: red;\n\t\t *    --foo_-_background: blue;\n\t\t *\n\t\t * Then where `@apply --foo` is used, that is converted to:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background);\n\t\t *\n\t\t * This approach generally works but there are some issues and limitations.\n\t\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t\t * another element sets it to:\n\t\t *\n\t\t *    --foo: { border: 2px solid red; }\n\t\t *\n\t\t * We must now ensure that the color and background from the previous setting\n\t\t * do not apply. This is accomplished by changing the property set to this:\n\t\t *\n\t\t *    --foo_-_border: 2px solid red;\n\t\t *    --foo_-_color: initial;\n\t\t *    --foo_-_background: initial;\n\t\t *\n\t\t * This works but introduces one new issue.\n\t\t * Consider this setup at the point where the `@apply` is used:\n\t\t *\n\t\t *    background: orange;\n\t\t *    @apply --foo;\n\t\t *\n\t\t * In this case the background will be unset (initial) rather than the desired\n\t\t * `orange`. We address this by altering the property set to use a fallback\n\t\t * value like this:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background, orange);\n\t\t *    border: var(--foo_-_border);\n\t\t *\n\t\t * Note that the default is retained in the property set and the `background` is\n\t\t * the desired `orange`. This leads us to a limitation.\n\t\t *\n\t\t * Limitation 1:\n\t\t\n\t\t * Only properties in the rule where the `@apply`\n\t\t * is used are considered as default values.\n\t\t * If another rule matches the element and sets `background` with\n\t\t * less specificity than the rule in which `@apply` appears,\n\t\t * the `background` will not be set.\n\t\t *\n\t\t * Limitation 2:\n\t\t *\n\t\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t\t * `@apply` properties.\n\t\t\n\t\t*/\n\t\t\n\t\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\t\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\t\n\t\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\t\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\t\n\t\t// separator used between mixin-name and mixin-property-name when producing properties\n\t\t// NOTE: plain '-' may cause collisions in user styles\n\t\tvar MIXIN_VAR_SEP = '_-_';\n\t\t\n\t\t// map of mixin to property names\n\t\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\t\n\t\tvar MixinMap = function () {\n\t\t  function MixinMap() {\n\t\t    classCallCheck(this, MixinMap);\n\t\t\n\t\t    this._map = {};\n\t\t  }\n\t\t\n\t\t  createClass(MixinMap, [{\n\t\t    key: 'set',\n\t\t    value: function set(name, props) {\n\t\t      name = name.trim();\n\t\t      this._map[name] = {\n\t\t        properties: props,\n\t\t        dependants: {}\n\t\t      };\n\t\t    }\n\t\t  }, {\n\t\t    key: 'get',\n\t\t    value: function get(name) {\n\t\t      name = name.trim();\n\t\t      return this._map[name];\n\t\t    }\n\t\t  }]);\n\t\t  return MixinMap;\n\t\t}();\n\t\t\n\t\tvar ApplyShim = function () {\n\t\t  function ApplyShim() {\n\t\t    var _this = this;\n\t\t\n\t\t    classCallCheck(this, ApplyShim);\n\t\t\n\t\t    this._currentTemplate = null;\n\t\t    this._measureElement = null;\n\t\t    this._map = new MixinMap();\n\t\t    this._separator = MIXIN_VAR_SEP;\n\t\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t\t    };\n\t\t  }\n\t\t\n\t\t  createClass(ApplyShim, [{\n\t\t    key: 'transformStyle',\n\t\t    value: function transformStyle(style, elementName) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      this.transformRules(ast, elementName);\n\t\t      return ast;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRules',\n\t\t    value: function transformRules(rules, elementName) {\n\t\t      var _this2 = this;\n\t\t\n\t\t      this._currentTemplate = templateMap[elementName];\n\t\t      forEachRule(rules, function (r) {\n\t\t        _this2.transformRule(r);\n\t\t      });\n\t\t      if (this._currentTemplate) {\n\t\t        this._currentTemplate.__applyShimInvalid = false;\n\t\t      }\n\t\t      this._currentTemplate = null;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRule',\n\t\t    value: function transformRule(rule) {\n\t\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t\t      // :root was only used for variable assignment in property shim,\n\t\t      // but generates invalid selectors with real properties.\n\t\t      // replace with `:host > *`, which serves the same effect\n\t\t      if (rule.selector === ':root') {\n\t\t        rule.selector = ':host > *';\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformCssText',\n\t\t    value: function transformCssText(cssText) {\n\t\t      // produce variables\n\t\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t\t      // consume mixins\n\t\t      return this._consumeCssProperties(cssText);\n\t\t    }\n\t\t  }, {\n\t\t    key: '_getInitialValueForProperty',\n\t\t    value: function _getInitialValueForProperty(property) {\n\t\t      if (!this._measureElement) {\n\t\t        this._measureElement = document.createElement('meta');\n\t\t        this._measureElement.style.all = 'initial';\n\t\t        document.head.appendChild(this._measureElement);\n\t\t      }\n\t\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t\t    }\n\t\t    // replace mixin consumption with variable consumption\n\t\t\n\t\t  }, {\n\t\t    key: '_consumeCssProperties',\n\t\t    value: function _consumeCssProperties(text) {\n\t\t      var m = void 0;\n\t\t      // loop over text until all mixins with defintions have been applied\n\t\t      while (m = MIXIN_MATCH.exec(text)) {\n\t\t        var matchText = m[0];\n\t\t        var mixinName = m[1];\n\t\t        var idx = m.index;\n\t\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t\t        var applyPos = idx + matchText.indexOf('@apply');\n\t\t        var afterApplyPos = idx + matchText.length;\n\t\t        // find props defined before this @apply\n\t\t        var textBeforeApply = text.slice(0, applyPos);\n\t\t        var textAfterApply = text.slice(afterApplyPos);\n\t\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t\t        // use regex match position to replace mixin, keep linear processing time\n\t\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t\t        // move regex search to _after_ replacement\n\t\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t\t      }\n\t\t      return text;\n\t\t    }\n\t\t    // produce variable consumption at the site of mixin consumption\n\t\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t\t    // Example:\n\t\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\t\n\t\t  }, {\n\t\t    key: '_atApplyToCssProperties',\n\t\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t\t      var vars = [];\n\t\t      var mixinEntry = this._map.get(mixinName);\n\t\t      // if we depend on a mixin before it is created\n\t\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t\t      if (!mixinEntry) {\n\t\t        this._map.set(mixinName, {});\n\t\t        mixinEntry = this._map.get(mixinName);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        if (this._currentTemplate) {\n\t\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t\t        }\n\t\t        var p = void 0,\n\t\t            parts = void 0,\n\t\t            f = void 0;\n\t\t        for (p in mixinEntry.properties) {\n\t\t          f = fallbacks && fallbacks[p];\n\t\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t\t          if (f) {\n\t\t            parts.push(',', f);\n\t\t          }\n\t\t          parts.push(')');\n\t\t          vars.push(parts.join(''));\n\t\t        }\n\t\t      }\n\t\t      return vars.join('; ');\n\t\t    }\n\t\t  }, {\n\t\t    key: '_replaceInitialOrInherit',\n\t\t    value: function _replaceInitialOrInherit(property, value) {\n\t\t      var match = INITIAL_INHERIT.exec(value);\n\t\t      if (match) {\n\t\t        if (match[1]) {\n\t\t          // initial\n\t\t          // replace `initial` with the concrete initial value for this property\n\t\t          value = ApplyShim._getInitialValueForProperty(property);\n\t\t        } else {\n\t\t          // inherit\n\t\t          // with this purposfully illegal value, the variable will be invalid at\n\t\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t\t          // and for inheriting values, will behave similarly\n\t\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t\t          value = 'apply-shim-inherit';\n\t\t        }\n\t\t      }\n\t\t      return value;\n\t\t    }\n\t\t\n\t\t    // \"parse\" a mixin definition into a map of properties and values\n\t\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\t\n\t\t  }, {\n\t\t    key: '_cssTextToMap',\n\t\t    value: function _cssTextToMap(text) {\n\t\t      var props = text.split(';');\n\t\t      var property = void 0,\n\t\t          value = void 0;\n\t\t      var out = {};\n\t\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t\t        p = props[i];\n\t\t        if (p) {\n\t\t          sp = p.split(':');\n\t\t          // ignore lines that aren't definitions like @media\n\t\t          if (sp.length > 1) {\n\t\t            property = sp[0].trim();\n\t\t            // some properties may have ':' in the value, like data urls\n\t\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t\t            out[property] = value;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return out;\n\t\t    }\n\t\t  }, {\n\t\t    key: '_invalidateMixinEntry',\n\t\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t\t      for (var elementName in mixinEntry.dependants) {\n\t\t        if (elementName !== this._currentTemplate) {\n\t\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: '_produceCssProperties',\n\t\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t\t      var _this3 = this;\n\t\t\n\t\t      // handle case where property value is a mixin\n\t\t      if (valueProperty) {\n\t\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t\t          if (value && _this3._map.get(value)) {\n\t\t            valueMixin = '@apply ' + value + ';';\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      if (!valueMixin) {\n\t\t        return matchText;\n\t\t      }\n\t\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t\t      var combinedProps = mixinValues;\n\t\t      var mixinEntry = this._map.get(propertyName);\n\t\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t\t      if (oldProps) {\n\t\t        // NOTE: since we use mixin, the map of properties is updated here\n\t\t        // and this is what we want.\n\t\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t\t      } else {\n\t\t        this._map.set(propertyName, combinedProps);\n\t\t      }\n\t\t      var out = [];\n\t\t      var p = void 0,\n\t\t          v = void 0;\n\t\t      // set variables defined by current mixin\n\t\t      var needToInvalidate = false;\n\t\t      for (p in combinedProps) {\n\t\t        v = mixinValues[p];\n\t\t        // if property not defined by current mixin, set initial\n\t\t        if (v === undefined) {\n\t\t          v = 'initial';\n\t\t        }\n\t\t        if (oldProps && !(p in oldProps)) {\n\t\t          needToInvalidate = true;\n\t\t        }\n\t\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t\t      }\n\t\t      if (needToInvalidate) {\n\t\t        this._invalidateMixinEntry(mixinEntry);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        mixinEntry.properties = combinedProps;\n\t\t      }\n\t\t      // because the mixinMap is global, the mixin might conflict with\n\t\t      // a different scope's simple variable definition:\n\t\t      // Example:\n\t\t      // some style somewhere:\n\t\t      // --mixin1:{ ... }\n\t\t      // --mixin2: var(--mixin1);\n\t\t      // some other element:\n\t\t      // --mixin1: 10px solid red;\n\t\t      // --foo: var(--mixin1);\n\t\t      // In this case, we leave the original variable definition in place.\n\t\t      if (valueProperty) {\n\t\t        prefix = matchText + ';' + prefix;\n\t\t      }\n\t\t      return prefix + out.join('; ') + ';';\n\t\t    }\n\t\t  }]);\n\t\t  return ApplyShim;\n\t\t}();\n\t\t\n\t\tvar applyShim = new ApplyShim();\n\t\twindow['ApplyShim'] = applyShim;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar flush = function flush() {};\n\t\t\n\t\tif (!nativeShadow) {\n\t\t  (function () {\n\t\t    var handler = function handler(mxns) {\n\t\t      for (var x = 0; x < mxns.length; x++) {\n\t\t        var mxn = mxns[x];\n\t\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t\t          var n = mxn.addedNodes[i];\n\t\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t\t            var root = n.getRootNode();\n\t\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t              // may no longer be in a shadowroot\n\t\t              var host = root.host;\n\t\t              if (host) {\n\t\t                var scope = host.is || host.localName;\n\t\t                StyleTransformer.dom(n, scope);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t\t          var _n = mxn.removedNodes[_i];\n\t\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t\t            if (classIdx >= 0) {\n\t\t              // NOTE: relies on the scoping class always being adjacent to the\n\t\t              // SCOPE_NAME class.\n\t\t              var _scope = _n.classList[classIdx + 1];\n\t\t              if (_scope) {\n\t\t                StyleTransformer.dom(_n, _scope, true);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    };\n\t\t\n\t\t    var observer = new MutationObserver(handler);\n\t\t    var startState = 'interactive';\n\t\t\n\t\t    var start = function start() {\n\t\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t\t    };\n\t\t    if (window.HTMLImports) {\n\t\t      window.HTMLImports.whenReady(start);\n\t\t    } else if (document.readyState === startState) {\n\t\t      requestAnimationFrame(start);\n\t\t    } else {\n\t\t      document.addEventListener('readystatechange', function () {\n\t\t        if (document.readyState === startState) {\n\t\t          start();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t\n\t\t    flush = function flush() {\n\t\t      handler(observer.takeRecords());\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(dfreedm): consider spliting into separate global\n\t\tvar styleCache = new StyleCache();\n\t\t\n\t\tvar ShadyCSS = {\n\t\t  flush: flush,\n\t\t  scopeCounter: {},\n\t\t  nativeShadow: nativeShadow,\n\t\t  nativeCss: nativeCssVariables,\n\t\t  nativeCssApply: nativeCssApply,\n\t\t  _documentOwner: document.documentElement,\n\t\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t\t    return name + '-' + id;\n\t\t  },\n\t\t  getStyleAst: function getStyleAst(style) {\n\t\t    return rulesForStyle(style);\n\t\t  },\n\t\t  styleAstToString: function styleAstToString(ast) {\n\t\t    return toCssText(ast);\n\t\t  },\n\t\t  _gatherStyles: function _gatherStyles(template) {\n\t\t    var styles = template.content.querySelectorAll('style');\n\t\t    var cssText = [];\n\t\t    for (var i = 0; i < styles.length; i++) {\n\t\t      var s = styles[i];\n\t\t      cssText.push(s.textContent);\n\t\t      s.parentNode.removeChild(s);\n\t\t    }\n\t\t    return cssText.join('').trim();\n\t\t  },\n\t\t  _getCssBuild: function _getCssBuild(template) {\n\t\t    var style = template.content.querySelector('style');\n\t\t    if (!style) {\n\t\t      return '';\n\t\t    }\n\t\t    return style.getAttribute('css-build') || '';\n\t\t  },\n\t\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t\t    if (template._prepared) {\n\t\t      return;\n\t\t    }\n\t\t    template._prepared = true;\n\t\t    template.name = elementName;\n\t\t    template.extends = typeExtension;\n\t\t    templateMap[elementName] = template;\n\t\t    var cssBuild = this._getCssBuild(template);\n\t\t    var cssText = this._gatherStyles(template);\n\t\t    var info = {\n\t\t      is: elementName,\n\t\t      extends: typeExtension,\n\t\t      __cssBuild: cssBuild\n\t\t    };\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleTransformer.dom(template.content, elementName);\n\t\t    }\n\t\t    var ast = parse(cssText);\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      applyShim.transformRules(ast, elementName);\n\t\t    }\n\t\t    template._styleAst = ast;\n\t\t\n\t\t    var ownPropertyNames = [];\n\t\t    if (!this.nativeCss) {\n\t\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t\t    }\n\t\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t\t      var root = this.nativeShadow ? template.content : null;\n\t\t      var placeholder = placeholderMap[elementName];\n\t\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t\t      template._style = style;\n\t\t    }\n\t\t    template._ownPropertyNames = ownPropertyNames;\n\t\t  },\n\t\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t\t    if (cssText.length) {\n\t\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t\t    }\n\t\t  },\n\t\t  _prepareHost: function _prepareHost(host) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var typeExtension = void 0;\n\t\t    if (is !== host.localName) {\n\t\t      typeExtension = host.localName;\n\t\t    }\n\t\t    var placeholder = placeholderMap[is];\n\t\t    var template = templateMap[is];\n\t\t    var ast = void 0;\n\t\t    var ownStylePropertyNames = void 0;\n\t\t    var cssBuild = void 0;\n\t\t    if (template) {\n\t\t      ast = template._styleAst;\n\t\t      ownStylePropertyNames = template._ownPropertyNames;\n\t\t      cssBuild = template._cssBuild;\n\t\t    }\n\t\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t\t  },\n\t\t  applyStyle: function applyStyle(host, overrideProps) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    if (window.CustomStyle) {\n\t\t      var CS = window.CustomStyle;\n\t\t      if (CS._documentDirty) {\n\t\t        CS.findStyles();\n\t\t        if (!this.nativeCss) {\n\t\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t\t        } else if (!this.nativeCssApply) {\n\t\t          CS._revalidateApplyShim();\n\t\t        }\n\t\t        CS.applyStyles();\n\t\t        CS._documentDirty = false;\n\t\t      }\n\t\t    }\n\t\t    var styleInfo = StyleInfo.get(host);\n\t\t    if (!styleInfo) {\n\t\t      styleInfo = this._prepareHost(host);\n\t\t    }\n\t\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t\t    if (this.nativeCss) {\n\t\t      var template = templateMap[is];\n\t\t      if (template && template.__applyShimInvalid && template._style) {\n\t\t        // update template\n\t\t        applyShim.transformRules(template._styleAst, is);\n\t\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        // update instance if native shadowdom\n\t\t        if (this.nativeShadow) {\n\t\t          var style = host.shadowRoot.querySelector('style');\n\t\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        }\n\t\t        styleInfo.styleRules = template._styleAst;\n\t\t      }\n\t\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t\t    } else {\n\t\t      this._updateProperties(host, styleInfo);\n\t\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t\t        // TODO: use caching\n\t\t        this._applyStyleProperties(host, styleInfo);\n\t\t      }\n\t\t    }\n\t\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t\t    // note: some elements may not have a root!\n\t\t    if (root) {\n\t\t      this._applyToDescendants(root);\n\t\t    }\n\t\t  },\n\t\t  _applyToDescendants: function _applyToDescendants(root) {\n\t\t    var c$ = root.children;\n\t\t    for (var i = 0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (c.shadowRoot) {\n\t\t        this.applyStyle(c);\n\t\t      }\n\t\t      this._applyToDescendants(c);\n\t\t    }\n\t\t  },\n\t\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t\t    var root = node.getRootNode();\n\t\t    var host = root.host;\n\t\t    if (host) {\n\t\t      if (StyleInfo.get(host)) {\n\t\t        return host;\n\t\t      } else {\n\t\t        return this._styleOwnerForNode(host);\n\t\t      }\n\t\t    }\n\t\t    return this._documentOwner;\n\t\t  },\n\t\t  _isRootOwner: function _isRootOwner(node) {\n\t\t    return node === this._documentOwner;\n\t\t  },\n\t\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t\t    // only generate new scope if cached style is not found\n\t\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t\t    }\n\t\t    if (!cacheEntry) {\n\t\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t\t    var owner = this._styleOwnerForNode(host);\n\t\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t\t    var props = Object.create(ownerProperties || null);\n\t\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t\t    var propertiesMatchingHost = propertyData.properties;\n\t\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t\t    StyleProperties.reify(props);\n\t\t    styleInfo.styleProperties = props;\n\t\t  },\n\t\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t\t    for (var p in overrides) {\n\t\t      var v = overrides[p];\n\t\t      // skip override props if they are not truthy or 0\n\t\t      // in order to fall back to inherited values\n\t\t      if (v || v === 0) {\n\t\t        props[p] = v;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t\t    // remove previous properties\n\t\t    for (var p in properties) {\n\t\t      // NOTE: for bc with shim, don't apply null values.\n\t\t      if (p === null) {\n\t\t        element.style.removeProperty(p);\n\t\t      } else {\n\t\t        element.style.setProperty(p, properties[p]);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  updateStyles: function updateStyles(properties) {\n\t\t    if (window.CustomStyle) {\n\t\t      window.CustomStyle._documentDirty = true;\n\t\t    }\n\t\t    this.applyStyle(this._documentOwner, properties);\n\t\t  },\n\t\t\n\t\t  /* Custom Style operations */\n\t\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t\t    var _this = this;\n\t\t\n\t\t    var ast = rulesForStyle(style);\n\t\t    forEachRule(ast, function (rule) {\n\t\t      if (nativeShadow) {\n\t\t        StyleTransformer.normalizeRootSelector(rule);\n\t\t      } else {\n\t\t        StyleTransformer.documentRule(rule);\n\t\t      }\n\t\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t\t        applyShim.transformRule(rule);\n\t\t      }\n\t\t    });\n\t\t    if (this.nativeCss) {\n\t\t      style.textContent = toCssText(ast);\n\t\t    } else {\n\t\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t\t    }\n\t\t  },\n\t\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      applyShim.transformRules(ast);\n\t\t      style.textContent = toCssText(ast);\n\t\t    }\n\t\t  },\n\t\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t\t    if (!this.nativeCss) {\n\t\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t\t    }\n\t\t  },\n\t\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t\t    var value = void 0;\n\t\t    if (!this.nativeCss) {\n\t\t      // element is either a style host, or an ancestor of a style host\n\t\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t\t      value = styleInfo.styleProperties[property];\n\t\t    }\n\t\t    // fall back to the property value from the computed styling\n\t\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t\t    // trim whitespace that can come after the `:` in css\n\t\t    // example: padding: 2px -> \" 2px\"\n\t\t    return value.trim();\n\t\t  },\n\t\t\n\t\t  // given an element and a classString, replaces\n\t\t  // the element's class with the provided classString and adds\n\t\t  // any necessary ShadyCSS static and property based scoping selectors\n\t\t  // NOTE: this method is suitable to be called in an environment in which\n\t\t  // setAttribute('class', ...) and className setter have been overridden so\n\t\t  // it cannot rely on those methods.\n\t\t  setElementClass: function setElementClass(element, classString) {\n\t\t    var _element$classList;\n\t\t\n\t\t    // use classList to clear existing classes\n\t\t    while (element.classList.length) {\n\t\t      element.classList.remove(element.classList[0]);\n\t\t    }\n\t\t    // add user classString\n\t\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t\t    // add static scoping: scope by shadyRoot\n\t\t    var root = element.getRootNode();\n\t\t    if (root.host) {\n\t\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t\t    }\n\t\t    // add property scoping: scope by special selector\n\t\t    if (!this.nativeCss) {\n\t\t      var styleInfo = StyleInfo.get(element);\n\t\t      if (styleInfo && styleInfo.scopeSelector) {\n\t\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t\t    return StyleInfo.get(node);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow['ShadyCSS'] = ShadyCSS;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\t\n\t\tExample:\n\t\t<shady-style>\n\t\t  <style>\n\t\t  ...\n\t\t  </style>\n\t\t</shady-style>\n\t\t*/\n\t\t\n\t\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\t\n\t\tvar enqueued = false;\n\t\t\n\t\tvar customStyles = [];\n\t\t\n\t\tvar hookFn = null;\n\t\t\n\t\t/*\n\t\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\t\tas all the instances will boot asynchronously after page load.\n\t\t\n\t\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t\t*/\n\t\tfunction enqueueDocumentValidation() {\n\t\t  if (enqueued) {\n\t\t    return;\n\t\t  }\n\t\t  enqueued = true;\n\t\t  if (window.HTMLImports) {\n\t\t    window.HTMLImports.whenReady(validateDocument);\n\t\t  } else if (document.readyState === 'complete') {\n\t\t    requestAnimationFrame(validateDocument);\n\t\t  } else {\n\t\t    document.addEventListener('readystatechange', function () {\n\t\t      if (document.readyState === 'complete') {\n\t\t        validateDocument();\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t}\n\t\t\n\t\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t\t// helps ensure that the first run of validateDocument will actually\n\t\t// have access to all the custom-style's created via loading imports.\n\t\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t\t// then the enqueue immediately calls validateDocument and work that could be\n\t\t// batched is not.\n\t\tenqueueDocumentValidation();\n\t\t\n\t\tfunction validateDocument() {\n\t\t  if (enqueued) {\n\t\t    ShadyCSS$1.updateStyles();\n\t\t    enqueued = false;\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction CustomStyle() {\n\t\t  /*\n\t\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t\t  CustomElement polyfill replacement that can be `.call`ed\n\t\t  */\n\t\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t\t  customStyles.push(self);\n\t\t  enqueueDocumentValidation();\n\t\t  return self;\n\t\t}\n\t\t\n\t\tObject.defineProperties(CustomStyle, {\n\t\t  /*\n\t\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t\t   The function must take a <style> element as input, and return nothing.\n\t\t  */\n\t\t  processHook: {\n\t\t    get: function get() {\n\t\t      return hookFn;\n\t\t    },\n\t\t    set: function set(fn) {\n\t\t      hookFn = fn;\n\t\t      return fn;\n\t\t    }\n\t\t  },\n\t\t  _customStyles: {\n\t\t    get: function get() {\n\t\t      return customStyles;\n\t\t    }\n\t\t  },\n\t\t  _documentDirty: {\n\t\t    get: function get() {\n\t\t      return enqueued;\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      enqueued = value;\n\t\t      return value;\n\t\t    }\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.findStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._findStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle._revalidateApplyShim = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    var s = customStyles[i];\n\t\t    if (s._style) {\n\t\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.applyStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._applyStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t\t  'constructor': {\n\t\t    value: CustomStyle,\n\t\t    configurable: true,\n\t\t    writable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.prototype._findStyle = function () {\n\t\t  if (!this._style) {\n\t\t    var style = this.querySelector('style');\n\t\t    if (!style) {\n\t\t      return;\n\t\t    }\n\t\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t\t    // which is referenced with __appliedElement.\n\t\t    // Also, we must copy over the attributes.\n\t\t    if (style.__appliedElement) {\n\t\t      for (var i = 0; i < style.attributes.length; i++) {\n\t\t        var attr = style.attributes[i];\n\t\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t\t      }\n\t\t    }\n\t\t    this._style = style.__appliedElement || style;\n\t\t    if (hookFn) {\n\t\t      hookFn(this._style);\n\t\t    }\n\t\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype._applyStyle = function () {\n\t\t  if (this._style) {\n\t\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow.customElements.define('custom-style', CustomStyle);\n\t\twindow['CustomStyle'] = CustomStyle;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/*\n\t\tSmall module to load ShadyCSS and CustomStyle together\n\t\t*/\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadycss.min.js.map\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(3), __webpack_require__(4)) :\n\t  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n\t  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n\t}(this, (function (exports,incrementalDom,root) {\n\t\n\troot = 'default' in root ? root['default'] : root;\n\t\n\tfunction keys() {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  var _ref$enumOnly = _ref.enumOnly;\n\t  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\t\n\t  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n\t  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n\t}\n\t\n\t// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n\t// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\n\tvar assign = (function (obj) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  args.forEach(function (arg) {\n\t    return keys(arg).forEach(function (name) {\n\t      return obj[name] = arg[name];\n\t    });\n\t  }); // eslint-disable-line no-return-assign\n\t  return obj;\n\t});\n\t\n\tvar empty = function (val) {\n\t  return typeof val === 'undefined' || val === null;\n\t};\n\t\n\tvar alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {\n\t  return isNaN(val) ? undefined : Number(val);\n\t};\n\tvar alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n\t  return empty(val) ? undefined : String(val);\n\t};\n\t\n\tfunction create(def) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args.unshift({}, def);\n\t    return assign.apply(undefined, args);\n\t  };\n\t}\n\t\n\tvar array = create({\n\t  coerce: function coerce(val) {\n\t    return Array.isArray(val) ? val : [val];\n\t  },\n\t  default: function _default() {\n\t    return [];\n\t  },\n\t  deserialize: JSON.parse,\n\t  serialize: JSON.stringify\n\t});\n\t\n\tvar boolean = create({\n\t  coerce: function coerce(value) {\n\t    return !!value;\n\t  },\n\t  default: false,\n\t  deserialize: function deserialize(value) {\n\t    return !(value === null);\n\t  },\n\t  serialize: function serialize(value) {\n\t    return value ? '' : undefined;\n\t  }\n\t});\n\t\n\tvar number = create({\n\t  default: 0,\n\t  coerce: alwaysUndefinedIfNotANumberOrNumber,\n\t  deserialize: alwaysUndefinedIfNotANumberOrNumber,\n\t  serialize: alwaysUndefinedIfNotANumberOrNumber\n\t});\n\t\n\tvar string = create({\n\t  default: '',\n\t  coerce: alwaysUndefinedIfEmptyOrString,\n\t  deserialize: alwaysUndefinedIfEmptyOrString,\n\t  serialize: alwaysUndefinedIfEmptyOrString\n\t});\n\t\n\tvar prop = Object.freeze({\n\t\tcreate: create,\n\t\tarray: array,\n\t\tboolean: boolean,\n\t\tnumber: number,\n\t\tstring: string\n\t});\n\t\n\tvar connected = '____skate_connected';\n\tvar created$1 = '____skate_created';\n\t\n\t// DEPRECATED\n\t//\n\t// This is the only \"symbol\" that must stay a string. This is because it is\n\t// relied upon across several versions. We should remove it, but ensure that\n\t// it's considered a breaking change that whatever version removes it cannot\n\t// be passed to vdom functions as tag names.\n\tvar name = '____skate_name';\n\t\n\t// Used on the Constructor\n\tvar ctorCreateInitProps = '____skate_ctor_createInitProps';\n\tvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\n\tvar ctorProps = '____skate_ctor_props';\n\tvar ctorPropsMap = '____skate_ctor_propsMap';\n\t\n\t// Used on the Element\n\tvar props = '____skate_props';\n\tvar ref$1 = '____skate_ref';\n\tvar renderer$1 = '____skate_renderer';\n\tvar rendering = '____skate_rendering';\n\tvar rendererDebounced = '____skate_rendererDebounced';\n\tvar updated$1 = '____skate_updated';\n\t\n\t// DEPRECTAED\n\t//\n\t// We should not be relying on internals for symbols as this creates version\n\t// coupling. We will move forward with platform agnostic ways of doing this.\n\t\n\t\n\tvar symbols$1 = Object.freeze({\n\t\tname: name\n\t});\n\t\n\tfunction enter(object, props) {\n\t  var saved = {};\n\t  Object.keys(props).forEach(function (key) {\n\t    saved[key] = object[key];\n\t    object[key] = props[key];\n\t  });\n\t  return saved;\n\t}\n\t\n\tfunction exit(object, saved) {\n\t  assign(object, saved);\n\t}\n\t\n\t// Decorates a function with a side effect that changes the properties of an\n\t// object during its execution, and restores them after. There is no error\n\t// handling here, if the wrapped function throws an error, properties are not\n\t// restored and all bets are off.\n\tvar propContext = function (object, props) {\n\t  return function (func) {\n\t    return function () {\n\t      var saved = enter(object, props);\n\t      var result = func.apply(undefined, arguments);\n\t      exit(object, saved);\n\t      return result;\n\t    };\n\t  };\n\t};\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\t\n\t\n\t\n\t\n\t\n\tvar asyncGenerator = function () {\n\t  function AwaitValue(value) {\n\t    this.value = value;\n\t  }\n\t\n\t  function AsyncGenerator(gen) {\n\t    var front, back;\n\t\n\t    function send(key, arg) {\n\t      return new Promise(function (resolve, reject) {\n\t        var request = {\n\t          key: key,\n\t          arg: arg,\n\t          resolve: resolve,\n\t          reject: reject,\n\t          next: null\n\t        };\n\t\n\t        if (back) {\n\t          back = back.next = request;\n\t        } else {\n\t          front = back = request;\n\t          resume(key, arg);\n\t        }\n\t      });\n\t    }\n\t\n\t    function resume(key, arg) {\n\t      try {\n\t        var result = gen[key](arg);\n\t        var value = result.value;\n\t\n\t        if (value instanceof AwaitValue) {\n\t          Promise.resolve(value.value).then(function (arg) {\n\t            resume(\"next\", arg);\n\t          }, function (arg) {\n\t            resume(\"throw\", arg);\n\t          });\n\t        } else {\n\t          settle(result.done ? \"return\" : \"normal\", result.value);\n\t        }\n\t      } catch (err) {\n\t        settle(\"throw\", err);\n\t      }\n\t    }\n\t\n\t    function settle(type, value) {\n\t      switch (type) {\n\t        case \"return\":\n\t          front.resolve({\n\t            value: value,\n\t            done: true\n\t          });\n\t          break;\n\t\n\t        case \"throw\":\n\t          front.reject(value);\n\t          break;\n\t\n\t        default:\n\t          front.resolve({\n\t            value: value,\n\t            done: false\n\t          });\n\t          break;\n\t      }\n\t\n\t      front = front.next;\n\t\n\t      if (front) {\n\t        resume(front.key, front.arg);\n\t      } else {\n\t        back = null;\n\t      }\n\t    }\n\t\n\t    this._invoke = send;\n\t\n\t    if (typeof gen.return !== \"function\") {\n\t      this.return = undefined;\n\t    }\n\t  }\n\t\n\t  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n\t    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n\t      return this;\n\t    };\n\t  }\n\t\n\t  AsyncGenerator.prototype.next = function (arg) {\n\t    return this._invoke(\"next\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.throw = function (arg) {\n\t    return this._invoke(\"throw\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.return = function (arg) {\n\t    return this._invoke(\"return\", arg);\n\t  };\n\t\n\t  return {\n\t    wrap: function (fn) {\n\t      return function () {\n\t        return new AsyncGenerator(fn.apply(this, arguments));\n\t      };\n\t    },\n\t    await: function (value) {\n\t      return new AwaitValue(value);\n\t    }\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar defineProperty = function (obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\t\n\t  return obj;\n\t};\n\t\n\tvar get$1 = function get$1(object, property, receiver) {\n\t  if (object === null) object = Function.prototype;\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent === null) {\n\t      return undefined;\n\t    } else {\n\t      return get$1(parent, property, receiver);\n\t    }\n\t  } else if (\"value\" in desc) {\n\t    return desc.value;\n\t  } else {\n\t    var getter = desc.get;\n\t\n\t    if (getter === undefined) {\n\t      return undefined;\n\t    }\n\t\n\t    return getter.call(receiver);\n\t  }\n\t};\n\t\n\tvar inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\t\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar possibleConstructorReturn = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/* eslint no-plusplus: 0 */\n\t\n\tvar customElements = root.customElements;\n\tvar HTMLElement = root.HTMLElement;\n\t\n\tvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\t\n\t// A stack of children that corresponds to the current function helper being\n\t// executed.\n\tvar stackChren = [];\n\t\n\tvar $skip = '__skip';\n\tvar $currentEventHandlers = '__events';\n\tvar $stackCurrentHelperProps = '__props';\n\t\n\t// The current function helper in the stack.\n\tvar stackCurrentHelper = void 0;\n\t\n\t// This is used for the Incremental DOM overrides to keep track of what args\n\t// to pass the main elementOpen() function.\n\tvar overrideArgs = void 0;\n\t\n\t// The number of levels deep after skipping a tree.\n\tvar skips = 0;\n\t\n\tvar noop = function noop() {};\n\t\n\t// Adds or removes an event listener for an element.\n\tfunction applyEvent(elem, ename, newFunc) {\n\t  var events = elem[$currentEventHandlers];\n\t\n\t  if (!events) {\n\t    events = elem[$currentEventHandlers] = {};\n\t  }\n\t\n\t  // Undefined indicates that there is no listener yet.\n\t  if (typeof events[ename] === 'undefined') {\n\t    // We only add a single listener once. Originally this was a workaround for\n\t    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n\t    // also a simpler model for binding / unbinding events because you only\n\t    // have a single handler you need to worry about and a single place where\n\t    // you only store one event handler\n\t    elem.addEventListener(ename, function (e) {\n\t      if (events[ename]) {\n\t        events[ename].call(this, e);\n\t      }\n\t    });\n\t  }\n\t\n\t  // Not undefined indicates that we have set a listener, so default to null.\n\t  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n\t}\n\t\n\tvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n\t  // Attributes that shouldn't be applied to the DOM.\n\t  key: noop,\n\t  statics: noop,\n\t\n\t  // Attributes that *must* be set via a property on all elements.\n\t  checked: incrementalDom.applyProp,\n\t  className: incrementalDom.applyProp,\n\t  disabled: incrementalDom.applyProp,\n\t  value: incrementalDom.applyProp,\n\t\n\t  // Ref handler.\n\t  ref: function ref(elem, name$$1, value) {\n\t    elem[ref$1] = value;\n\t  },\n\t\n\t\n\t  // Skip handler.\n\t  skip: function skip(elem, name$$1, value) {\n\t    if (value) {\n\t      elem[$skip] = true;\n\t    } else {\n\t      delete elem[$skip];\n\t    }\n\t  }\n\t}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n\t  var _ref = customElements.get(elem.localName) || {\n\t    props: {},\n\t    prototype: {}\n\t  };\n\t\n\t  var props$$1 = _ref.props;\n\t  var prototype = _ref.prototype;\n\t\n\t  // TODO when refactoring properties to not have to workaround the old\n\t  // WebKit bug we can remove the \"name in props\" check below.\n\t  //\n\t  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n\t  // elements that set a property that isn't explicitly specified in \"props\"\n\t  // or \"prototype\" unless it is added to the element explicitly as a\n\t  // property prior to passing the prop to the vdom function. For example, if\n\t  // it were added in a lifecycle callback because it wouldn't have been\n\t  // upgraded yet.\n\t  //\n\t  // We prefer setting props, so we do this if there's a property matching\n\t  // name that was passed. However, certain props on SVG elements are\n\t  // readonly and error when you try to set them.\n\t\n\t  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n\t    incrementalDom.applyProp(elem, name$$1, value);\n\t    return;\n\t  }\n\t\n\t  // Explicit false removes the attribute.\n\t  if (value === false) {\n\t    applyDefault(elem, name$$1);\n\t    return;\n\t  }\n\t\n\t  // Handle built-in and custom events.\n\t  if (name$$1.indexOf('on') === 0) {\n\t    var firstChar = name$$1[2];\n\t    var eventName = void 0;\n\t\n\t    if (firstChar === '-') {\n\t      eventName = name$$1.substring(3);\n\t    } else if (firstChar === firstChar.toUpperCase()) {\n\t      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n\t    }\n\t\n\t    if (eventName) {\n\t      applyEvent(elem, eventName, value);\n\t      return;\n\t    }\n\t  }\n\t\n\t  applyDefault(elem, name$$1, value);\n\t}));\n\t\n\tfunction resolveTagName(name$$1) {\n\t  // We return falsy values as some wrapped IDOM functions allow empty values.\n\t  if (!name$$1) {\n\t    return name$$1;\n\t  }\n\t\n\t  // We try and return the cached tag name, if one exists.\n\t  if (name$$1[name]) {\n\t    return name$$1[name];\n\t  }\n\t\n\t  // If it's a custom element, we get the tag name by constructing it and\n\t  // caching it.\n\t  if (name$$1.prototype instanceof HTMLElement) {\n\t    // eslint-disable-next-line\n\t    var elem = new name$$1();\n\t    return name$$1[name] = elem.localName;\n\t  }\n\t\n\t  // Pass all other values through so IDOM gets what it's expecting.\n\t  return name$$1;\n\t}\n\t\n\t// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n\t// so it's the only function we need to execute in the context of our attributes.\n\tvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\t\n\tfunction elementOpenStart(tag) {\n\t  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t  overrideArgs = [tag, key, statics];\n\t}\n\t\n\tfunction elementOpenEnd() {\n\t  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n\t  overrideArgs = null;\n\t  return node;\n\t}\n\t\n\tfunction wrapIdomFunc(func) {\n\t  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\t\n\t  return function wrap() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args[0] = resolveTagName(args[0]);\n\t    stackCurrentHelper = null;\n\t    if (typeof args[0] === 'function') {\n\t      // If we've encountered a function, handle it according to the type of\n\t      // function that is being wrapped.\n\t      stackCurrentHelper = args[0];\n\t      return tnameFuncHandler.apply(undefined, args);\n\t    } else if (stackChren.length) {\n\t      // We pass the wrap() function in here so that when it's called as\n\t      // children, it will queue up for the next stack, if there is one.\n\t      stackChren[stackChren.length - 1].push([wrap, args]);\n\t    } else {\n\t      if (func === elementOpen$1) {\n\t        if (skips) {\n\t          return ++skips;\n\t        }\n\t\n\t        var elem = func.apply(undefined, args);\n\t\n\t        if (elem[$skip]) {\n\t          ++skips;\n\t        }\n\t\n\t        return elem;\n\t      }\n\t\n\t      if (func === incrementalDom.elementClose) {\n\t        if (skips === 1) {\n\t          incrementalDom.skip();\n\t        }\n\t\n\t        // We only want to skip closing if it's not the last closing tag in the\n\t        // skipped tree because we keep the element that initiated the skpping.\n\t        if (skips && --skips) {\n\t          return;\n\t        }\n\t\n\t        var _elem = func.apply(undefined, args);\n\t        var ref$$1 = _elem[ref$1];\n\t\n\t        // We delete so that it isn't called again for the same element. If the\n\t        // ref changes, or the element changes, this will be defined again.\n\t        delete _elem[ref$1];\n\t\n\t        // Execute the saved ref after esuring we've cleand up after it.\n\t        if (typeof ref$$1 === 'function') {\n\t          ref$$1(_elem);\n\t        }\n\t\n\t        return _elem;\n\t      }\n\t\n\t      // We must call elementOpenStart and elementOpenEnd even if we are\n\t      // skipping because they queue up attributes and then call elementClose.\n\t      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n\t        return func.apply(undefined, args);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction newAttr() {\n\t  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t    args[_key2] = arguments[_key2];\n\t  }\n\t\n\t  if (stackCurrentHelper) {\n\t    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n\t  } else if (stackChren.length) {\n\t    stackChren[stackChren.length - 1].push([newAttr, args]);\n\t  } else {\n\t    overrideArgs.push(args[0]);\n\t    overrideArgs.push(args[1]);\n\t  }\n\t}\n\t\n\tfunction stackOpen(tname, key, statics) {\n\t  var props$$1 = { key: key, statics: statics };\n\t\n\t  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n\t    attrs[_key3 - 3] = arguments[_key3];\n\t  }\n\t\n\t  for (var a = 0; a < attrs.length; a += 2) {\n\t    props$$1[attrs[a]] = attrs[a + 1];\n\t  }\n\t  tname[$stackCurrentHelperProps] = props$$1;\n\t  stackChren.push([]);\n\t}\n\t\n\tfunction stackClose(tname) {\n\t  var chren = stackChren.pop();\n\t  var props$$1 = tname[$stackCurrentHelperProps];\n\t  delete tname[$stackCurrentHelperProps];\n\t  var elemOrFn = tname(props$$1, function () {\n\t    return chren.forEach(function (args) {\n\t      return args[0].apply(args, toConsumableArray(args[1]));\n\t    });\n\t  });\n\t  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n\t}\n\t\n\t// Incremental DOM overrides\n\t// -------------------------\n\t\n\t// We must override internal functions that call internal Incremental DOM\n\t// functions because we can't override the internal references. This means\n\t// we must roughly re-implement their behaviour. Luckily, they're fairly\n\t// simple.\n\tvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\n\tvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\t\n\t// Standard open / closed overrides don't need to reproduce internal behaviour\n\t// because they are the ones referenced from *End and *Start.\n\tvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\n\tvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\t\n\t// Ensure we call our overridden functions instead of the internal ones.\n\tfunction newElementVoid(tag) {\n\t  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t    args[_key4 - 1] = arguments[_key4];\n\t  }\n\t\n\t  newElementOpen.apply(undefined, [tag].concat(args));\n\t  return newElementClose(tag);\n\t}\n\t\n\t// Text override ensures their calls can queue if using function helpers.\n\tvar newText = wrapIdomFunc(incrementalDom.text);\n\t\n\t// Convenience function for declaring an Incremental DOM element using\n\t// hyperscript-style syntax.\n\tfunction element(tname, attrs) {\n\t  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\t\n\t  // If attributes are a function, then they should be treated as children.\n\t\n\t  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n\t    chren[_key5 - 2] = arguments[_key5];\n\t  }\n\t\n\t  if (atype === 'function' || atype === 'string' || atype === 'number') {\n\t    chren.unshift(attrs);\n\t  }\n\t\n\t  // Ensure the attributes are an object. Null is considered an object so we\n\t  // have to test for this explicitly.\n\t  if (attrs === null || atype !== 'object') {\n\t    attrs = {};\n\t  }\n\t\n\t  // We open the element so we can set attrs after.\n\t  newElementOpenStart(tname, attrs.key, attrs.statics);\n\t\n\t  // Delete so special attrs don't actually get set.\n\t  delete attrs.key;\n\t  delete attrs.statics;\n\t\n\t  // Set attributes.\n\t  Object.keys(attrs).forEach(function (name$$1) {\n\t    return newAttr(name$$1, attrs[name$$1]);\n\t  });\n\t\n\t  // Close before we render the descendant tree.\n\t  newElementOpenEnd(tname);\n\t\n\t  chren.forEach(function (ch) {\n\t    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n\t    if (ctype === 'function') {\n\t      ch();\n\t    } else if (ctype === 'string' || ctype === 'number') {\n\t      newText(ch);\n\t    } else if (Array.isArray(ch)) {\n\t      ch.forEach(function (sch) {\n\t        return sch();\n\t      });\n\t    }\n\t  });\n\t\n\t  return newElementClose(tname);\n\t}\n\t\n\t// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n\t// transpiles for JSX (React.createElement() / h).\n\tfunction builder() {\n\t  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n\t    tags[_key6] = arguments[_key6];\n\t  }\n\t\n\t  if (tags.length === 0) {\n\t    return function () {\n\t      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n\t        args[_key7] = arguments[_key7];\n\t      }\n\t\n\t      return element.bind.apply(element, [null].concat(args));\n\t    };\n\t  }\n\t  return tags.map(function (tag) {\n\t    return function () {\n\t      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n\t        args[_key8] = arguments[_key8];\n\t      }\n\t\n\t      return element.bind.apply(element, [null, tag].concat(args));\n\t    };\n\t  });\n\t}\n\t\n\t\n\t\n\tvar vdom = Object.freeze({\n\t\telement: element,\n\t\tbuilder: builder,\n\t\tattr: newAttr,\n\t\telementClose: newElementClose,\n\t\telementOpen: newElementOpen,\n\t\telementOpenEnd: newElementOpenEnd,\n\t\telementOpenStart: newElementOpenStart,\n\t\telementVoid: newElementVoid,\n\t\ttext: newText\n\t});\n\t\n\tfunction createSymbol(description) {\n\t  return typeof Symbol === 'function' ? Symbol(description) : description;\n\t}\n\t\n\tvar data = function (element) {\n\t  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t\n\t  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n\t};\n\t\n\tvar dashCase = function (str) {\n\t  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t    var dash = !one || idx % 2 === 0 ? '' : '-';\n\t    return '' + one + dash + two.toLowerCase();\n\t  });\n\t};\n\t\n\tvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n\t];\n\tvar native = (function (fn) {\n\t  return nativeHints.map(function (hint) {\n\t    return (fn || '').toString().indexOf([hint]) > -1;\n\t  }).reduce(function (a, b) {\n\t    return a || b;\n\t  });\n\t});\n\t\n\tvar MutationObserver = root.MutationObserver;\n\t\n\t\n\tfunction microtaskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var i = 0;\n\t  var cbArgs = [];\n\t  var elem = document.createElement('span');\n\t  var observer = new MutationObserver(function () {\n\t    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t    scheduled = false;\n\t    cbArgs = null;\n\t  });\n\t\n\t  observer.observe(elem, { childList: true });\n\t\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      elem.textContent = '' + i;\n\t      i += 1;\n\t    }\n\t  };\n\t}\n\t\n\t// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n\t// polyfill requires that the element be in the document to trigger Mutation\n\t// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n\t//\n\t// The soonest we can set the timeout for in IE is 1 as they have issues when\n\t// setting to 0.\n\tfunction taskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var cbArgs = [];\n\t  return function () {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      setTimeout(function () {\n\t        scheduled = false;\n\t        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t      }, 1);\n\t    }\n\t  };\n\t}\n\tvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\t\n\tvar getOwnPropertyDescriptors = function () {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  return keys(obj).reduce(function (prev, curr) {\n\t    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t    return prev;\n\t  }, {});\n\t};\n\t\n\t/**\n\t * This is needed to avoid IE11 \"stack size errors\" when creating\n\t * a new property on the constructor of an HTMLElement\n\t */\n\tfunction setCtorNativeProperty(Ctor, propName, value) {\n\t  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n\t}\n\t\n\t/**\n\t * Returns a cached map of property options for the given component class.\n\t * Keys in the map are the properties name which can a string or a symbol.\n\t *\n\t * The map is created by caching the result of: static get props\n\t */\n\tfunction getPropsMap(Ctor) {\n\t  // Must be defined on constructor and not from a superclass\n\t  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n\t    (function () {\n\t      var props$$1 = Ctor.props || {};\n\t\n\t      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n\t        result[propNameOrSymbol] = props$$1[propNameOrSymbol];\n\t        return result;\n\t      }, {});\n\t      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n\t    })();\n\t  }\n\t\n\t  return Ctor[ctorPropsMap];\n\t}\n\t\n\tfunction get$2(elem) {\n\t  var props$$1 = {};\n\t  keys(getPropsMap(elem.constructor)).forEach(function (key) {\n\t    props$$1[key] = elem[key];\n\t  });\n\t\n\t  return props$$1;\n\t}\n\t\n\tfunction set$2(elem, newProps) {\n\t  assign(elem, newProps);\n\t  if (elem[renderer$1]) {\n\t    elem[renderer$1]();\n\t  }\n\t}\n\t\n\tvar props$1 = function (elem, newProps) {\n\t  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n\t};\n\t\n\tfunction getDefaultValue(elem, name, opts) {\n\t  return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n\t}\n\t\n\tfunction getInitialValue(elem, name, opts) {\n\t  return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n\t}\n\t\n\tfunction getPropData(elem, name) {\n\t  var elemData = data(elem, 'props');\n\t  return elemData[name] || (elemData[name] = {});\n\t}\n\t\n\tfunction syncFirstTimeProp(elem, prop, propName, attributeName, propData) {\n\t  var syncAttrValue = propData.lastAssignedValue;\n\t  if (empty(syncAttrValue)) {\n\t    if ('initial' in prop) {\n\t      syncAttrValue = getInitialValue(elem, propName, prop);\n\t    } else if ('default' in prop) {\n\t      syncAttrValue = getDefaultValue(elem, propName, prop);\n\t    }\n\t  }\n\t  if (!empty(syncAttrValue) && prop.serialize) {\n\t    syncAttrValue = prop.serialize(syncAttrValue);\n\t  }\n\t  if (!empty(syncAttrValue)) {\n\t    propData.syncingAttribute = true;\n\t    elem.setAttribute(attributeName, syncAttrValue);\n\t  }\n\t}\n\t\n\tfunction syncExistingProp(elem, prop, propName, attributeName, propData) {\n\t  if (attributeName && !propData.settingAttribute) {\n\t    var internalValue = propData.internalValue;\n\t\n\t    var serializedValue = prop.serialize(internalValue);\n\t    var currentAttrValue = elem.getAttribute(attributeName);\n\t    var serializedIsEmpty = empty(serializedValue);\n\t    var attributeChanged = !(serializedIsEmpty && empty(currentAttrValue) || serializedValue === currentAttrValue);\n\t\n\t    propData.syncingAttribute = true;\n\t\n\t    var shouldRemoveAttribute = empty(propData.lastAssignedValue);\n\t    if (shouldRemoveAttribute || serializedIsEmpty) {\n\t      elem.removeAttribute(attributeName);\n\t    } else {\n\t      elem.setAttribute(attributeName, serializedValue);\n\t    }\n\t\n\t    if (!attributeChanged && propData.syncingAttribute) {\n\t      propData.syncingAttribute = false;\n\t    }\n\t  }\n\t\n\t  // Allow the attribute to be linked again.\n\t  propData.settingAttribute = false;\n\t}\n\t\n\tfunction syncPropToAttr(elem, prop, propName, isFirstSync) {\n\t  var attributeName = data(elem, 'propertyLinks')[propName];\n\t  var propData = getPropData(elem, propName);\n\t\n\t  if (attributeName) {\n\t    if (isFirstSync) {\n\t      syncFirstTimeProp(elem, prop, propName, attributeName, propData);\n\t    } else {\n\t      syncExistingProp(elem, prop, propName, attributeName, propData);\n\t    }\n\t  }\n\t}\n\t\n\tfunction createNativePropertyDefinition(name$$1, opts) {\n\t  var prop = {\n\t    configurable: true,\n\t    enumerable: true\n\t  };\n\t\n\t  prop.created = function created(elem) {\n\t    var propData = getPropData(elem, name$$1);\n\t    var attributeName = opts.attribute === true ? dashCase(name$$1) : opts.attribute;\n\t    var initialValue = elem[name$$1];\n\t\n\t    // Store property to attribute link information.\n\t    data(elem, 'attributeLinks')[attributeName] = name$$1;\n\t    data(elem, 'propertyLinks')[name$$1] = attributeName;\n\t\n\t    // Set up initial value if it wasn't specified.\n\t    if (empty(initialValue)) {\n\t      if (attributeName && elem.hasAttribute(attributeName)) {\n\t        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n\t      } else if ('initial' in opts) {\n\t        initialValue = getInitialValue(elem, name$$1, opts);\n\t      } else if ('default' in opts) {\n\t        initialValue = getDefaultValue(elem, name$$1, opts);\n\t      }\n\t    }\n\t\n\t    propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n\t  };\n\t\n\t  prop.get = function get() {\n\t    var propData = getPropData(this, name$$1);\n\t    var internalValue = propData.internalValue;\n\t\n\t    return typeof opts.get === 'function' ? opts.get(this, { name: name$$1, internalValue: internalValue }) : internalValue;\n\t  };\n\t\n\t  prop.set = function set(newValue) {\n\t    var propData = getPropData(this, name$$1);\n\t    propData.lastAssignedValue = newValue;\n\t    var oldValue = propData.oldValue;\n\t\n\t\n\t    if (empty(oldValue)) {\n\t      oldValue = null;\n\t    }\n\t\n\t    if (empty(newValue)) {\n\t      newValue = getDefaultValue(this, name$$1, opts);\n\t    }\n\t\n\t    if (typeof opts.coerce === 'function') {\n\t      newValue = opts.coerce(newValue);\n\t    }\n\t\n\t    var changeData = { name: name$$1, newValue: newValue, oldValue: oldValue };\n\t\n\t    if (typeof opts.set === 'function') {\n\t      opts.set(this, changeData);\n\t    }\n\t\n\t    // Queue a re-render.\n\t    this[rendererDebounced](this);\n\t\n\t    // Update prop data so we can use it next time.\n\t    propData.internalValue = propData.oldValue = newValue;\n\t\n\t    // Link up the attribute.\n\t    if (this[connected]) {\n\t      syncPropToAttr(this, opts, name$$1, false);\n\t    }\n\t  };\n\t\n\t  return prop;\n\t}\n\t\n\tvar initProps = function (opts) {\n\t  opts = opts || {};\n\t\n\t  if (typeof opts === 'function') {\n\t    opts = { coerce: opts };\n\t  }\n\t\n\t  return function (name$$1) {\n\t    return createNativePropertyDefinition(name$$1, assign({\n\t      default: null,\n\t      deserialize: function deserialize(value) {\n\t        return value;\n\t      },\n\t      serialize: function serialize(value) {\n\t        return value;\n\t      }\n\t    }, opts));\n\t  };\n\t};\n\t\n\tvar HTMLElement$1 = root.HTMLElement || function () {\n\t  function _class() {\n\t    classCallCheck(this, _class);\n\t  }\n\t\n\t  return _class;\n\t}();\n\tvar _prevName = createSymbol('prevName');\n\tvar _prevOldValue = createSymbol('prevOldValue');\n\tvar _prevNewValue = createSymbol('prevNewValue');\n\t\n\tfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n\t  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n\t}\n\t\n\tfunction syncPropsToAttrs(elem) {\n\t  var props$$1 = getPropsMap(elem.constructor);\n\t  Object.keys(props$$1).forEach(function (propName) {\n\t    var prop = props$$1[propName];\n\t    syncPropToAttr(elem, prop, propName, true);\n\t  });\n\t}\n\t\n\t// TODO remove when not catering to Safari < 10.\n\t//\n\t// Ensures that definitions passed as part of the constructor are functions\n\t// that return property definitions used on the element.\n\tfunction ensurePropertyFunctions(Ctor) {\n\t  var props$$1 = getPropsMap(Ctor);\n\t  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props$$1[descriptorName];\n\t    if (typeof descriptors[descriptorName] !== 'function') {\n\t      descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n\t    }\n\t    return descriptors;\n\t  }, {});\n\t}\n\t\n\t// TODO remove when not catering to Safari < 10.\n\t//\n\t// This can probably be simplified into createInitProps().\n\tfunction ensurePropertyDefinitions(Ctor) {\n\t  var props$$1 = ensurePropertyFunctions(Ctor);\n\t  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props$$1[descriptorName](descriptorName);\n\t    return descriptors;\n\t  }, {});\n\t}\n\t\n\t// TODO refactor when not catering to Safari < 10.\n\t//\n\t// We should be able to simplify this where all we do is Object.defineProperty().\n\tfunction createInitProps(Ctor) {\n\t  var props$$1 = ensurePropertyDefinitions(Ctor);\n\t\n\t  return function (elem) {\n\t    if (!props$$1) {\n\t      return;\n\t    }\n\t\n\t    keys(props$$1).forEach(function (name$$1) {\n\t      var prop = props$$1[name$$1];\n\t      prop.created(elem);\n\t\n\t      // We check here before defining to see if the prop was specified prior\n\t      // to upgrading.\n\t      var hasPropBeforeUpgrading = name$$1 in elem;\n\t\n\t      // This is saved prior to defining so that we can set it after it it was\n\t      // defined prior to upgrading. We don't want to invoke the getter if we\n\t      // don't need to, so we only get the value if we need to re-sync.\n\t      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\t\n\t      // https://bugs.webkit.org/show_bug.cgi?id=49739\n\t      //\n\t      // When Webkit fixes that bug so that native property accessors can be\n\t      // retrieved, we can move defining the property to the prototype and away\n\t      // from having to do if for every instance as all other browsers support\n\t      // this.\n\t      Object.defineProperty(elem, name$$1, prop);\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We'll be removing get / set callbacks on properties. Use the\n\t      // updatedCallback() instead.\n\t      //\n\t      // We re-set the prop if it was specified prior to upgrading because we\n\t      // need to ensure set() is triggered both in polyfilled environments and\n\t      // in native where the definition may be registerd after elements it\n\t      // represents have already been created.\n\t      if (hasPropBeforeUpgrading) {\n\t        elem[name$$1] = valueBeforeUpgrading;\n\t      }\n\t    });\n\t  };\n\t}\n\t\n\tvar _class2 = function (_HTMLElement) {\n\t  inherits(_class2, _HTMLElement);\n\t  createClass(_class2, null, [{\n\t    key: 'observedAttributes',\n\t\n\t\n\t    /**\n\t     * Returns unique attribute names configured with props and\n\t     * those set on the Component constructor if any\n\t     */\n\t    get: function get() {\n\t      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n\t\n\t      var props$$1 = getPropsMap(this);\n\t      var attrsFromLinkedProps = Object.keys(props$$1).map(function (key) {\n\t        var attribute = props$$1[key].attribute;\n\t\n\t        return attribute === true ? dashCase(key) : attribute;\n\t      }).filter(Boolean);\n\t\n\t      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n\t\n\t      return all.filter(function (item, index) {\n\t        return all.indexOf(item) === index;\n\t      });\n\t    },\n\t    set: function set(value) {\n\t      value = Array.isArray(value) ? value : [];\n\t      setCtorNativeProperty(this, 'observedAttributes', value);\n\t    }\n\t\n\t    // Returns superclass props overwritten with this Component props\n\t\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n\t    },\n\t    set: function set(value) {\n\t      setCtorNativeProperty(this, ctorProps, value);\n\t    }\n\t  }]);\n\t\n\t  function _class2() {\n\t    classCallCheck(this, _class2);\n\t\n\t    var _this = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this));\n\t\n\t    var constructor = _this.constructor;\n\t\n\t    // Used for the ready() function so it knows when it can call its callback.\n\t\n\t    _this[created$1] = true;\n\t\n\t    // TODO refactor to not cater to Safari < 10. This means we can depend on\n\t    // built-in property descriptors.\n\t    // Must be defined on constructor and not from a superclass\n\t    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n\t      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n\t    }\n\t\n\t    // Set up a renderer that is debounced for property sets to call directly.\n\t    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\t\n\t    // Set up property lifecycle.\n\t    var propConfigsCount = keys(getPropsMap(constructor)).length;\n\t    if (propConfigsCount && constructor[ctorCreateInitProps]) {\n\t      constructor[ctorCreateInitProps](_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static render()\n\t    if (!_this.renderCallback && constructor.render) {\n\t      _this.renderCallback = constructor.render.bind(constructor, _this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static created()\n\t    //\n\t    // Props should be set up before calling this.\n\t    if (typeof constructor.created === 'function') {\n\t      constructor.created(_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // Feature has rarely been used.\n\t    //\n\t    // Created should be set before invoking the ready listeners.\n\t    var elemData = data(_this);\n\t    var readyCallbacks = elemData.readyCallbacks;\n\t    if (readyCallbacks) {\n\t      readyCallbacks.forEach(function (cb) {\n\t        return cb(_this);\n\t      });\n\t      delete elemData.readyCallbacks;\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  // Custom Elements v1\n\t\n\t\n\t  createClass(_class2, [{\n\t    key: 'connectedCallback',\n\t    value: function connectedCallback() {\n\t      var constructor = this.constructor;\n\t\n\t      // DEPRECATED\n\t      //\n\t      // No more reflecting back to attributes in favour of one-way reflection.\n\t\n\t      syncPropsToAttrs(this);\n\t\n\t      // Used to check whether or not the component can render.\n\t      this[connected] = true;\n\t\n\t      // Render!\n\t      this[rendererDebounced]();\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static attached()\n\t      if (typeof constructor.attached === 'function') {\n\t        constructor.attached(this);\n\t      }\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We can remove this once all browsers support :defined.\n\t      this.setAttribute('defined', '');\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'disconnectedCallback',\n\t    value: function disconnectedCallback() {\n\t      var constructor = this.constructor;\n\t\n\t      // Ensures the component can't be rendered while disconnected.\n\t\n\t      this[connected] = false;\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static detached()\n\t      if (typeof constructor.detached === 'function') {\n\t        constructor.detached(this);\n\t      }\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n\t      // Polyfill calls this twice.\n\t      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n\t        return;\n\t      }\n\t\n\t      // Set data so we can prevent double calling if the polyfill.\n\t      this[_prevName] = name$$1;\n\t      this[_prevOldValue] = oldValue;\n\t      this[_prevNewValue] = newValue;\n\t\n\t      var attributeChanged = this.constructor.attributeChanged;\n\t\n\t      var propertyName = data(this, 'attributeLinks')[name$$1];\n\t\n\t      if (propertyName) {\n\t        var propData = data(this, 'props')[propertyName];\n\t\n\t        // This ensures a property set doesn't cause the attribute changed\n\t        // handler to run again once we set this flag. This only ever has a\n\t        // chance to run when you set an attribute, it then sets a property and\n\t        // then that causes the attribute to be set again.\n\t        if (propData.syncingAttribute) {\n\t          propData.syncingAttribute = false;\n\t        } else {\n\t          // Sync up the property.\n\t          var propOpts = getPropsMap(this.constructor)[propertyName];\n\t          propData.settingAttribute = true;\n\t          var newPropVal = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n\t          this[propertyName] = newPropVal;\n\t        }\n\t      }\n\t\n\t      if (attributeChanged) {\n\t        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n\t      }\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static updated() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t\n\t  }, {\n\t    key: 'updatedCallback',\n\t    value: function updatedCallback(prev) {\n\t      return this.constructor.updated(this, prev);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static rendered() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t\n\t  }, {\n\t    key: 'renderedCallback',\n\t    value: function renderedCallback() {\n\t      return this.constructor.rendered(this);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static renderer() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t\n\t  }, {\n\t    key: 'rendererCallback',\n\t    value: function rendererCallback() {\n\t      return this.constructor.renderer(this);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Invokes the complete render lifecycle.\n\t\n\t  }, {\n\t    key: renderer$1,\n\t    value: function value() {\n\t      if (this[rendering] || !this[connected]) {\n\t        return;\n\t      }\n\t\n\t      // Flag as rendering. This prevents anything from trying to render - or\n\t      // queueing a render - while there is a pending render.\n\t      this[rendering] = true;\n\t\n\t      if (this[updated$1]() && typeof this.renderCallback === 'function') {\n\t        this.rendererCallback();\n\t        this.renderedCallback();\n\t      }\n\t\n\t      this[rendering] = false;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Calls the user-defined updated() lifecycle callback.\n\t\n\t  }, {\n\t    key: updated$1,\n\t    value: function value() {\n\t      var prev = this[props];\n\t      this[props] = props$1(this);\n\t      return this.updatedCallback(prev);\n\t    }\n\t\n\t    // Skate\n\t\n\t  }], [{\n\t    key: 'extend',\n\t    value: function extend() {\n\t      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\t\n\t      // Create class for the user.\n\t      var Ctor = function (_Base) {\n\t        inherits(Ctor, _Base);\n\t\n\t        function Ctor() {\n\t          classCallCheck(this, Ctor);\n\t          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n\t        }\n\t\n\t        return Ctor;\n\t      }(Base);\n\t\n\t      // For inheriting from the object literal.\n\t\n\t\n\t      var opts = getOwnPropertyDescriptors(definition);\n\t      var prot = getOwnPropertyDescriptors(definition.prototype);\n\t\n\t      // Prototype is non configurable (but is writable).\n\t      delete opts.prototype;\n\t\n\t      // Pass on static and instance members from the definition.\n\t      Object.defineProperties(Ctor, opts);\n\t      Object.defineProperties(Ctor.prototype, prot);\n\t\n\t      return Ctor;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'updated',\n\t    value: function updated(elem, prev) {\n\t      if (!prev) {\n\t        return true;\n\t      }\n\t\n\t      // use get all keys so that we check Symbols as well as regular props\n\t      // using a for loop so we can break early\n\t      var allKeys = keys(prev);\n\t      for (var i = 0; i < allKeys.length; i += 1) {\n\t        if (prev[allKeys[i]] !== elem[allKeys[i]]) {\n\t          return true;\n\t        }\n\t      }\n\t\n\t      return false;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'rendered',\n\t    value: function rendered() {}\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'renderer',\n\t    value: function renderer(elem) {\n\t      if (!elem.shadowRoot) {\n\t        elem.attachShadow({ mode: 'open' });\n\t      }\n\t      incrementalDom.patchInner(elem.shadowRoot, function () {\n\t        var possibleFn = elem.renderCallback();\n\t        if (typeof possibleFn === 'function') {\n\t          possibleFn();\n\t        } else if (Array.isArray(possibleFn)) {\n\t          possibleFn.forEach(function (fn) {\n\t            if (typeof fn === 'function') {\n\t              fn();\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }\n\t  }]);\n\t  return _class2;\n\t}(HTMLElement$1);\n\t\n\tfunction uniqueId(prefix) {\n\t  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n\t  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0;\n\t    // eslint-disable-next-line no-mixed-operators\n\t    var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t  return (prefix || 'x') + '-' + rand;\n\t}\n\t\n\tvar define = function () {\n\t  var customElements = root.customElements;\n\t\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  var name$$1 = args[0];\n\t  var Ctor = args[1];\n\t\n\t\n\t  if (!customElements) {\n\t    throw new Error('Skate requires native custom element support or a polyfill.');\n\t  }\n\t\n\t  // Support passing an anonymous definition.\n\t  if (args.length === 1) {\n\t    // We are checking string for now, but once we remove the ability to pass\n\t    // an object literal, we can change this to check \"function\" and invert the\n\t    // blocks of logic.\n\t    if (typeof name$$1 === 'string') {\n\t      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n\t    } else {\n\t      Ctor = name$$1;\n\t      name$$1 = uniqueId();\n\t    }\n\t  }\n\t\n\t  // Ensure there's no conflicts.\n\t  if (customElements.get(name$$1)) {\n\t    name$$1 = uniqueId(name$$1);\n\t  }\n\t\n\t  // DEPRECATED\n\t  //\n\t  // Object literals.\n\t  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n\t    Ctor = _class2.extend(Ctor);\n\t  }\n\t\n\t  // This allows us to check this before instantiating the custom element to\n\t  // find its name from the constructor in the vdom module, thus improving\n\t  // performance but still falling back to a robust method.\n\t  Ctor[name] = name$$1;\n\t\n\t  // Sipmle define. Not supporting customised built-ins yet.\n\t  customElements.define(name$$1, Ctor);\n\t\n\t  // The spec doesn't return but this allows for a simpler, more concise API.\n\t  return Ctor;\n\t};\n\t\n\tvar Event = function (TheEvent) {\n\t  if (TheEvent) {\n\t    try {\n\t      new TheEvent('emit-init'); // eslint-disable-line no-new\n\t    } catch (e) {\n\t      return undefined;\n\t    }\n\t  }\n\t  return TheEvent;\n\t}(root.Event);\n\t\n\tfunction createCustomEvent(name) {\n\t  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var detail = opts.detail;\n\t\n\t  delete opts.detail;\n\t\n\t  var e = void 0;\n\t  if (Event) {\n\t    e = new Event(name, opts);\n\t    Object.defineProperty(e, 'detail', { value: detail });\n\t  } else {\n\t    e = document.createEvent('CustomEvent');\n\t    Object.defineProperty(e, 'composed', { value: opts.composed });\n\t    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n\t  }\n\t  return e;\n\t}\n\t\n\tvar emit = function (elem, name) {\n\t  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (opts.bubbles === undefined) {\n\t    opts.bubbles = true;\n\t  }\n\t  if (opts.cancelable === undefined) {\n\t    opts.cancelable = true;\n\t  }\n\t  if (opts.composed === undefined) {\n\t    opts.composed = true;\n\t  }\n\t  return elem.dispatchEvent(createCustomEvent(name, opts));\n\t};\n\t\n\tfunction getValue(elem) {\n\t  var type = elem.type;\n\t  if (type === 'checkbox' || type === 'radio') {\n\t    return elem.checked ? elem.value || true : false;\n\t  }\n\t  return elem.value;\n\t}\n\t\n\tvar link = function (elem, target) {\n\t  return function (e) {\n\t    var value = getValue(e.target);\n\t    var localTarget = target || e.target.name || 'value';\n\t\n\t    if (localTarget.indexOf('.') > -1) {\n\t      var parts = localTarget.split('.');\n\t      var firstPart = parts[0];\n\t      var propName = parts.pop();\n\t      var obj = parts.reduce(function (prev, curr) {\n\t        return prev && prev[curr];\n\t      }, elem);\n\t\n\t      obj[propName || e.target.name] = value;\n\t      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n\t    } else {\n\t      props$1(elem, defineProperty({}, localTarget, value));\n\t    }\n\t  };\n\t};\n\t\n\tvar ready = function (elem, done) {\n\t  var info = data(elem);\n\t  if (elem[created$1]) {\n\t    done(elem);\n\t  } else if (info.readyCallbacks) {\n\t    info.readyCallbacks.push(done);\n\t  } else {\n\t    info.readyCallbacks = [done];\n\t  }\n\t};\n\t\n\tvar h = builder();\n\t\n\texports.Component = _class2;\n\texports.define = define;\n\texports.emit = emit;\n\texports.h = h;\n\texports.link = link;\n\texports.prop = prop;\n\texports.props = props$1;\n\texports.ready = ready;\n\texports.symbols = symbols$1;\n\texports.vdom = vdom;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t//# sourceMappingURL=index.js.map\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function (name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\t\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\t\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = attributes[name] || attributes[symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes[symbols.default] = applyAttributeTyped;\n\t\n\tattributes[symbols.placeholder] = function () {};\n\t\n\tattributes['style'] = applyStyle;\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\t\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\t\n\t  return parent.namespaceURI;\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = undefined;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function (doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\t\n\t  while (child) {\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t\n\t    child = child.nextElementSibling;\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function (nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\t\n\t/** @type {?Context} */\n\tvar context = null;\n\t\n\t/** @type {?Node} */\n\tvar currentNode = null;\n\t\n\t/** @type {?Node} */\n\tvar currentParent = null;\n\t\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = null;\n\t\n\t/** @type {?Document} */\n\tvar doc = null;\n\t\n\t/**\n\t * Returns a patcher function that sets up and restores a patch context,\n\t * running the run function with the provided data.\n\t * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n\t * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n\t * @template T\n\t */\n\tvar patchFactory = function (run) {\n\t  /**\n\t   * TODO(moz): These annotations won't be necessary once we switch to Closure\n\t   * Compiler's new type inference. Remove these once the switch is done.\n\t   *\n\t   * @param {(!Element|!DocumentFragment)} node\n\t   * @param {!function(T)} fn\n\t   * @param {T=} data\n\t   * @template T\n\t   */\n\t  var f = function (node, fn, data) {\n\t    var prevContext = context;\n\t    var prevRoot = root;\n\t    var prevDoc = doc;\n\t    var prevCurrentNode = currentNode;\n\t    var prevCurrentParent = currentParent;\n\t    var previousInAttributes = false;\n\t    var previousInSkip = false;\n\t\n\t    context = new Context();\n\t    root = node;\n\t    doc = node.ownerDocument;\n\t    currentParent = node.parentNode;\n\t\n\t    if (false) {}\n\t\n\t    run(node, fn, data);\n\t\n\t    if (false) {}\n\t\n\t    context.notifyChanges();\n\t\n\t    context = prevContext;\n\t    root = prevRoot;\n\t    doc = prevDoc;\n\t    currentNode = prevCurrentNode;\n\t    currentParent = prevCurrentParent;\n\t  };\n\t  return f;\n\t};\n\t\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchInner = patchFactory(function (node, fn, data) {\n\t  currentNode = node;\n\t\n\t  enterNode();\n\t  fn(data);\n\t  exitNode();\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = patchFactory(function (node, fn, data) {\n\t  currentNode = /** @type {!Element} */{ nextSibling: node };\n\t\n\t  fn(data);\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (nodeName, key) {\n\t  var data = getData(currentNode);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\t\n\t  var node = undefined;\n\t\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && 'production' !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\t\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\t\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\t\n\t    context.markCreated(node);\n\t  }\n\t\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\t\n\t  currentNode = node;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function () {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = undefined;\n\t\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[symbols.placeholder] && node !== root) {\n\t    if (false) {}\n\t    return;\n\t  }\n\t\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\t\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function () {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function () {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function () {\n\t  clearUnvisitedDOM();\n\t\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\t\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function (tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function () {\n\t  if (false) {}\n\t\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function () {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function () {\n\t  if (false) {}\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip = function () {\n\t  if (false) {}\n\t  currentNode = currentParent.lastChild;\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function (tag, key, statics) {\n\t  if (false) {}\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function (name, value) {\n\t  if (false) {}\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd = function () {\n\t  if (false) {}\n\t\n\t  var node = elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose = function (tag) {\n\t  if (false) {}\n\t\n\t  var node = coreElementClose();\n\t\n\t  if (false) {}\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function (tag, key, statics, const_args) {\n\t  elementOpen.apply(null, arguments);\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  elementOpen.apply(null, arguments);\n\t  skip();\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text = function (value, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreText();\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\texports.patch = patchInner;\n\texports.patchInner = patchInner;\n\texports.patchOuter = patchOuter;\n\texports.currentElement = currentElement;\n\texports.skip = skip;\n\texports.elementVoid = elementVoid;\n\texports.elementOpenStart = elementOpenStart;\n\texports.elementOpenEnd = elementOpenEnd;\n\texports.elementOpen = elementOpen;\n\texports.elementClose = elementClose;\n\texports.elementPlaceholder = elementPlaceholder;\n\texports.text = text;\n\texports.attr = attr;\n\texports.symbols = symbols;\n\texports.attributes = attributes;\n\texports.applyAttr = applyAttr;\n\texports.applyProp = applyProp;\n\texports.notifications = notifications;\n\t\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict'\n\tmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n\t  (typeof global === 'object' && global.global === global && global) ||\n\t  this\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subject_1 = __webpack_require__(6);\n\tvar ObjectUnsubscribedError_1 = __webpack_require__(21);\n\t/**\n\t * @class BehaviorSubject<T>\n\t */\n\tvar BehaviorSubject = (function (_super) {\n\t    __extends(BehaviorSubject, _super);\n\t    function BehaviorSubject(_value) {\n\t        _super.call(this);\n\t        this._value = _value;\n\t    }\n\t    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n\t        get: function () {\n\t            return this.getValue();\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    BehaviorSubject.prototype._subscribe = function (subscriber) {\n\t        var subscription = _super.prototype._subscribe.call(this, subscriber);\n\t        if (subscription && !subscription.closed) {\n\t            subscriber.next(this._value);\n\t        }\n\t        return subscription;\n\t    };\n\t    BehaviorSubject.prototype.getValue = function () {\n\t        if (this.hasError) {\n\t            throw this.thrownError;\n\t        }\n\t        else if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        else {\n\t            return this._value;\n\t        }\n\t    };\n\t    BehaviorSubject.prototype.next = function (value) {\n\t        _super.prototype.next.call(this, this._value = value);\n\t    };\n\t    return BehaviorSubject;\n\t}(Subject_1.Subject));\n\texports.BehaviorSubject = BehaviorSubject;\n\t//# sourceMappingURL=BehaviorSubject.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(7);\n\tvar Subscriber_1 = __webpack_require__(10);\n\tvar Subscription_1 = __webpack_require__(12);\n\tvar ObjectUnsubscribedError_1 = __webpack_require__(21);\n\tvar SubjectSubscription_1 = __webpack_require__(22);\n\tvar rxSubscriber_1 = __webpack_require__(19);\n\t/**\n\t * @class SubjectSubscriber<T>\n\t */\n\tvar SubjectSubscriber = (function (_super) {\n\t    __extends(SubjectSubscriber, _super);\n\t    function SubjectSubscriber(destination) {\n\t        _super.call(this, destination);\n\t        this.destination = destination;\n\t    }\n\t    return SubjectSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.SubjectSubscriber = SubjectSubscriber;\n\t/**\n\t * @class Subject<T>\n\t */\n\tvar Subject = (function (_super) {\n\t    __extends(Subject, _super);\n\t    function Subject() {\n\t        _super.call(this);\n\t        this.observers = [];\n\t        this.closed = false;\n\t        this.isStopped = false;\n\t        this.hasError = false;\n\t        this.thrownError = null;\n\t    }\n\t    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n\t        return new SubjectSubscriber(this);\n\t    };\n\t    Subject.prototype.lift = function (operator) {\n\t        var subject = new AnonymousSubject(this, this);\n\t        subject.operator = operator;\n\t        return subject;\n\t    };\n\t    Subject.prototype.next = function (value) {\n\t        if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        if (!this.isStopped) {\n\t            var observers = this.observers;\n\t            var len = observers.length;\n\t            var copy = observers.slice();\n\t            for (var i = 0; i < len; i++) {\n\t                copy[i].next(value);\n\t            }\n\t        }\n\t    };\n\t    Subject.prototype.error = function (err) {\n\t        if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        this.hasError = true;\n\t        this.thrownError = err;\n\t        this.isStopped = true;\n\t        var observers = this.observers;\n\t        var len = observers.length;\n\t        var copy = observers.slice();\n\t        for (var i = 0; i < len; i++) {\n\t            copy[i].error(err);\n\t        }\n\t        this.observers.length = 0;\n\t    };\n\t    Subject.prototype.complete = function () {\n\t        if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        this.isStopped = true;\n\t        var observers = this.observers;\n\t        var len = observers.length;\n\t        var copy = observers.slice();\n\t        for (var i = 0; i < len; i++) {\n\t            copy[i].complete();\n\t        }\n\t        this.observers.length = 0;\n\t    };\n\t    Subject.prototype.unsubscribe = function () {\n\t        this.isStopped = true;\n\t        this.closed = true;\n\t        this.observers = null;\n\t    };\n\t    Subject.prototype._subscribe = function (subscriber) {\n\t        if (this.closed) {\n\t            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n\t        }\n\t        else if (this.hasError) {\n\t            subscriber.error(this.thrownError);\n\t            return Subscription_1.Subscription.EMPTY;\n\t        }\n\t        else if (this.isStopped) {\n\t            subscriber.complete();\n\t            return Subscription_1.Subscription.EMPTY;\n\t        }\n\t        else {\n\t            this.observers.push(subscriber);\n\t            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n\t        }\n\t    };\n\t    Subject.prototype.asObservable = function () {\n\t        var observable = new Observable_1.Observable();\n\t        observable.source = this;\n\t        return observable;\n\t    };\n\t    Subject.create = function (destination, source) {\n\t        return new AnonymousSubject(destination, source);\n\t    };\n\t    return Subject;\n\t}(Observable_1.Observable));\n\texports.Subject = Subject;\n\t/**\n\t * @class AnonymousSubject<T>\n\t */\n\tvar AnonymousSubject = (function (_super) {\n\t    __extends(AnonymousSubject, _super);\n\t    function AnonymousSubject(destination, source) {\n\t        _super.call(this);\n\t        this.destination = destination;\n\t        this.source = source;\n\t    }\n\t    AnonymousSubject.prototype.next = function (value) {\n\t        var destination = this.destination;\n\t        if (destination && destination.next) {\n\t            destination.next(value);\n\t        }\n\t    };\n\t    AnonymousSubject.prototype.error = function (err) {\n\t        var destination = this.destination;\n\t        if (destination && destination.error) {\n\t            this.destination.error(err);\n\t        }\n\t    };\n\t    AnonymousSubject.prototype.complete = function () {\n\t        var destination = this.destination;\n\t        if (destination && destination.complete) {\n\t            this.destination.complete();\n\t        }\n\t    };\n\t    AnonymousSubject.prototype._subscribe = function (subscriber) {\n\t        var source = this.source;\n\t        if (source) {\n\t            return this.source.subscribe(subscriber);\n\t        }\n\t        else {\n\t            return Subscription_1.Subscription.EMPTY;\n\t        }\n\t    };\n\t    return AnonymousSubject;\n\t}(Subject));\n\texports.AnonymousSubject = AnonymousSubject;\n\t//# sourceMappingURL=Subject.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(8);\n\tvar toSubscriber_1 = __webpack_require__(9);\n\tvar observable_1 = __webpack_require__(20);\n\t/**\n\t * A representation of any set of values over any amount of time. This the most basic building block\n\t * of RxJS.\n\t *\n\t * @class Observable<T>\n\t */\n\tvar Observable = (function () {\n\t    /**\n\t     * @constructor\n\t     * @param {Function} subscribe the function that is  called when the Observable is\n\t     * initially subscribed to. This function is given a Subscriber, to which new values\n\t     * can be `next`ed, or an `error` method can be called to raise an error, or\n\t     * `complete` can be called to notify of a successful completion.\n\t     */\n\t    function Observable(subscribe) {\n\t        this._isScalar = false;\n\t        if (subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Creates a new Observable, with this Observable as the source, and the passed\n\t     * operator defined as the new observable's operator.\n\t     * @method lift\n\t     * @param {Operator} operator the operator defining the operation to take on the observable\n\t     * @return {Observable} a new observable with the Operator applied\n\t     */\n\t    Observable.prototype.lift = function (operator) {\n\t        var observable = new Observable();\n\t        observable.source = this;\n\t        observable.operator = operator;\n\t        return observable;\n\t    };\n\t    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t        var operator = this.operator;\n\t        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\t        if (operator) {\n\t            operator.call(sink, this);\n\t        }\n\t        else {\n\t            sink.add(this._subscribe(sink));\n\t        }\n\t        if (sink.syncErrorThrowable) {\n\t            sink.syncErrorThrowable = false;\n\t            if (sink.syncErrorThrown) {\n\t                throw sink.syncErrorValue;\n\t            }\n\t        }\n\t        return sink;\n\t    };\n\t    /**\n\t     * @method forEach\n\t     * @param {Function} next a handler for each value emitted by the observable\n\t     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t     * @return {Promise} a promise that either resolves on observable completion or\n\t     *  rejects with the handled error\n\t     */\n\t    Observable.prototype.forEach = function (next, PromiseCtor) {\n\t        var _this = this;\n\t        if (!PromiseCtor) {\n\t            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                PromiseCtor = root_1.root.Rx.config.Promise;\n\t            }\n\t            else if (root_1.root.Promise) {\n\t                PromiseCtor = root_1.root.Promise;\n\t            }\n\t        }\n\t        if (!PromiseCtor) {\n\t            throw new Error('no Promise impl found');\n\t        }\n\t        return new PromiseCtor(function (resolve, reject) {\n\t            var subscription = _this.subscribe(function (value) {\n\t                if (subscription) {\n\t                    // if there is a subscription, then we can surmise\n\t                    // the next handling is asynchronous. Any errors thrown\n\t                    // need to be rejected explicitly and unsubscribe must be\n\t                    // called manually\n\t                    try {\n\t                        next(value);\n\t                    }\n\t                    catch (err) {\n\t                        reject(err);\n\t                        subscription.unsubscribe();\n\t                    }\n\t                }\n\t                else {\n\t                    // if there is NO subscription, then we're getting a nexted\n\t                    // value synchronously during subscription. We can just call it.\n\t                    // If it errors, Observable's `subscribe` will ensure the\n\t                    // unsubscription logic is called, then synchronously rethrow the error.\n\t                    // After that, Promise will trap the error and send it\n\t                    // down the rejection path.\n\t                    next(value);\n\t                }\n\t            }, reject, resolve);\n\t        });\n\t    };\n\t    Observable.prototype._subscribe = function (subscriber) {\n\t        return this.source.subscribe(subscriber);\n\t    };\n\t    /**\n\t     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t     * @method Symbol.observable\n\t     * @return {Observable} this instance of the observable\n\t     */\n\t    Observable.prototype[observable_1.$$observable] = function () {\n\t        return this;\n\t    };\n\t    // HACK: Since TypeScript inherits static properties too, we have to\n\t    // fight against TypeScript here so Subject can have a different static create signature\n\t    /**\n\t     * Creates a new cold Observable by calling the Observable constructor\n\t     * @static true\n\t     * @owner Observable\n\t     * @method create\n\t     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t     * @return {Observable} a new cold observable\n\t     */\n\t    Observable.create = function (subscribe) {\n\t        return new Observable(subscribe);\n\t    };\n\t    return Observable;\n\t}());\n\texports.Observable = Observable;\n\t//# sourceMappingURL=Observable.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t/**\n\t * window: browser in DOM main thread\n\t * self: browser in WebWorker\n\t * global: Node.js/other\n\t */\n\texports.root = (typeof window == 'object' && window.window === window && window\n\t    || typeof self == 'object' && self.self === self && self\n\t    || typeof global == 'object' && global.global === global && global);\n\tif (!exports.root) {\n\t    throw new Error('RxJS could not find any global context (window, self, global)');\n\t}\n\t//# sourceMappingURL=root.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Subscriber_1 = __webpack_require__(10);\n\tvar rxSubscriber_1 = __webpack_require__(19);\n\tvar Observer_1 = __webpack_require__(18);\n\tfunction toSubscriber(nextOrObserver, error, complete) {\n\t    if (nextOrObserver) {\n\t        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n\t            return nextOrObserver;\n\t        }\n\t        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n\t            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n\t        }\n\t    }\n\t    if (!nextOrObserver && !error && !complete) {\n\t        return new Subscriber_1.Subscriber(Observer_1.empty);\n\t    }\n\t    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t}\n\texports.toSubscriber = toSubscriber;\n\t//# sourceMappingURL=toSubscriber.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isFunction_1 = __webpack_require__(11);\n\tvar Subscription_1 = __webpack_require__(12);\n\tvar Observer_1 = __webpack_require__(18);\n\tvar rxSubscriber_1 = __webpack_require__(19);\n\t/**\n\t * Implements the {@link Observer} interface and extends the\n\t * {@link Subscription} class. While the {@link Observer} is the public API for\n\t * consuming the values of an {@link Observable}, all Observers get converted to\n\t * a Subscriber, in order to provide Subscription-like capabilities such as\n\t * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n\t * implementing operators, but it is rarely used as a public API.\n\t *\n\t * @class Subscriber<T>\n\t */\n\tvar Subscriber = (function (_super) {\n\t    __extends(Subscriber, _super);\n\t    /**\n\t     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n\t     * defined Observer or a `next` callback function.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     */\n\t    function Subscriber(destinationOrNext, error, complete) {\n\t        _super.call(this);\n\t        this.syncErrorValue = null;\n\t        this.syncErrorThrown = false;\n\t        this.syncErrorThrowable = false;\n\t        this.isStopped = false;\n\t        switch (arguments.length) {\n\t            case 0:\n\t                this.destination = Observer_1.empty;\n\t                break;\n\t            case 1:\n\t                if (!destinationOrNext) {\n\t                    this.destination = Observer_1.empty;\n\t                    break;\n\t                }\n\t                if (typeof destinationOrNext === 'object') {\n\t                    if (destinationOrNext instanceof Subscriber) {\n\t                        this.destination = destinationOrNext;\n\t                        this.destination.add(this);\n\t                    }\n\t                    else {\n\t                        this.syncErrorThrowable = true;\n\t                        this.destination = new SafeSubscriber(this, destinationOrNext);\n\t                    }\n\t                    break;\n\t                }\n\t            default:\n\t                this.syncErrorThrowable = true;\n\t                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n\t                break;\n\t        }\n\t    }\n\t    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n\t    /**\n\t     * A static factory for a Subscriber, given a (potentially partial) definition\n\t     * of an Observer.\n\t     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n\t     * Observer represented by the given arguments.\n\t     */\n\t    Subscriber.create = function (next, error, complete) {\n\t        var subscriber = new Subscriber(next, error, complete);\n\t        subscriber.syncErrorThrowable = false;\n\t        return subscriber;\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `next` from\n\t     * the Observable, with a value. The Observable may call this method 0 or more\n\t     * times.\n\t     * @param {T} [value] The `next` value.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.next = function (value) {\n\t        if (!this.isStopped) {\n\t            this._next(value);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `error` from\n\t     * the Observable, with an attached {@link Error}. Notifies the Observer that\n\t     * the Observable has experienced an error condition.\n\t     * @param {any} [err] The `error` exception.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._error(err);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive a valueless notification of type\n\t     * `complete` from the Observable. Notifies the Observer that the Observable\n\t     * has finished sending push-based notifications.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._complete();\n\t        }\n\t    };\n\t    Subscriber.prototype.unsubscribe = function () {\n\t        if (this.closed) {\n\t            return;\n\t        }\n\t        this.isStopped = true;\n\t        _super.prototype.unsubscribe.call(this);\n\t    };\n\t    Subscriber.prototype._next = function (value) {\n\t        this.destination.next(value);\n\t    };\n\t    Subscriber.prototype._error = function (err) {\n\t        this.destination.error(err);\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype._complete = function () {\n\t        this.destination.complete();\n\t        this.unsubscribe();\n\t    };\n\t    return Subscriber;\n\t}(Subscription_1.Subscription));\n\texports.Subscriber = Subscriber;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SafeSubscriber = (function (_super) {\n\t    __extends(SafeSubscriber, _super);\n\t    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n\t        _super.call(this);\n\t        this._parent = _parent;\n\t        var next;\n\t        var context = this;\n\t        if (isFunction_1.isFunction(observerOrNext)) {\n\t            next = observerOrNext;\n\t        }\n\t        else if (observerOrNext) {\n\t            context = observerOrNext;\n\t            next = observerOrNext.next;\n\t            error = observerOrNext.error;\n\t            complete = observerOrNext.complete;\n\t            if (isFunction_1.isFunction(context.unsubscribe)) {\n\t                this.add(context.unsubscribe.bind(context));\n\t            }\n\t            context.unsubscribe = this.unsubscribe.bind(this);\n\t        }\n\t        this._context = context;\n\t        this._next = next;\n\t        this._error = error;\n\t        this._complete = complete;\n\t    }\n\t    SafeSubscriber.prototype.next = function (value) {\n\t        if (!this.isStopped && this._next) {\n\t            var _parent = this._parent;\n\t            if (!_parent.syncErrorThrowable) {\n\t                this.__tryOrUnsub(this._next, value);\n\t            }\n\t            else if (this.__tryOrSetError(_parent, this._next, value)) {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var _parent = this._parent;\n\t            if (this._error) {\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parent, this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else if (!_parent.syncErrorThrowable) {\n\t                this.unsubscribe();\n\t                throw err;\n\t            }\n\t            else {\n\t                _parent.syncErrorValue = err;\n\t                _parent.syncErrorThrown = true;\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            var _parent = this._parent;\n\t            if (this._complete) {\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parent, this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            this.unsubscribe();\n\t            throw err;\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            parent.syncErrorValue = err;\n\t            parent.syncErrorThrown = true;\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    SafeSubscriber.prototype._unsubscribe = function () {\n\t        var _parent = this._parent;\n\t        this._context = null;\n\t        this._parent = null;\n\t        _parent.unsubscribe();\n\t    };\n\t    return SafeSubscriber;\n\t}(Subscriber));\n\t//# sourceMappingURL=Subscriber.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isFunction(x) {\n\t    return typeof x === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t//# sourceMappingURL=isFunction.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar isArray_1 = __webpack_require__(13);\n\tvar isObject_1 = __webpack_require__(14);\n\tvar isFunction_1 = __webpack_require__(11);\n\tvar tryCatch_1 = __webpack_require__(15);\n\tvar errorObject_1 = __webpack_require__(16);\n\tvar UnsubscriptionError_1 = __webpack_require__(17);\n\t/**\n\t * Represents a disposable resource, such as the execution of an Observable. A\n\t * Subscription has one important method, `unsubscribe`, that takes no argument\n\t * and just disposes the resource held by the subscription.\n\t *\n\t * Additionally, subscriptions may be grouped together through the `add()`\n\t * method, which will attach a child Subscription to the current Subscription.\n\t * When a Subscription is unsubscribed, all its children (and its grandchildren)\n\t * will be unsubscribed as well.\n\t *\n\t * @class Subscription\n\t */\n\tvar Subscription = (function () {\n\t    /**\n\t     * @param {function(): void} [unsubscribe] A function describing how to\n\t     * perform the disposal of resources when the `unsubscribe` method is called.\n\t     */\n\t    function Subscription(unsubscribe) {\n\t        /**\n\t         * A flag to indicate whether this Subscription has already been unsubscribed.\n\t         * @type {boolean}\n\t         */\n\t        this.closed = false;\n\t        if (unsubscribe) {\n\t            this._unsubscribe = unsubscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Disposes the resources held by the subscription. May, for instance, cancel\n\t     * an ongoing Observable execution or cancel any other type of work that\n\t     * started when the Subscription was created.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.unsubscribe = function () {\n\t        var hasErrors = false;\n\t        var errors;\n\t        if (this.closed) {\n\t            return;\n\t        }\n\t        this.closed = true;\n\t        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n\t        this._subscriptions = null;\n\t        if (isFunction_1.isFunction(_unsubscribe)) {\n\t            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\t            if (trial === errorObject_1.errorObject) {\n\t                hasErrors = true;\n\t                (errors = errors || []).push(errorObject_1.errorObject.e);\n\t            }\n\t        }\n\t        if (isArray_1.isArray(_subscriptions)) {\n\t            var index = -1;\n\t            var len = _subscriptions.length;\n\t            while (++index < len) {\n\t                var sub = _subscriptions[index];\n\t                if (isObject_1.isObject(sub)) {\n\t                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\t                    if (trial === errorObject_1.errorObject) {\n\t                        hasErrors = true;\n\t                        errors = errors || [];\n\t                        var err = errorObject_1.errorObject.e;\n\t                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n\t                            errors = errors.concat(err.errors);\n\t                        }\n\t                        else {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (hasErrors) {\n\t            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n\t        }\n\t    };\n\t    /**\n\t     * Adds a tear down to be called during the unsubscribe() of this\n\t     * Subscription.\n\t     *\n\t     * If the tear down being added is a subscription that is already\n\t     * unsubscribed, is the same reference `add` is being called on, or is\n\t     * `Subscription.EMPTY`, it will not be added.\n\t     *\n\t     * If this subscription is already in an `closed` state, the passed\n\t     * tear down logic will be executed immediately.\n\t     *\n\t     * @param {TeardownLogic} teardown The additional logic to execute on\n\t     * teardown.\n\t     * @return {Subscription} Returns the Subscription used or created to be\n\t     * added to the inner subscriptions list. This Subscription can be used with\n\t     * `remove()` to remove the passed teardown logic from the inner subscriptions\n\t     * list.\n\t     */\n\t    Subscription.prototype.add = function (teardown) {\n\t        if (!teardown || (teardown === Subscription.EMPTY)) {\n\t            return Subscription.EMPTY;\n\t        }\n\t        if (teardown === this) {\n\t            return this;\n\t        }\n\t        var sub = teardown;\n\t        switch (typeof teardown) {\n\t            case 'function':\n\t                sub = new Subscription(teardown);\n\t            case 'object':\n\t                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n\t                    break;\n\t                }\n\t                else if (this.closed) {\n\t                    sub.unsubscribe();\n\t                }\n\t                else {\n\t                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n\t                }\n\t                break;\n\t            default:\n\t                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n\t        }\n\t        return sub;\n\t    };\n\t    /**\n\t     * Removes a Subscription from the internal list of subscriptions that will\n\t     * unsubscribe during the unsubscribe process of this Subscription.\n\t     * @param {Subscription} subscription The subscription to remove.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.remove = function (subscription) {\n\t        // HACK: This might be redundant because of the logic in `add()`\n\t        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n\t            return;\n\t        }\n\t        var subscriptions = this._subscriptions;\n\t        if (subscriptions) {\n\t            var subscriptionIndex = subscriptions.indexOf(subscription);\n\t            if (subscriptionIndex !== -1) {\n\t                subscriptions.splice(subscriptionIndex, 1);\n\t            }\n\t        }\n\t    };\n\t    Subscription.EMPTY = (function (empty) {\n\t        empty.closed = true;\n\t        return empty;\n\t    }(new Subscription()));\n\t    return Subscription;\n\t}());\n\texports.Subscription = Subscription;\n\t//# sourceMappingURL=Subscription.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\t//# sourceMappingURL=isArray.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isObject(x) {\n\t    return x != null && typeof x === 'object';\n\t}\n\texports.isObject = isObject;\n\t//# sourceMappingURL=isObject.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar errorObject_1 = __webpack_require__(16);\n\tvar tryCatchTarget;\n\tfunction tryCatcher() {\n\t    try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t    }\n\t    catch (e) {\n\t        errorObject_1.errorObject.e = e;\n\t        return errorObject_1.errorObject;\n\t    }\n\t}\n\tfunction tryCatch(fn) {\n\t    tryCatchTarget = fn;\n\t    return tryCatcher;\n\t}\n\texports.tryCatch = tryCatch;\n\t;\n\t//# sourceMappingURL=tryCatch.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t// typeof any so that it we don't have to cast when comparing a result to the error object\n\texports.errorObject = { e: {} };\n\t//# sourceMappingURL=errorObject.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when one or more errors have occurred during the\n\t * `unsubscribe` of a {@link Subscription}.\n\t */\n\tvar UnsubscriptionError = (function (_super) {\n\t    __extends(UnsubscriptionError, _super);\n\t    function UnsubscriptionError(errors) {\n\t        _super.call(this);\n\t        this.errors = errors;\n\t        var err = Error.call(this, errors ?\n\t            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n\t        this.name = err.name = 'UnsubscriptionError';\n\t        this.stack = err.stack;\n\t        this.message = err.message;\n\t    }\n\t    return UnsubscriptionError;\n\t}(Error));\n\texports.UnsubscriptionError = UnsubscriptionError;\n\t//# sourceMappingURL=UnsubscriptionError.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.empty = {\n\t    closed: true,\n\t    next: function (value) { },\n\t    error: function (err) { throw err; },\n\t    complete: function () { }\n\t};\n\t//# sourceMappingURL=Observer.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(8);\n\tvar Symbol = root_1.root.Symbol;\n\texports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n\t    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\t//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(8);\n\tfunction getSymbolObservable(context) {\n\t    var $$observable;\n\t    var Symbol = context.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (Symbol.observable) {\n\t            $$observable = Symbol.observable;\n\t        }\n\t        else {\n\t            $$observable = Symbol('observable');\n\t            Symbol.observable = $$observable;\n\t        }\n\t    }\n\t    else {\n\t        $$observable = '@@observable';\n\t    }\n\t    return $$observable;\n\t}\n\texports.getSymbolObservable = getSymbolObservable;\n\texports.$$observable = getSymbolObservable(root_1.root);\n\t//# sourceMappingURL=observable.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when an action is invalid because the object has been\n\t * unsubscribed.\n\t *\n\t * @see {@link Subject}\n\t * @see {@link BehaviorSubject}\n\t *\n\t * @class ObjectUnsubscribedError\n\t */\n\tvar ObjectUnsubscribedError = (function (_super) {\n\t    __extends(ObjectUnsubscribedError, _super);\n\t    function ObjectUnsubscribedError() {\n\t        var err = _super.call(this, 'object unsubscribed');\n\t        this.name = err.name = 'ObjectUnsubscribedError';\n\t        this.stack = err.stack;\n\t        this.message = err.message;\n\t    }\n\t    return ObjectUnsubscribedError;\n\t}(Error));\n\texports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n\t//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscription_1 = __webpack_require__(12);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SubjectSubscription = (function (_super) {\n\t    __extends(SubjectSubscription, _super);\n\t    function SubjectSubscription(subject, subscriber) {\n\t        _super.call(this);\n\t        this.subject = subject;\n\t        this.subscriber = subscriber;\n\t        this.closed = false;\n\t    }\n\t    SubjectSubscription.prototype.unsubscribe = function () {\n\t        if (this.closed) {\n\t            return;\n\t        }\n\t        this.closed = true;\n\t        var subject = this.subject;\n\t        var observers = subject.observers;\n\t        this.subject = null;\n\t        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n\t            return;\n\t        }\n\t        var subscriberIndex = observers.indexOf(this.subscriber);\n\t        if (subscriberIndex !== -1) {\n\t            observers.splice(subscriberIndex, 1);\n\t        }\n\t    };\n\t    return SubjectSubscription;\n\t}(Subscription_1.Subscription));\n\texports.SubjectSubscription = SubjectSubscription;\n\t//# sourceMappingURL=SubjectSubscription.js.map\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar AjaxObservable_1 = __webpack_require__(24);\n\texports.ajax = AjaxObservable_1.AjaxObservable.create;\n\t//# sourceMappingURL=ajax.js.map\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar root_1 = __webpack_require__(8);\n\tvar tryCatch_1 = __webpack_require__(15);\n\tvar errorObject_1 = __webpack_require__(16);\n\tvar Observable_1 = __webpack_require__(7);\n\tvar Subscriber_1 = __webpack_require__(10);\n\tvar map_1 = __webpack_require__(25);\n\tfunction getCORSRequest() {\n\t    if (root_1.root.XMLHttpRequest) {\n\t        var xhr = new root_1.root.XMLHttpRequest();\n\t        if ('withCredentials' in xhr) {\n\t            xhr.withCredentials = !!this.withCredentials;\n\t        }\n\t        return xhr;\n\t    }\n\t    else if (!!root_1.root.XDomainRequest) {\n\t        return new root_1.root.XDomainRequest();\n\t    }\n\t    else {\n\t        throw new Error('CORS is not supported by your browser');\n\t    }\n\t}\n\tfunction getXMLHttpRequest() {\n\t    if (root_1.root.XMLHttpRequest) {\n\t        return new root_1.root.XMLHttpRequest();\n\t    }\n\t    else {\n\t        var progId = void 0;\n\t        try {\n\t            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n\t            for (var i = 0; i < 3; i++) {\n\t                try {\n\t                    progId = progIds[i];\n\t                    if (new root_1.root.ActiveXObject(progId)) {\n\t                        break;\n\t                    }\n\t                }\n\t                catch (e) {\n\t                }\n\t            }\n\t            return new root_1.root.ActiveXObject(progId);\n\t        }\n\t        catch (e) {\n\t            throw new Error('XMLHttpRequest is not supported by your browser');\n\t        }\n\t    }\n\t}\n\tfunction ajaxGet(url, headers) {\n\t    if (headers === void 0) { headers = null; }\n\t    return new AjaxObservable({ method: 'GET', url: url, headers: headers });\n\t}\n\texports.ajaxGet = ajaxGet;\n\t;\n\tfunction ajaxPost(url, body, headers) {\n\t    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });\n\t}\n\texports.ajaxPost = ajaxPost;\n\t;\n\tfunction ajaxDelete(url, headers) {\n\t    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });\n\t}\n\texports.ajaxDelete = ajaxDelete;\n\t;\n\tfunction ajaxPut(url, body, headers) {\n\t    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });\n\t}\n\texports.ajaxPut = ajaxPut;\n\t;\n\tfunction ajaxGetJSON(url, headers) {\n\t    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })\n\t        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));\n\t}\n\texports.ajaxGetJSON = ajaxGetJSON;\n\t;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar AjaxObservable = (function (_super) {\n\t    __extends(AjaxObservable, _super);\n\t    function AjaxObservable(urlOrRequest) {\n\t        _super.call(this);\n\t        var request = {\n\t            async: true,\n\t            createXHR: function () {\n\t                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n\t            },\n\t            crossDomain: false,\n\t            withCredentials: false,\n\t            headers: {},\n\t            method: 'GET',\n\t            responseType: 'json',\n\t            timeout: 0\n\t        };\n\t        if (typeof urlOrRequest === 'string') {\n\t            request.url = urlOrRequest;\n\t        }\n\t        else {\n\t            for (var prop in urlOrRequest) {\n\t                if (urlOrRequest.hasOwnProperty(prop)) {\n\t                    request[prop] = urlOrRequest[prop];\n\t                }\n\t            }\n\t        }\n\t        this.request = request;\n\t    }\n\t    AjaxObservable.prototype._subscribe = function (subscriber) {\n\t        return new AjaxSubscriber(subscriber, this.request);\n\t    };\n\t    /**\n\t     * Creates an observable for an Ajax request with either a request object with\n\t     * url, headers, etc or a string for a URL.\n\t     *\n\t     * @example\n\t     * source = Rx.Observable.ajax('/products');\n\t     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n\t     *\n\t     * @param {string|Object} request Can be one of the following:\n\t     *   A string of the URL to make the Ajax call.\n\t     *   An object with the following properties\n\t     *   - url: URL of the request\n\t     *   - body: The body of the request\n\t     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n\t     *   - async: Whether the request is async\n\t     *   - headers: Optional headers\n\t     *   - crossDomain: true if a cross domain request, else false\n\t     *   - createXHR: a function to override if you need to use an alternate\n\t     *   XMLHttpRequest implementation.\n\t     *   - resultSelector: a function to use to alter the output value type of\n\t     *   the Observable. Gets {@link AjaxResponse} as an argument.\n\t     * @return {Observable} An observable sequence containing the XMLHttpRequest.\n\t     * @static true\n\t     * @name ajax\n\t     * @owner Observable\n\t    */\n\t    AjaxObservable.create = (function () {\n\t        var create = function (urlOrRequest) {\n\t            return new AjaxObservable(urlOrRequest);\n\t        };\n\t        create.get = ajaxGet;\n\t        create.post = ajaxPost;\n\t        create.delete = ajaxDelete;\n\t        create.put = ajaxPut;\n\t        create.getJSON = ajaxGetJSON;\n\t        return create;\n\t    })();\n\t    return AjaxObservable;\n\t}(Observable_1.Observable));\n\texports.AjaxObservable = AjaxObservable;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar AjaxSubscriber = (function (_super) {\n\t    __extends(AjaxSubscriber, _super);\n\t    function AjaxSubscriber(destination, request) {\n\t        _super.call(this, destination);\n\t        this.request = request;\n\t        this.done = false;\n\t        var headers = request.headers = request.headers || {};\n\t        // force CORS if requested\n\t        if (!request.crossDomain && !headers['X-Requested-With']) {\n\t            headers['X-Requested-With'] = 'XMLHttpRequest';\n\t        }\n\t        // ensure content type is set\n\t        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n\t            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n\t        }\n\t        // properly serialize body\n\t        request.body = this.serializeBody(request.body, request.headers['Content-Type']);\n\t        this.send();\n\t    }\n\t    AjaxSubscriber.prototype.next = function (e) {\n\t        this.done = true;\n\t        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;\n\t        var response = new AjaxResponse(e, xhr, request);\n\t        destination.next(response);\n\t    };\n\t    AjaxSubscriber.prototype.send = function () {\n\t        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;\n\t        var createXHR = request.createXHR;\n\t        var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n\t        if (xhr === errorObject_1.errorObject) {\n\t            this.error(errorObject_1.errorObject.e);\n\t        }\n\t        else {\n\t            this.xhr = xhr;\n\t            // open XHR first\n\t            var result = void 0;\n\t            if (user) {\n\t                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n\t            }\n\t            else {\n\t                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n\t            }\n\t            if (result === errorObject_1.errorObject) {\n\t                this.error(errorObject_1.errorObject.e);\n\t                return null;\n\t            }\n\t            // timeout and responseType can be set once the XHR is open\n\t            xhr.timeout = request.timeout;\n\t            xhr.responseType = request.responseType;\n\t            // set headers\n\t            this.setHeaders(xhr, headers);\n\t            // now set up the events\n\t            this.setupEvents(xhr, request);\n\t            // finally send the request\n\t            if (body) {\n\t                xhr.send(body);\n\t            }\n\t            else {\n\t                xhr.send();\n\t            }\n\t        }\n\t        return xhr;\n\t    };\n\t    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n\t        if (!body || typeof body === 'string') {\n\t            return body;\n\t        }\n\t        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n\t            return body;\n\t        }\n\t        if (contentType) {\n\t            var splitIndex = contentType.indexOf(';');\n\t            if (splitIndex !== -1) {\n\t                contentType = contentType.substring(0, splitIndex);\n\t            }\n\t        }\n\t        switch (contentType) {\n\t            case 'application/x-www-form-urlencoded':\n\t                return Object.keys(body).map(function (key) { return (encodeURI(key) + \"=\" + encodeURI(body[key])); }).join('&');\n\t            case 'application/json':\n\t                return JSON.stringify(body);\n\t            default:\n\t                return body;\n\t        }\n\t    };\n\t    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n\t        for (var key in headers) {\n\t            if (headers.hasOwnProperty(key)) {\n\t                xhr.setRequestHeader(key, headers[key]);\n\t            }\n\t        }\n\t    };\n\t    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n\t        var progressSubscriber = request.progressSubscriber;\n\t        function xhrTimeout(e) {\n\t            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n\t            if (progressSubscriber) {\n\t                progressSubscriber.error(e);\n\t            }\n\t            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n\t        }\n\t        ;\n\t        xhr.ontimeout = xhrTimeout;\n\t        xhrTimeout.request = request;\n\t        xhrTimeout.subscriber = this;\n\t        xhrTimeout.progressSubscriber = progressSubscriber;\n\t        if (xhr.upload && 'withCredentials' in xhr && root_1.root.XDomainRequest) {\n\t            if (progressSubscriber) {\n\t                var xhrProgress_1;\n\t                xhrProgress_1 = function (e) {\n\t                    var progressSubscriber = xhrProgress_1.progressSubscriber;\n\t                    progressSubscriber.next(e);\n\t                };\n\t                xhr.onprogress = xhrProgress_1;\n\t                xhrProgress_1.progressSubscriber = progressSubscriber;\n\t            }\n\t            var xhrError_1;\n\t            xhrError_1 = function (e) {\n\t                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;\n\t                if (progressSubscriber) {\n\t                    progressSubscriber.error(e);\n\t                }\n\t                subscriber.error(new AjaxError('ajax error', this, request));\n\t            };\n\t            xhr.onerror = xhrError_1;\n\t            xhrError_1.request = request;\n\t            xhrError_1.subscriber = this;\n\t            xhrError_1.progressSubscriber = progressSubscriber;\n\t        }\n\t        function xhrReadyStateChange(e) {\n\t            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n\t            if (this.readyState === 4) {\n\t                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n\t                var status_1 = this.status === 1223 ? 204 : this.status;\n\t                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n\t                // fix status code when it is 0 (0 status is undocumented).\n\t                // Occurs when accessing file resources or on Android 4.1 stock browser\n\t                // while retrieving files from application cache.\n\t                if (status_1 === 0) {\n\t                    status_1 = response ? 200 : 0;\n\t                }\n\t                if (200 <= status_1 && status_1 < 300) {\n\t                    if (progressSubscriber) {\n\t                        progressSubscriber.complete();\n\t                    }\n\t                    subscriber.next(e);\n\t                    subscriber.complete();\n\t                }\n\t                else {\n\t                    if (progressSubscriber) {\n\t                        progressSubscriber.error(e);\n\t                    }\n\t                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n\t                }\n\t            }\n\t        }\n\t        ;\n\t        xhr.onreadystatechange = xhrReadyStateChange;\n\t        xhrReadyStateChange.subscriber = this;\n\t        xhrReadyStateChange.progressSubscriber = progressSubscriber;\n\t        xhrReadyStateChange.request = request;\n\t    };\n\t    AjaxSubscriber.prototype.unsubscribe = function () {\n\t        var _a = this, done = _a.done, xhr = _a.xhr;\n\t        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n\t            xhr.abort();\n\t        }\n\t        _super.prototype.unsubscribe.call(this);\n\t    };\n\t    return AjaxSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.AjaxSubscriber = AjaxSubscriber;\n\t/**\n\t * A normalized AJAX response.\n\t *\n\t * @see {@link ajax}\n\t *\n\t * @class AjaxResponse\n\t */\n\tvar AjaxResponse = (function () {\n\t    function AjaxResponse(originalEvent, xhr, request) {\n\t        this.originalEvent = originalEvent;\n\t        this.xhr = xhr;\n\t        this.request = request;\n\t        this.status = xhr.status;\n\t        this.responseType = xhr.responseType || request.responseType;\n\t        switch (this.responseType) {\n\t            case 'json':\n\t                if ('response' in xhr) {\n\t                    //IE does not support json as responseType, parse it internally\n\t                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n\t                }\n\t                else {\n\t                    this.response = JSON.parse(xhr.responseText || 'null');\n\t                }\n\t                break;\n\t            case 'xml':\n\t                this.response = xhr.responseXML;\n\t                break;\n\t            case 'text':\n\t            default:\n\t                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;\n\t                break;\n\t        }\n\t    }\n\t    return AjaxResponse;\n\t}());\n\texports.AjaxResponse = AjaxResponse;\n\t/**\n\t * A normalized AJAX error.\n\t *\n\t * @see {@link ajax}\n\t *\n\t * @class AjaxError\n\t */\n\tvar AjaxError = (function (_super) {\n\t    __extends(AjaxError, _super);\n\t    function AjaxError(message, xhr, request) {\n\t        _super.call(this, message);\n\t        this.message = message;\n\t        this.xhr = xhr;\n\t        this.request = request;\n\t        this.status = xhr.status;\n\t    }\n\t    return AjaxError;\n\t}(Error));\n\texports.AjaxError = AjaxError;\n\t/**\n\t * @see {@link ajax}\n\t *\n\t * @class AjaxTimeoutError\n\t */\n\tvar AjaxTimeoutError = (function (_super) {\n\t    __extends(AjaxTimeoutError, _super);\n\t    function AjaxTimeoutError(xhr, request) {\n\t        _super.call(this, 'ajax timeout', xhr, request);\n\t    }\n\t    return AjaxTimeoutError;\n\t}(AjaxError));\n\texports.AjaxTimeoutError = AjaxTimeoutError;\n\t//# sourceMappingURL=AjaxObservable.js.map\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(10);\n\t/**\n\t * Applies a given `project` function to each value emitted by the source\n\t * Observable, and emits the resulting values as an Observable.\n\t *\n\t * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n\t * it passes each source value through a transformation function to get\n\t * corresponding output values.</span>\n\t *\n\t * <img src=\"./img/map.png\" width=\"100%\">\n\t *\n\t * Similar to the well known `Array.prototype.map` function, this operator\n\t * applies a projection to each value and emits that projection in the output\n\t * Observable.\n\t *\n\t * @example <caption>Map every every click to the clientX position of that click</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var positions = clicks.map(ev => ev.clientX);\n\t * positions.subscribe(x => console.log(x));\n\t *\n\t * @see {@link mapTo}\n\t * @see {@link pluck}\n\t *\n\t * @param {function(value: T, index: number): R} project The function to apply\n\t * to each `value` emitted by the source Observable. The `index` parameter is\n\t * the number `i` for the i-th emission that has happened since the\n\t * subscription, starting from the number `0`.\n\t * @param {any} [thisArg] An optional argument to define what `this` is in the\n\t * `project` function.\n\t * @return {Observable<R>} An Observable that emits the values from the source\n\t * Observable transformed by the given `project` function.\n\t * @method map\n\t * @owner Observable\n\t */\n\tfunction map(project, thisArg) {\n\t    if (typeof project !== 'function') {\n\t        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n\t    }\n\t    return this.lift(new MapOperator(project, thisArg));\n\t}\n\texports.map = map;\n\tvar MapOperator = (function () {\n\t    function MapOperator(project, thisArg) {\n\t        this.project = project;\n\t        this.thisArg = thisArg;\n\t    }\n\t    MapOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n\t    };\n\t    return MapOperator;\n\t}());\n\texports.MapOperator = MapOperator;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar MapSubscriber = (function (_super) {\n\t    __extends(MapSubscriber, _super);\n\t    function MapSubscriber(destination, project, thisArg) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.count = 0;\n\t        this.thisArg = thisArg || this;\n\t    }\n\t    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n\t    // using try/catch optimizations.\n\t    MapSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.project.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    return MapSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=map.js.map\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(7);\n\tvar empty_1 = __webpack_require__(27);\n\tObservable_1.Observable.empty = empty_1.empty;\n\t//# sourceMappingURL=empty.js.map\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar EmptyObservable_1 = __webpack_require__(28);\n\texports.empty = EmptyObservable_1.EmptyObservable.create;\n\t//# sourceMappingURL=empty.js.map\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(7);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar EmptyObservable = (function (_super) {\n\t    __extends(EmptyObservable, _super);\n\t    function EmptyObservable(scheduler) {\n\t        _super.call(this);\n\t        this.scheduler = scheduler;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits no items to the Observer and immediately\n\t     * emits a complete notification.\n\t     *\n\t     * <span class=\"informal\">Just emits 'complete', and nothing else.\n\t     * </span>\n\t     *\n\t     * <img src=\"./img/empty.png\" width=\"100%\">\n\t     *\n\t     * This static operator is useful for creating a simple Observable that only\n\t     * emits the complete notification. It can be used for composing with other\n\t     * Observables, such as in a {@link mergeMap}.\n\t     *\n\t     * @example <caption>Emit the number 7, then complete.</caption>\n\t     * var result = Rx.Observable.empty().startWith(7);\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n\t     * var interval = Rx.Observable.interval(1000);\n\t     * var result = interval.mergeMap(x =>\n\t     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n\t     * );\n\t     * result.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link create}\n\t     * @see {@link never}\n\t     * @see {@link of}\n\t     * @see {@link throw}\n\t     *\n\t     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n\t     * the emission of the complete notification.\n\t     * @return {Observable} An \"empty\" Observable: emits only the complete\n\t     * notification.\n\t     * @static true\n\t     * @name empty\n\t     * @owner Observable\n\t     */\n\t    EmptyObservable.create = function (scheduler) {\n\t        return new EmptyObservable(scheduler);\n\t    };\n\t    EmptyObservable.dispatch = function (arg) {\n\t        var subscriber = arg.subscriber;\n\t        subscriber.complete();\n\t    };\n\t    EmptyObservable.prototype._subscribe = function (subscriber) {\n\t        var scheduler = this.scheduler;\n\t        if (scheduler) {\n\t            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n\t        }\n\t        else {\n\t            subscriber.complete();\n\t        }\n\t    };\n\t    return EmptyObservable;\n\t}(Observable_1.Observable));\n\texports.EmptyObservable = EmptyObservable;\n\t//# sourceMappingURL=EmptyObservable.js.map\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(7);\n\tvar filter_1 = __webpack_require__(30);\n\tObservable_1.Observable.prototype.filter = filter_1.filter;\n\t//# sourceMappingURL=filter.js.map\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(10);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Filter items emitted by the source Observable by only emitting those that\n\t * satisfy a specified predicate.\n\t *\n\t * <span class=\"informal\">Like\n\t * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n\t * it only emits a value from the source if it passes a criterion function.</span>\n\t *\n\t * <img src=\"./img/filter.png\" width=\"100%\">\n\t *\n\t * Similar to the well-known `Array.prototype.filter` method, this operator\n\t * takes values from the source Observable, passes them through a `predicate`\n\t * function and only emits those values that yielded `true`.\n\t *\n\t * @example <caption>Emit only click events whose target was a DIV element</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n\t * clicksOnDivs.subscribe(x => console.log(x));\n\t *\n\t * @see {@link distinct}\n\t * @see {@link distinctKey}\n\t * @see {@link distinctUntilChanged}\n\t * @see {@link distinctUntilKeyChanged}\n\t * @see {@link ignoreElements}\n\t * @see {@link partition}\n\t * @see {@link skip}\n\t *\n\t * @param {function(value: T, index: number): boolean} predicate A function that\n\t * evaluates each value emitted by the source Observable. If it returns `true`,\n\t * the value is emitted, if `false` the value is not passed to the output\n\t * Observable. The `index` parameter is the number `i` for the i-th source\n\t * emission that has happened since the subscription, starting from the number\n\t * `0`.\n\t * @param {any} [thisArg] An optional argument to determine the value of `this`\n\t * in the `predicate` function.\n\t * @return {Observable} An Observable of values from the source that were\n\t * allowed by the `predicate` function.\n\t * @method filter\n\t * @owner Observable\n\t */\n\tfunction filter(predicate, thisArg) {\n\t    return this.lift(new FilterOperator(predicate, thisArg));\n\t}\n\texports.filter = filter;\n\tvar FilterOperator = (function () {\n\t    function FilterOperator(predicate, thisArg) {\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t    }\n\t    FilterOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n\t    };\n\t    return FilterOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar FilterSubscriber = (function (_super) {\n\t    __extends(FilterSubscriber, _super);\n\t    function FilterSubscriber(destination, predicate, thisArg) {\n\t        _super.call(this, destination);\n\t        this.predicate = predicate;\n\t        this.thisArg = thisArg;\n\t        this.count = 0;\n\t        this.predicate = predicate;\n\t    }\n\t    // the try catch block below is left specifically for\n\t    // optimization and perf reasons. a tryCatcher is not necessary here.\n\t    FilterSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        try {\n\t            result = this.predicate.call(this.thisArg, value, this.count++);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        if (result) {\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    return FilterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\t//# sourceMappingURL=filter.js.map\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(7);\n\tvar map_1 = __webpack_require__(25);\n\tObservable_1.Observable.prototype.map = map_1.map;\n\t//# sourceMappingURL=map.js.map\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(7);\n\tvar catch_1 = __webpack_require__(33);\n\tObservable_1.Observable.prototype.catch = catch_1._catch;\n\tObservable_1.Observable.prototype._catch = catch_1._catch;\n\t//# sourceMappingURL=catch.js.map\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(34);\n\tvar subscribeToResult_1 = __webpack_require__(35);\n\t/**\n\t * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n\t * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n\t *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n\t *  is returned by the `selector` will be used to continue the observable chain.\n\t * @return {Observable} an observable that originates from either the source or the observable returned by the\n\t *  catch `selector` function.\n\t * @method catch\n\t * @name catch\n\t * @owner Observable\n\t */\n\tfunction _catch(selector) {\n\t    var operator = new CatchOperator(selector);\n\t    var caught = this.lift(operator);\n\t    return (operator.caught = caught);\n\t}\n\texports._catch = _catch;\n\tvar CatchOperator = (function () {\n\t    function CatchOperator(selector) {\n\t        this.selector = selector;\n\t    }\n\t    CatchOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n\t    };\n\t    return CatchOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar CatchSubscriber = (function (_super) {\n\t    __extends(CatchSubscriber, _super);\n\t    function CatchSubscriber(destination, selector, caught) {\n\t        _super.call(this, destination);\n\t        this.selector = selector;\n\t        this.caught = caught;\n\t    }\n\t    // NOTE: overriding `error` instead of `_error` because we don't want\n\t    // to have this flag this subscriber as `isStopped`.\n\t    CatchSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var result = void 0;\n\t            try {\n\t                result = this.selector(err, this.caught);\n\t            }\n\t            catch (err) {\n\t                this.destination.error(err);\n\t                return;\n\t            }\n\t            this.unsubscribe();\n\t            this.destination.remove(this);\n\t            subscribeToResult_1.subscribeToResult(this, result);\n\t        }\n\t    };\n\t    return CatchSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t//# sourceMappingURL=catch.js.map\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(10);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar OuterSubscriber = (function (_super) {\n\t    __extends(OuterSubscriber, _super);\n\t    function OuterSubscriber() {\n\t        _super.apply(this, arguments);\n\t    }\n\t    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this.destination.next(innerValue);\n\t    };\n\t    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n\t        this.destination.error(error);\n\t    };\n\t    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        this.destination.complete();\n\t    };\n\t    return OuterSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.OuterSubscriber = OuterSubscriber;\n\t//# sourceMappingURL=OuterSubscriber.js.map\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(8);\n\tvar isArray_1 = __webpack_require__(13);\n\tvar isPromise_1 = __webpack_require__(36);\n\tvar Observable_1 = __webpack_require__(7);\n\tvar iterator_1 = __webpack_require__(37);\n\tvar InnerSubscriber_1 = __webpack_require__(38);\n\tvar observable_1 = __webpack_require__(20);\n\tfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n\t    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\t    if (destination.closed) {\n\t        return null;\n\t    }\n\t    if (result instanceof Observable_1.Observable) {\n\t        if (result._isScalar) {\n\t            destination.next(result.value);\n\t            destination.complete();\n\t            return null;\n\t        }\n\t        else {\n\t            return result.subscribe(destination);\n\t        }\n\t    }\n\t    if (isArray_1.isArray(result)) {\n\t        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n\t            destination.next(result[i]);\n\t        }\n\t        if (!destination.closed) {\n\t            destination.complete();\n\t        }\n\t    }\n\t    else if (isPromise_1.isPromise(result)) {\n\t        result.then(function (value) {\n\t            if (!destination.closed) {\n\t                destination.next(value);\n\t                destination.complete();\n\t            }\n\t        }, function (err) { return destination.error(err); })\n\t            .then(null, function (err) {\n\t            // Escaping the Promise trap: globally throw unhandled errors\n\t            root_1.root.setTimeout(function () { throw err; });\n\t        });\n\t        return destination;\n\t    }\n\t    else if (typeof result[iterator_1.$$iterator] === 'function') {\n\t        var iterator = result[iterator_1.$$iterator]();\n\t        do {\n\t            var item = iterator.next();\n\t            if (item.done) {\n\t                destination.complete();\n\t                break;\n\t            }\n\t            destination.next(item.value);\n\t            if (destination.closed) {\n\t                break;\n\t            }\n\t        } while (true);\n\t    }\n\t    else if (typeof result[observable_1.$$observable] === 'function') {\n\t        var obs = result[observable_1.$$observable]();\n\t        if (typeof obs.subscribe !== 'function') {\n\t            destination.error(new Error('invalid observable'));\n\t        }\n\t        else {\n\t            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n\t        }\n\t    }\n\t    else {\n\t        destination.error(new TypeError('unknown type returned'));\n\t    }\n\t    return null;\n\t}\n\texports.subscribeToResult = subscribeToResult;\n\t//# sourceMappingURL=subscribeToResult.js.map\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isPromise(value) {\n\t    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n\t}\n\texports.isPromise = isPromise;\n\t//# sourceMappingURL=isPromise.js.map\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(8);\n\tfunction symbolIteratorPonyfill(root) {\n\t    var Symbol = root.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (!Symbol.iterator) {\n\t            Symbol.iterator = Symbol('iterator polyfill');\n\t        }\n\t        return Symbol.iterator;\n\t    }\n\t    else {\n\t        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n\t        var Set_1 = root.Set;\n\t        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n\t            return '@@iterator';\n\t        }\n\t        var Map_1 = root.Map;\n\t        // required for compatability with es6-shim\n\t        if (Map_1) {\n\t            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n\t            for (var i = 0; i < keys.length; ++i) {\n\t                var key = keys[i];\n\t                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n\t                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n\t                    return key;\n\t                }\n\t            }\n\t        }\n\t        return '@@iterator';\n\t    }\n\t}\n\texports.symbolIteratorPonyfill = symbolIteratorPonyfill;\n\texports.$$iterator = symbolIteratorPonyfill(root_1.root);\n\t//# sourceMappingURL=iterator.js.map\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Subscriber_1 = __webpack_require__(10);\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar InnerSubscriber = (function (_super) {\n\t    __extends(InnerSubscriber, _super);\n\t    function InnerSubscriber(parent, outerValue, outerIndex) {\n\t        _super.call(this);\n\t        this.parent = parent;\n\t        this.outerValue = outerValue;\n\t        this.outerIndex = outerIndex;\n\t        this.index = 0;\n\t    }\n\t    InnerSubscriber.prototype._next = function (value) {\n\t        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n\t    };\n\t    InnerSubscriber.prototype._error = function (error) {\n\t        this.parent.notifyError(error, this);\n\t        this.unsubscribe();\n\t    };\n\t    InnerSubscriber.prototype._complete = function () {\n\t        this.parent.notifyComplete(this);\n\t        this.unsubscribe();\n\t    };\n\t    return InnerSubscriber;\n\t}(Subscriber_1.Subscriber));\n\texports.InnerSubscriber = InnerSubscriber;\n\t//# sourceMappingURL=InnerSubscriber.js.map\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(7);\n\tvar switchMap_1 = __webpack_require__(40);\n\tObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n\t//# sourceMappingURL=switchMap.js.map\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(34);\n\tvar subscribeToResult_1 = __webpack_require__(35);\n\t/* tslint:disable:max-line-length */\n\t/**\n\t * Projects each source value to an Observable which is merged in the output\n\t * Observable, emitting values only from the most recently projected Observable.\n\t *\n\t * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n\t * these inner Observables using {@link switch}.</span>\n\t *\n\t * <img src=\"./img/switchMap.png\" width=\"100%\">\n\t *\n\t * Returns an Observable that emits items based on applying a function that you\n\t * supply to each item emitted by the source Observable, where that function\n\t * returns an (so-called \"inner\") Observable. Each time it observes one of these\n\t * inner Observables, the output Observable begins emitting the items emitted by\n\t * that inner Observable. When a new inner Observable is emitted, `switchMap`\n\t * stops emitting items from the earlier-emitted inner Observable and begins\n\t * emitting items from the new one. It continues to behave like this for\n\t * subsequent inner Observables.\n\t *\n\t * @example <caption>Rerun an interval Observable on every click event</caption>\n\t * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n\t * result.subscribe(x => console.log(x));\n\t *\n\t * @see {@link concatMap}\n\t * @see {@link exhaustMap}\n\t * @see {@link mergeMap}\n\t * @see {@link switch}\n\t * @see {@link switchMapTo}\n\t *\n\t * @param {function(value: T, ?index: number): Observable} project A function\n\t * that, when applied to an item emitted by the source Observable, returns an\n\t * Observable.\n\t * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n\t * A function to produce the value on the output Observable based on the values\n\t * and the indices of the source (outer) emission and the inner Observable\n\t * emission. The arguments passed to this function are:\n\t * - `outerValue`: the value that came from the source\n\t * - `innerValue`: the value that came from the projected Observable\n\t * - `outerIndex`: the \"index\" of the value that came from the source\n\t * - `innerIndex`: the \"index\" of the value from the projected Observable\n\t * @return {Observable} An Observable that emits the result of applying the\n\t * projection function (and the optional `resultSelector`) to each item emitted\n\t * by the source Observable and taking only the values from the most recently\n\t * projected inner Observable.\n\t * @method switchMap\n\t * @owner Observable\n\t */\n\tfunction switchMap(project, resultSelector) {\n\t    return this.lift(new SwitchMapOperator(project, resultSelector));\n\t}\n\texports.switchMap = switchMap;\n\tvar SwitchMapOperator = (function () {\n\t    function SwitchMapOperator(project, resultSelector) {\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t    }\n\t    SwitchMapOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n\t    };\n\t    return SwitchMapOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SwitchMapSubscriber = (function (_super) {\n\t    __extends(SwitchMapSubscriber, _super);\n\t    function SwitchMapSubscriber(destination, project, resultSelector) {\n\t        _super.call(this, destination);\n\t        this.project = project;\n\t        this.resultSelector = resultSelector;\n\t        this.index = 0;\n\t    }\n\t    SwitchMapSubscriber.prototype._next = function (value) {\n\t        var result;\n\t        var index = this.index++;\n\t        try {\n\t            result = this.project(value, index);\n\t        }\n\t        catch (error) {\n\t            this.destination.error(error);\n\t            return;\n\t        }\n\t        this._innerSub(result, value, index);\n\t    };\n\t    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n\t        var innerSubscription = this.innerSubscription;\n\t        if (innerSubscription) {\n\t            innerSubscription.unsubscribe();\n\t        }\n\t        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n\t    };\n\t    SwitchMapSubscriber.prototype._complete = function () {\n\t        var innerSubscription = this.innerSubscription;\n\t        if (!innerSubscription || innerSubscription.closed) {\n\t            _super.prototype._complete.call(this);\n\t        }\n\t    };\n\t    SwitchMapSubscriber.prototype._unsubscribe = function () {\n\t        this.innerSubscription = null;\n\t    };\n\t    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n\t        this.remove(innerSub);\n\t        this.innerSubscription = null;\n\t        if (this.isStopped) {\n\t            _super.prototype._complete.call(this);\n\t        }\n\t    };\n\t    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        if (this.resultSelector) {\n\t            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        else {\n\t            this.destination.next(innerValue);\n\t        }\n\t    };\n\t    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n\t        var result;\n\t        try {\n\t            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n\t        }\n\t        catch (err) {\n\t            this.destination.error(err);\n\t            return;\n\t        }\n\t        this.destination.next(result);\n\t    };\n\t    return SwitchMapSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\t//# sourceMappingURL=switchMap.js.map\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(7);\n\tvar distinct_1 = __webpack_require__(42);\n\tObservable_1.Observable.prototype.distinct = distinct_1.distinct;\n\t//# sourceMappingURL=distinct.js.map\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar OuterSubscriber_1 = __webpack_require__(34);\n\tvar subscribeToResult_1 = __webpack_require__(35);\n\tvar Set_1 = __webpack_require__(43);\n\t/**\n\t * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n\t * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n\t * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n\t * source observable directly with an equality check against previous values.\n\t * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n\t * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n\t * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n\t * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n\t * that the internal `Set` can be \"flushed\", basically clearing it of values.\n\t * @param {function} [keySelector] optional function to select which value you want to check as distinct.\n\t * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.\n\t * @return {Observable} an Observable that emits items from the source Observable with distinct values.\n\t * @method distinct\n\t * @owner Observable\n\t */\n\tfunction distinct(keySelector, flushes) {\n\t    return this.lift(new DistinctOperator(keySelector, flushes));\n\t}\n\texports.distinct = distinct;\n\tvar DistinctOperator = (function () {\n\t    function DistinctOperator(keySelector, flushes) {\n\t        this.keySelector = keySelector;\n\t        this.flushes = flushes;\n\t    }\n\t    DistinctOperator.prototype.call = function (subscriber, source) {\n\t        return source._subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n\t    };\n\t    return DistinctOperator;\n\t}());\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar DistinctSubscriber = (function (_super) {\n\t    __extends(DistinctSubscriber, _super);\n\t    function DistinctSubscriber(destination, keySelector, flushes) {\n\t        _super.call(this, destination);\n\t        this.keySelector = keySelector;\n\t        this.values = new Set_1.Set();\n\t        if (flushes) {\n\t            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n\t        }\n\t    }\n\t    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n\t        this.values.clear();\n\t    };\n\t    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n\t        this._error(error);\n\t    };\n\t    DistinctSubscriber.prototype._next = function (value) {\n\t        if (this.keySelector) {\n\t            this._useKeySelector(value);\n\t        }\n\t        else {\n\t            this._finalizeNext(value, value);\n\t        }\n\t    };\n\t    DistinctSubscriber.prototype._useKeySelector = function (value) {\n\t        var key;\n\t        var destination = this.destination;\n\t        try {\n\t            key = this.keySelector(value);\n\t        }\n\t        catch (err) {\n\t            destination.error(err);\n\t            return;\n\t        }\n\t        this._finalizeNext(key, value);\n\t    };\n\t    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n\t        var values = this.values;\n\t        if (!values.has(key)) {\n\t            values.add(key);\n\t            this.destination.next(value);\n\t        }\n\t    };\n\t    return DistinctSubscriber;\n\t}(OuterSubscriber_1.OuterSubscriber));\n\texports.DistinctSubscriber = DistinctSubscriber;\n\t//# sourceMappingURL=distinct.js.map\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(8);\n\tfunction minimalSetImpl() {\n\t    // THIS IS NOT a full impl of Set, this is just the minimum\n\t    // bits of functionality we need for this library.\n\t    return (function () {\n\t        function MinimalSet() {\n\t            this._values = [];\n\t        }\n\t        MinimalSet.prototype.add = function (value) {\n\t            if (!this.has(value)) {\n\t                this._values.push(value);\n\t            }\n\t        };\n\t        MinimalSet.prototype.has = function (value) {\n\t            return this._values.indexOf(value) !== -1;\n\t        };\n\t        Object.defineProperty(MinimalSet.prototype, \"size\", {\n\t            get: function () {\n\t                return this._values.length;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        MinimalSet.prototype.clear = function () {\n\t            this._values.length = 0;\n\t        };\n\t        return MinimalSet;\n\t    }());\n\t}\n\texports.minimalSetImpl = minimalSetImpl;\n\texports.Set = root_1.root.Set || minimalSetImpl();\n\t//# sourceMappingURL=Set.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// dist/index-with-deps.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ad59821860eedd756661","import 'skatejs-web-components';\n\nimport {Component, prop, h} from 'skatejs';\nconst React = { createElement: h };\n\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { ajax } from 'rxjs/Observable/dom/ajax';\nimport 'rxjs/add/observable/empty';\n\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/switchMap';\nimport 'rxjs/add/operator/distinct';\n\n\ncustomElements.define('svg-import', class extends Component {\n\tstatic get props () {\n\t\treturn {\n\t\t\t// By declaring the property an attribute, we can now pass an initial value\n\t\t\t// for the count as part of the HTML.\n\t\t\tsrc: prop.string({ attribute: true }),\n\t\t\t'inner-style': prop.string({ attribute: true }),\n\t\t};\n\t}\n\n\tconstructor(){\n\t\tsuper();\n\t\tthis.src$ = new BehaviorSubject(this.src)\n\t\t\t.filter(val => val && typeof val === 'string')\n\t\t\t.distinct( (src) => src + this['inner-style'])\n\t\t\t.switchMap(src => this.fetchXml(src))\n\t\t\t.filter(xml => !!xml);\n\t}\n\t\n\n\tfetchXml(src){\n\n\t\treturn ajax({url:src,cache:true,crossDomain:true,responseType:'text'})\n\t\t\t.map(function (response) {\n\t\t\t\treturn jQuery.parseXML(response.response)\n\t\t\t})\n\t\t\t.catch((err)=>{\n\t\t\t\tconsole.error(err);\n\t\t\t\treturn Observable.empty();\n\t\t\t});\n\t}\n\n\tgetWraper(){\n\t\treturn jQuery(this.shadowRoot).find('.svg-import-wrap').get(0);\n\t}\n\n\tupdateXml(xml){\n\t\tlet comp = this;\n\t\tif(!xml){return}\n\t\tconst $ = jQuery;\n\n\n\t\tvar $svg = $(xml).find('svg');\n\t\tvar svg = $svg.get(0);\n\n\t\tsvg.removeAttribute('xmlns:a');\n\t\tif(comp.width && comp.height){\n\t\t\t// svg.hasAttribute('viewBox') ? svg.setAttribute('viewBox', '0 0 ' + comp.height + ' ' + comp.width) : '';\n\t\t\tsvg.setAttribute('width','100%');\n\t\t\tsvg.setAttribute('height','100%');\n\t\t}\n\n\t\tvar wraper = comp.getWraper();\n\n\t\tif(wraper){\n\t\t\twraper.innerHTML = '';\n\t\t\twraper.appendChild(svg);\n\t\t}\n\n\t}\n\tconnectedCallback () {\n\t\t// Ensure we call the parent.\n\t\tsuper.connectedCallback();\n\t\t//this.updateXml();\n\t\tif(!jQuery){\n\t\t\tthrow new TypeError('svg-import require jQuery to work!');\n\t\t}\n\n\t\tthis.srcSubscription = this.src$\n\t\t\t.subscribe(\n\t\t\t\t(src)=>this.updateXml(src),\n\t\t\t\t(err)=>console.error(err));\n\n\t}\n\tattributeChangedCallback (name, oldValue, newValue) {\n\t\tsuper.attributeChangedCallback(name, oldValue, newValue);\n\t\tif(name === 'src'){\n\t\t\tthis.src$.next(newValue);\n\t\t}\n\t}\n\tdisconnectedCallback () {\n\t\t// Ensure we callback the parent.\n\t\tsuper.disconnectedCallback();\n\t\tif(this.srcSubscription){\n\t\t\tthis.srcSubscription.unsubscribe();\n\t\t}\n\t}\n\trenderCallback () {\n\t\t// By separating the strings (and not using template literals or string\n\t\t// concatenation) it ensures the strings are diffed indepenedently. If\n\t\t// you select \"Count\" with your mouse, it will not deselect whenr endered.\n\t\tvar comp = this;\n\n\t\tconst defBoxStyle = `\n\t\t\t:host{display:inline-block;}\n\t\t\t.svg-import-wrap{\n\t\t\t\toverflow:hidden;\n\t\t\t\tmargin:0;\n\t\t\t\tpadding:0;\n\t\t\t\twidth:100%;\n\t\t\t\theight:100%;\n\t\t\t\tmin-width:5px;\n\t\t\t\tmin-height:5px;\n\t\t\t\tdisplay:block;\n\t\t\t}\n\t\t\tsvg{\n\t\t\t\twidth:100%;\n\t\t\t\theight:100%;\n\t\t\t}\n\t\t`;\n\n\t\tthis.src$.next(comp.src);\n\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<style>{defBoxStyle + comp['inner-style']}</style>\n\t\t\t\t<figure role=\"image\" className=\"svg-import-wrap\"></figure>\n\t\t\t</div>\n\t\t)\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsWebComponents\"] = factory();\n\telse\n\t\troot[\"skatejsWebComponents\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// We load the Safari fix first because the custom element polyfill overrides\n\t// attachShadow() to observe the shadow root.\n\t__webpack_require__(1);\n\t\n\t// We have to include this first so that it can patch native.\n\t__webpack_require__(2);\n\t\n\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t// ShadyDOM polyfill be loaded first.\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _window = window,\n\t    HTMLElement = _window.HTMLElement,\n\t    MutationObserver = _window.MutationObserver,\n\t    navigator = _window.navigator;\n\tvar userAgent = navigator.userAgent;\n\t\n\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\tvar safariVersions = [0, 1].map(function (v) {\n\t  return '10.0.' + v;\n\t}).concat(['10.0']);\n\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\n\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\tfunction fixSafari() {\n\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\n\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t  // element as this is the only scenario where styles aren't recalculated.\n\t  var moOpts = { childList: true, subtree: true };\n\t  var mo = new MutationObserver(function (muts) {\n\t    muts.forEach(function (mut) {\n\t      var target = mut.target;\n\t\n\t      if (target.tagName === 'STYLE') {\n\t        var nextSibling = target.nextSibling,\n\t            parentNode = target.parentNode;\n\t\n\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t        // as it seems that doesn't trigger a recalc.\n\t\n\t        parentNode.removeChild(target);\n\t        parentNode.insertBefore(target, nextSibling);\n\t      }\n\t    });\n\t  });\n\t\n\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t  function newAttachShadow(opts) {\n\t    var sr = oldAttachShadow.call(this, opts);\n\t    mo.observe(sr, moOpts);\n\t    return sr;\n\t  }\n\t\n\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t    // Ensure polyfills can override it (hoping they call it back).\n\t    configurable: true,\n\t    enumerable: true,\n\t    value: newAttachShadow,\n\t    writable: true\n\t  });\n\t}\n\t\n\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t// fixes the bug.\n\tif (patch) {\n\t  fixSafari();\n\t}\n\t\n\texports.default = patch;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t Code distributed by Google as part of the polymer project is also\n\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\n\t//# sourceMappingURL=custom-elements.min.js.map\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar settings = window.ShadyDOM || {};\n\t\n\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\n\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\n\tfunction isShadyRoot(obj) {\n\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t}\n\t\n\tvar p = Element.prototype;\n\tvar matches = p.matches || p.matchesSelector ||\n\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tfunction matchesSelector(element, selector) {\n\t  return matches.call(element, selector);\n\t}\n\t\n\tfunction copyOwnProperty(name, source, target) {\n\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t  if (pd) {\n\t    Object.defineProperty(target, name, pd);\n\t  }\n\t}\n\t\n\tfunction extend(target, source) {\n\t  if (target && source) {\n\t    var n$ = Object.getOwnPropertyNames(source);\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t      copyOwnProperty(n, source, target);\n\t    }\n\t  }\n\t  return target || source;\n\t}\n\t\n\tfunction extendAll(target) {\n\t  var sources = [], len = arguments.length - 1;\n\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t  for (var i=0; i < sources.length; i++) {\n\t    extend(target, sources[i]);\n\t  }\n\t  return target;\n\t}\n\t\n\tfunction mixin(target, source) {\n\t  for (var i in source) {\n\t    target[i] = source[i];\n\t  }\n\t  return target;\n\t}\n\t\n\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t  obj.__proto__ = proto;\n\t  return obj;\n\t}\n\t\n\tfunction patchPrototype(obj, mixin) {\n\t  var proto = Object.getPrototypeOf(obj);\n\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t    var patchProto = Object.create(proto);\n\t    patchProto.__sourceProto = proto;\n\t    extend(patchProto, mixin);\n\t    proto.__patchProto = patchProto;\n\t  }\n\t  setPrototypeOf(obj, proto.__patchProto);\n\t}\n\t\n\t\n\t\n\tvar common = {};\n\t\n\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\tvar promish;\n\tif (window.Promise) {\n\t  promish = Promise.resolve();\n\t} else {\n\t  promish = {\n\t    then: function(cb) {\n\t      var twiddle = document.createTextNode('');\n\t      var observer = new MutationObserver(function() {\n\t        observer.disconnect();\n\t        cb();\n\t      });\n\t      observer.observe(twiddle, {characterData: true});\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction newSplice(index, removed, addedCount) {\n\t  return {\n\t    index: index,\n\t    removed: removed,\n\t    addedCount: addedCount\n\t  };\n\t}\n\t\n\tvar EDIT_LEAVE = 0;\n\tvar EDIT_UPDATE = 1;\n\tvar EDIT_ADD = 2;\n\tvar EDIT_DELETE = 3;\n\t\n\tvar ArraySplice = {\n\t\n\t  // Note: This function is *based* on the computation of the Levenshtein\n\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t  // edits - not one. With Array splices, an update is really a delete\n\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t  // maximum array items in the original array. For example:\n\t  //\n\t  //   'xxxx123' -> '123yyyy'\n\t  //\n\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t  // leaves the substring '123' intact.\n\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t                              old, oldStart, oldEnd) {\n\t    var this$1 = this;\n\t\n\t    // \"Deletion\" columns\n\t    var rowCount = oldEnd - oldStart + 1;\n\t    var columnCount = currentEnd - currentStart + 1;\n\t    var distances = new Array(rowCount);\n\t\n\t    // \"Addition\" rows. Initialize null column.\n\t    for (var i = 0; i < rowCount; i++) {\n\t      distances[i] = new Array(columnCount);\n\t      distances[i][0] = i;\n\t    }\n\t\n\t    // Initialize null row\n\t    for (var j = 0; j < columnCount; j++)\n\t      distances[0][j] = j;\n\t\n\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t        else {\n\t          var north = distances[i$1 - 1][j$1] + 1;\n\t          var west = distances[i$1][j$1 - 1] + 1;\n\t          distances[i$1][j$1] = north < west ? north : west;\n\t        }\n\t      }\n\t    }\n\t\n\t    return distances;\n\t  },\n\t\n\t  // This starts at the final weight, and walks \"backward\" by finding\n\t  // the minimum previous weight recursively until the origin of the weight\n\t  // matrix.\n\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t    var i = distances.length - 1;\n\t    var j = distances[0].length - 1;\n\t    var current = distances[i][j];\n\t    var edits = [];\n\t    while (i > 0 || j > 0) {\n\t      if (i == 0) {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        continue;\n\t      }\n\t      if (j == 0) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        continue;\n\t      }\n\t      var northWest = distances[i - 1][j - 1];\n\t      var west = distances[i - 1][j];\n\t      var north = distances[i][j - 1];\n\t\n\t      var min;\n\t      if (west < north)\n\t        min = west < northWest ? west : northWest;\n\t      else\n\t        min = north < northWest ? north : northWest;\n\t\n\t      if (min == northWest) {\n\t        if (northWest == current) {\n\t          edits.push(EDIT_LEAVE);\n\t        } else {\n\t          edits.push(EDIT_UPDATE);\n\t          current = northWest;\n\t        }\n\t        i--;\n\t        j--;\n\t      } else if (min == west) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        current = west;\n\t      } else {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        current = north;\n\t      }\n\t    }\n\t\n\t    edits.reverse();\n\t    return edits;\n\t  },\n\t\n\t  /**\n\t   * Splice Projection functions:\n\t   *\n\t   * A splice map is a representation of how a previous array of items\n\t   * was transformed into a new array of items. Conceptually it is a list of\n\t   * tuples of\n\t   *\n\t   *   <index, removed, addedCount>\n\t   *\n\t   * which are kept in ascending index order of. The tuple represents that at\n\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t   * from |index|, |addedCount| items were added.\n\t   */\n\t\n\t  /**\n\t   * Lacking individual splice mutation information, the minimal set of\n\t   * splices can be synthesized given the previous state and final state of an\n\t   * array. The basic approach is to calculate the edit distance matrix and\n\t   * choose the shortest path through it.\n\t   *\n\t   * Complexity: O(l * p)\n\t   *   l: The length of the current array\n\t   *   p: The length of the old array\n\t   */\n\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t                        old, oldStart, oldEnd) {\n\t    var prefixCount = 0;\n\t    var suffixCount = 0;\n\t    var splice;\n\t\n\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t    if (currentStart == 0 && oldStart == 0)\n\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\n\t    if (currentEnd == current.length && oldEnd == old.length)\n\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\n\t    currentStart += prefixCount;\n\t    oldStart += prefixCount;\n\t    currentEnd -= suffixCount;\n\t    oldEnd -= suffixCount;\n\t\n\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t      return [];\n\t\n\t    if (currentStart == currentEnd) {\n\t      splice = newSplice(currentStart, [], 0);\n\t      while (oldStart < oldEnd)\n\t        splice.removed.push(old[oldStart++]);\n\t\n\t      return [ splice ];\n\t    } else if (oldStart == oldEnd)\n\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\n\t    var ops = this.spliceOperationsFromEditDistances(\n\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t                               old, oldStart, oldEnd));\n\t\n\t    splice = undefined;\n\t    var splices = [];\n\t    var index = currentStart;\n\t    var oldIndex = oldStart;\n\t    for (var i = 0; i < ops.length; i++) {\n\t      switch(ops[i]) {\n\t        case EDIT_LEAVE:\n\t          if (splice) {\n\t            splices.push(splice);\n\t            splice = undefined;\n\t          }\n\t\n\t          index++;\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_UPDATE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_ADD:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t          break;\n\t        case EDIT_DELETE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (splice) {\n\t      splices.push(splice);\n\t    }\n\t    return splices;\n\t  },\n\t\n\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t    var this$1 = this;\n\t\n\t    for (var i = 0; i < searchLength; i++)\n\t      if (!this$1.equals(current[i], old[i]))\n\t        return i;\n\t    return searchLength;\n\t  },\n\t\n\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t    var index1 = current.length;\n\t    var index2 = old.length;\n\t    var count = 0;\n\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t      count++;\n\t\n\t    return count;\n\t  },\n\t\n\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t                            previous.length);\n\t  },\n\t\n\t  equals: function equals(currentValue, previousValue) {\n\t    return currentValue === previousValue;\n\t  }\n\t\n\t};\n\t\n\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t// for now this is stuck on `utils`\n\t//import {patchNode} from './patch'\n\t// native add/remove\n\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\tvar nativeAppendChild = Element.prototype.appendChild;\n\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\n\t/**\n\t * `tree` is a dom manipulation library used by ShadyDom to\n\t * manipulate composed and logical trees.\n\t */\n\tvar tree = {\n\t\n\t  // sad but faster than slice...\n\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopy: function arrayCopy(a$) {\n\t    var l = a$.length;\n\t    var copy = new Array(l);\n\t    for (var i=0; i < l; i++) {\n\t      copy[i] = a$[i];\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes(node) {\n\t    tree.Logical.saveChildNodes(node);\n\t    if (!tree.Composed.hasParentNode(node)) {\n\t      tree.Composed.saveComposedData(node);\n\t      //tree.Composed.saveParentNode(node);\n\t    }\n\t    tree.Composed.saveChildNodes(node);\n\t  }\n\t\n\t};\n\t\n\ttree.Logical = {\n\t\n\t  hasParentNode: function hasParentNode(node) {\n\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes(node) {\n\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes(node) {\n\t    // note: we're distinguishing here between undefined and false-y:\n\t    // hasChildNodes uses undefined check to see if this element has logical\n\t    // children; the false-y check indicates whether or not we should rebuild\n\t    // the cached childNodes array.\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      tree.Composed.getChildNodes(node);\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes(node) {\n\t    if (!node.__dom.childNodes) {\n\t      node.__dom.childNodes = [];\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        node.__dom.childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.childNodes;\n\t  },\n\t\n\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t  // element will store firstChild/lastChild, and in case (2), the element\n\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t  // the mere existence of __dom is not enough to know if the requested\n\t  // logical data is available and instead we do an explicit undefined check.\n\t  getParentNode: function getParentNode(node) {\n\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t  },\n\t\n\t  getLastChild: function getLastChild(node) {\n\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t  },\n\t\n\t  getNextSibling: function getNextSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      this._getFirstElementChild(node) :\n\t      tree.Composed.getFirstElementChild(node);\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t    var n = node.__dom.firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild(node) {\n\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t      this._getLastElementChild(node) :\n\t      tree.Composed.getLastElementChild(node);\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild(node) {\n\t    var n = node.__dom.lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t      this._getNextElementSibling(node) :\n\t      tree.Composed.getNextElementSibling(node);\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t      this._getPreviousElementSibling(node) :\n\t      tree.Composed.getPreviousElementSibling(node);\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  // Capture the list of light children. It's important to do this before we\n\t  // start transforming the DOM into \"rendered\" state.\n\t  // Children may be added to this list dynamically. It will be treated as the\n\t  // source of truth for the light children of the element. This element's\n\t  // actual children will be treated as the rendered state once this function\n\t  // has been called.\n\t  saveChildNodes: function saveChildNodes$1(node) {\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.firstChild;\n\t      node.__dom.lastChild = node.lastChild;\n\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        n.__dom = n.__dom || {};\n\t        n.__dom.parentNode = node;\n\t        n.__dom.nextSibling = c$[i+1] || null;\n\t        n.__dom.previousSibling = c$[i-1] || null;\n\t        common.patchNode(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t  // already been distributed.\n\t  // NOTE: ensure `node` is patched...\n\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var c$ = tree.arrayCopyChildNodes(node);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1._linkNode(c$[i], container, ref_node);\n\t      }\n\t      // cleanup logical dom in doc fragment.\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t      node.__dom.childNodes = null;\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t    common.patchNode(node);\n\t    ref_node = ref_node || null;\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t      container.__dom.lastChild;\n\t    if (node.__dom.previousSibling) {\n\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.nextSibling = ref_node;\n\t    if (node.__dom.nextSibling) {\n\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.lastChild = node;\n\t      if (!container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.firstChild) {\n\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t    }\n\t    if (node === container.__dom.lastChild) {\n\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t    }\n\t    var p = node.__dom.previousSibling;\n\t    var n = node.__dom.nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.previousSibling = p;\n\t    }\n\t    // When an element is removed, logical data is no longer tracked.\n\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t    // from `null` which is set if info is null.\n\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t      node.__dom.nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  }\n\t\n\t}\n\t\n\t\n\t// TODO(sorvell): composed tree manipulation is made available\n\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t// to the tree for optional patching pluggability.\n\ttree.Composed = {\n\t\n\t  hasParentNode: function hasParentNode$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes$1(node) {\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes$1(node) {\n\t    if (!node.__dom.$childNodes) {\n\t      node.__dom.$childNodes = [];\n\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t        node.__dom.$childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getParentNode: function getParentNode$1(node) {\n\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t      (!node.__patched && node.parentNode);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild$1(node) {\n\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t  },\n\t\n\t  getLastChild: function getLastChild$1(node) {\n\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t  },\n\t\n\t  getNextSibling: function getNextSibling$1(node) {\n\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t    return node.__patched ? this._getFirstElementChild(node) :\n\t      node.firstElementChild;\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t    var n = node.__dom.$firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild$1(node) {\n\t    return node.__patched ? this._getLastElementChild(node) :\n\t      node.lastElementChild;\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t    var n = node.__dom.$lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t    return node.__patched ? this._getNextElementSibling(node) :\n\t      node.nextElementSibling;\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t      node.previousElementSibling;\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes$2(node) {\n\t    var this$1 = this;\n\t\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.$firstChild = node.firstChild;\n\t      node.__dom.$lastChild = node.lastChild;\n\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        this$1.saveComposedData(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  saveComposedData: function saveComposedData(node) {\n\t    node.__dom = node.__dom || {};\n\t    if (node.__dom.$parentNode === undefined) {\n\t      node.__dom.$parentNode = node.parentNode;\n\t    }\n\t    if (node.__dom.$nextSibling === undefined) {\n\t      node.__dom.$nextSibling = node.nextSibling;\n\t    }\n\t    if (node.__dom.$previousSibling === undefined) {\n\t      node.__dom.$previousSibling = node.previousSibling;\n\t    }\n\t  },\n\t\n\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.$childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      // TODO(sorvell): remember this for patching:\n\t      // the act of setting this info can affect patched nodes\n\t      // getters; therefore capture childNodes before patching.\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        this$1._linkNode(n, container, ref_node);\n\t      }\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t      container.__dom.$lastChild;\n\t    if (node.__dom.$previousSibling) {\n\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.$nextSibling = ref_node;\n\t    if (node.__dom.$nextSibling) {\n\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.$parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.$lastChild = node;\n\t      if (!container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.$firstChild) {\n\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t    }\n\t    if (node === container.__dom.$lastChild) {\n\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t    }\n\t    var p = node.__dom.$previousSibling;\n\t    var n = node.__dom.$nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.$nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.$previousSibling = p;\n\t    }\n\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t      node.__dom.$nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  clearChildNodes: function clearChildNodes(node) {\n\t    var this$1 = this;\n\t\n\t    var c$ = this.getChildNodes(node);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      this$1.recordRemoveChild(c, node);\n\t      nativeRemoveChild.call(node, c)\n\t    }\n\t  },\n\t\n\t  saveParentNode: function saveParentNode(node) {\n\t    node.__dom = node.__dom || {};\n\t    node.__dom.$parentNode = node.parentNode;\n\t  },\n\t\n\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t    this.saveChildNodes(parentNode);\n\t    // remove from current location.\n\t    this._addChild(parentNode, newChild, refChild);\n\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t  },\n\t\n\t  appendChild: function appendChild(parentNode, newChild) {\n\t    this.saveChildNodes(parentNode);\n\t    this._addChild(parentNode, newChild);\n\t    return nativeAppendChild.call(parentNode, newChild);\n\t  },\n\t\n\t  removeChild: function removeChild(parentNode, node) {\n\t    var currentParent = this.getParentNode(node);\n\t    this.saveChildNodes(parentNode);\n\t    this._removeChild(parentNode, node);\n\t    if (currentParent === parentNode) {\n\t      return nativeRemoveChild.call(parentNode, node);\n\t    }\n\t  },\n\t\n\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t    var this$1 = this;\n\t\n\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t    var oldParent = this.getParentNode(newChild);\n\t    if (oldParent) {\n\t      this._removeChild(oldParent, newChild);\n\t    }\n\t    if (isFrag) {\n\t      var c$ = this.getChildNodes(newChild);\n\t      for (var i=0; i < c$.length; i++) {\n\t        var c = c$[i];\n\t        // unlink document fragment children\n\t        this$1._removeChild(newChild, c);\n\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t      }\n\t    } else {\n\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t    }\n\t  },\n\t\n\t  _removeChild: function _removeChild(parentNode, node) {\n\t    this.recordRemoveChild(node, parentNode);\n\t  }\n\t\n\t};\n\t\n\t// for testing...\n\tvar descriptors = {};\n\tfunction getNativeProperty(element, property) {\n\t  if (!descriptors[property]) {\n\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t      HTMLElement.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Element.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Node.prototype, property);\n\t  }\n\t  return descriptors[property].get.call(element);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// NOTE: normalize event contruction where necessary (IE11)\n\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t  function(inType, params) {\n\t    params = params || {};\n\t    var e = document.createEvent('Event');\n\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t    return e;\n\t  };\n\t\n\tvar Distributor = (function () {\n\t  function anonymous(root) {\n\t    this.root = root;\n\t    this.insertionPointTag = 'slot';\n\t  }\n\t\n\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t  };\n\t\n\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t    return Boolean(this.root._insertionPoints &&\n\t      this.root._insertionPoints.length);\n\t  };\n\t\n\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t    return node.localName && node.localName == this.insertionPointTag;\n\t  };\n\t\n\t  anonymous.prototype.distribute = function distribute () {\n\t    if (this.hasInsertionPoint()) {\n\t      return this.distributePool(this.root, this.collectPool());\n\t    }\n\t    return [];\n\t  };\n\t\n\t  // Gather the pool of nodes that should be distributed. We will combine\n\t  // these with the \"content root\" to arrive at the composed tree.\n\t  anonymous.prototype.collectPool = function collectPool () {\n\t    return tree.arrayCopy(\n\t      tree.Logical.getChildNodes(this.root.host));\n\t  };\n\t\n\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t  // instead elements are distributed into storage\n\t  // array where applicable.\n\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t    var this$1 = this;\n\t\n\t    var dirtyRoots = [];\n\t    var p$ = this.root._insertionPoints;\n\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t      this$1.distributeInsertionPoint(p, pool);\n\t      // provoke redistribution on insertion point parents\n\t      // must do this on all candidate hosts since distribution in this\n\t      // scope invalidates their distribution.\n\t      // only get logical parent.\n\t      var parent = tree.Logical.getParentNode(p);\n\t      if (parent && parent.shadyRoot &&\n\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t        dirtyRoots.push(parent.shadyRoot);\n\t      }\n\t    }\n\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t      var p$1 = pool[i$1];\n\t      if (p$1) {\n\t        p$1._assignedSlot = undefined;\n\t        // remove undistributed elements from physical dom.\n\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t        if (parent$1) {\n\t          tree.Composed.removeChild(parent$1, p$1);\n\t        }\n\t      }\n\t    }\n\t    return dirtyRoots;\n\t  };\n\t\n\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t    var this$1 = this;\n\t\n\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t    if (prevAssignedNodes) {\n\t      this.clearAssignedSlots(insertionPoint, true);\n\t    }\n\t    insertionPoint._assignedNodes = [];\n\t    var needsSlotChange = false;\n\t    // distribute nodes from the pool that this selector matches\n\t    var anyDistributed = false;\n\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t      node=pool[i];\n\t      // skip nodes that were already used\n\t      if (!node) {\n\t        continue;\n\t      }\n\t      // distribute this node if it matches\n\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node, insertionPoint)\n\t        // remove this node from the pool\n\t        pool[i] = undefined;\n\t        // since at least one node matched, we won't need fallback content\n\t        anyDistributed = true;\n\t      }\n\t    }\n\t    // Fallback content if nothing was distributed here\n\t    if (!anyDistributed) {\n\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t      for (var j = 0, node$1; j < children.length; j++) {\n\t        node$1 = children[j];\n\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t      }\n\t    }\n\t    // we're already dirty if a node was newly added to the slot\n\t    // and we're also dirty if the assigned count decreased.\n\t    if (prevAssignedNodes) {\n\t      // TODO(sorvell): the tracking of previously assigned slots\n\t      // could instead by done with a Set and then we could\n\t      // avoid needing to iterate here to clear the info.\n\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t      }\n\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t        needsSlotChange = true;\n\t      }\n\t    }\n\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t    if (needsSlotChange) {\n\t      this._fireSlotChange(insertionPoint);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t    var n$ = slot._assignedNodes;\n\t    if (n$) {\n\t      for (var i=0; i < n$.length; i++) {\n\t        var n = n$[i];\n\t        if (savePrevious) {\n\t          n.__prevAssignedSlot = n._assignedSlot;\n\t        }\n\t        // only clear if it was previously set to this slot;\n\t        // this helps ensure that if the node has otherwise been distributed\n\t        // ignore it.\n\t        if (n._assignedSlot === slot) {\n\t          n._assignedSlot = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t    var slotName = insertionPoint.getAttribute('name');\n\t    slotName = slotName ? slotName.trim() : '';\n\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t    slot = slot ? slot.trim() : '';\n\t    return (slot == slotName);\n\t  };\n\t\n\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t    insertionPoint._assignedNodes.push(child);\n\t    child._assignedSlot = insertionPoint;\n\t  };\n\t\n\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t    var this$1 = this;\n\t\n\t    var n$ = insertionPoint._assignedNodes;\n\t    insertionPoint._distributedNodes = [];\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t      if (this$1.isInsertionPoint(n)) {\n\t        var d$ = n._distributedNodes;\n\t        if (d$) {\n\t          for (var j=0; j < d$.length; j++) {\n\t            insertionPoint._distributedNodes.push(d$[j]);\n\t          }\n\t        }\n\t      } else {\n\t        insertionPoint._distributedNodes.push(n$[i]);\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t    // Safari tech preview does not bubble but chrome does\n\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t    if (insertionPoint._assignedSlot) {\n\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t    return !(insertionPoint._assignedSlot);\n\t  };\n\t\n\t  return anonymous;\n\t}())\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t  polyfill across browsers.\n\t*/\n\tvar ShadyRoot = function ShadyRoot(host) {\n\t  if (!host) {\n\t    throw 'Must provide a host';\n\t  }\n\t  // NOTE: this strange construction is necessary because\n\t  // DocumentFragment cannot be subclassed on older browsers.\n\t  var frag = document.createDocumentFragment();\n\t  frag.__proto__ = ShadyFragmentMixin;\n\t  frag._init(host);\n\t  return frag;\n\t};\n\t\n\tvar ShadyMixin = {\n\t\n\t  _init: function _init(host) {\n\t    // NOTE: set a fake local name so this element can be\n\t    // distinguished from a DocumentFragment when patching.\n\t    // FF doesn't allow this to be `localName`\n\t    this.__localName = 'ShadyRoot';\n\t    // root <=> host\n\t    host.shadyRoot = this;\n\t    this.host = host;\n\t    // logical dom setup\n\t    tree.Logical.saveChildNodes(host);\n\t    tree.Logical.saveChildNodes(this);\n\t    // state flags\n\t    this._clean = true;\n\t    this._hasRendered = false;\n\t    this._distributor = new Distributor(this);\n\t    this.update();\n\t  },\n\t\n\t  // async render the \"top\" distributor (this is all that is needed to\n\t  // distribute this host).\n\t  update: function update() {\n\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t    if (distributionRoot._clean) {\n\t      distributionRoot._clean = false;\n\t      enqueue(function() {\n\t        distributionRoot.render();\n\t      });\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t  // this should only return a shadowRoot.\n\t  // returns the host that's the top of this host's distribution tree\n\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t    var root = element.shadyRoot;\n\t    while (element && this._elementNeedsDistribution(element)) {\n\t      root = element.getRootNode();\n\t      element = root && root.host;\n\t    }\n\t    return root;\n\t  },\n\t\n\t  // Return true if a host's children includes\n\t  // an insertion point that selects selectively\n\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t    var this$1 = this;\n\t\n\t    var c$ = tree.Logical.getChildNodes(element);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t        return element.getRootNode();\n\t      }\n\t    }\n\t  },\n\t\n\t  render: function render() {\n\t    if (!this._clean) {\n\t      this._clean = true;\n\t      if (!this._skipUpdateInsertionPoints) {\n\t        this.updateInsertionPoints();\n\t      } else if (!this._hasRendered) {\n\t        this._insertionPoints = [];\n\t      }\n\t      this._skipUpdateInsertionPoints = false;\n\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t      // that would avoid distribution for initial render if\n\t      // no insertion points exist. We cannot currently do this because\n\t      // it relies on elements being in the physical shadowRoot element\n\t      // so that native methods will be used. The current append code\n\t      // simply provokes distribution in this case and does not put the\n\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t      // consider if the special processing is worth the perf gain.\n\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t      //   tree.Composed.clearChildNodes(this.host);\n\t      //   tree.Composed.appendChild(this.host, this);\n\t      // } else {\n\t      // logical\n\t      this.distribute();\n\t      // physical\n\t      this.compose();\n\t      this._hasRendered = true;\n\t    }\n\t  },\n\t\n\t  forceRender: function forceRender() {\n\t    this._clean = false;\n\t    this.render();\n\t  },\n\t\n\t  distribute: function distribute() {\n\t    var dirtyRoots = this._distributor.distribute();\n\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t      dirtyRoots[i].forceRender();\n\t    }\n\t  },\n\t\n\t  updateInsertionPoints: function updateInsertionPoints() {\n\t    var this$1 = this;\n\t\n\t    var i$ = this.__insertionPoints;\n\t    // if any insertion points have been removed, clear their distribution info\n\t    if (i$) {\n\t      for (var i=0, c; i < i$.length; i++) {\n\t        c = i$[i];\n\t        if (c.getRootNode() !== this$1) {\n\t          this$1._distributor.clearAssignedSlots(c);\n\t        }\n\t      }\n\t    }\n\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t    // ensure insertionPoints's and their parents have logical dom info.\n\t    // save logical tree info\n\t    // a. for shadyRoot\n\t    // b. for insertion points (fallback)\n\t    // c. for parents of insertion points\n\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t      c$1 = i$[i$1];\n\t      tree.Logical.saveChildNodes(c$1);\n\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t    }\n\t  },\n\t\n\t  get _insertionPoints() {\n\t    if (!this.__insertionPoints) {\n\t      this.updateInsertionPoints();\n\t    }\n\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t  },\n\t\n\t  set _insertionPoints(insertionPoints) {\n\t    this.__insertionPoints = insertionPoints;\n\t  },\n\t\n\t  hasInsertionPoint: function hasInsertionPoint() {\n\t    return this._distributor.hasInsertionPoint();\n\t  },\n\t\n\t  compose: function compose() {\n\t    // compose self\n\t    // note: it's important to mark this clean before distribution\n\t    // so that attachment that provokes additional distribution (e.g.\n\t    // adding something to your parentNode) works\n\t    this._composeTree();\n\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t    // (these seem unnecessary)\n\t  },\n\t\n\t  // Reify dom such that it is at its correct rendering position\n\t  // based on logical distribution.\n\t  _composeTree: function _composeTree() {\n\t    var this$1 = this;\n\t\n\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t    var p$ = this._insertionPoints || [];\n\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t      parent = tree.Logical.getParentNode(p);\n\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t      }\n\t    }\n\t  },\n\t\n\t  // Returns the list of nodes which should be rendered inside `node`.\n\t  _composeNode: function _composeNode(node) {\n\t    var this$1 = this;\n\t\n\t    var children = [];\n\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t    for (var i = 0; i < c$.length; i++) {\n\t      var child = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t        var distributedNodes = child._distributedNodes ||\n\t          (child._distributedNodes = []);\n\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t          var distributedNode = distributedNodes[j];\n\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t            children.push(distributedNode);\n\t          }\n\t        }\n\t      } else {\n\t        children.push(child);\n\t      }\n\t    }\n\t    return children;\n\t  },\n\t\n\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t    return this._distributor.isFinalDestination(\n\t      insertionPoint, node);\n\t  },\n\t\n\t  // Ensures that the rendered node list inside `container` is `children`.\n\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t    var composed = tree.Composed.getChildNodes(container);\n\t    var splices = calculateSplices(children, composed);\n\t    // process removals\n\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t        // check if the node is still where we expect it is before trying\n\t        // to remove it; this can happen if we move a node and\n\t        // then schedule its previous host for distribution resulting in\n\t        // the node being removed here.\n\t        if (tree.Composed.getParentNode(n) === container) {\n\t          tree.Composed.removeChild(container, n);\n\t        }\n\t        composed.splice(s.index + d, 1);\n\t      }\n\t      d -= s.addedCount;\n\t    }\n\t    // process adds\n\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t      next = composed[s$1.index];\n\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t        n$1 = children[j$1];\n\t        tree.Composed.insertBefore(container, n$1, next);\n\t        // TODO(sorvell): is this splice strictly needed?\n\t        composed.splice(j$1, 0, n$1);\n\t      }\n\t    }\n\t  },\n\t\n\t  getInsertionPointTag: function getInsertionPointTag() {\n\t    return this._distributor.insertionPointTag;\n\t  }\n\t\n\t}\n\t\n\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\textend(ShadyFragmentMixin, ShadyMixin);\n\t\n\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\n\t// function upgradeLogicalChildren(children) {\n\t//   if (needsUpgrade && children) {\n\t//     for (let i=0; i < children.length; i++) {\n\t//       CustomElements.upgrade(children[i]);\n\t//     }\n\t//   }\n\t// }\n\t\n\t// render enqueuer/flusher\n\tvar customElements = window.customElements;\n\tvar flushList = [];\n\tvar scheduled;\n\tvar flushCount = 0;\n\tvar flushMax = 100;\n\tfunction enqueue(callback) {\n\t  if (!scheduled) {\n\t    scheduled = true;\n\t    promish.then(flush$1);\n\t  }\n\t  flushList.push(callback);\n\t}\n\t\n\tfunction flush$1() {\n\t  scheduled = false;\n\t  flushCount++;\n\t  while (flushList.length) {\n\t    flushList.shift()();\n\t  }\n\t  if (customElements && customElements.flush) {\n\t    customElements.flush();\n\t  }\n\t  // continue flushing after elements are upgraded...\n\t  var isFlushedMaxed = (flushCount > flushMax);\n\t  if (flushList.length && !isFlushedMaxed) {\n\t      flush$1();\n\t  }\n\t  flushCount = 0;\n\t  if (isFlushedMaxed) {\n\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t  }\n\t}\n\t\n\tflush$1.list = flushList;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// Cribbed from ShadowDOM polyfill\n\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t/////////////////////////////////////////////////////////////////////////////\n\t// innerHTML and outerHTML\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\n\tfunction escapeReplace(c) {\n\t  switch (c) {\n\t    case '&':\n\t      return '&amp;';\n\t    case '<':\n\t      return '&lt;';\n\t    case '>':\n\t      return '&gt;';\n\t    case '\"':\n\t      return '&quot;';\n\t    case '\\u00A0':\n\t      return '&nbsp;';\n\t  }\n\t}\n\t\n\tfunction escapeAttr(s) {\n\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t}\n\t\n\tfunction escapeData(s) {\n\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t}\n\t\n\tfunction makeSet(arr) {\n\t  var set = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    set[arr[i]] = true;\n\t  }\n\t  return set;\n\t}\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\tvar voidElements = makeSet([\n\t  'area',\n\t  'base',\n\t  'br',\n\t  'col',\n\t  'command',\n\t  'embed',\n\t  'hr',\n\t  'img',\n\t  'input',\n\t  'keygen',\n\t  'link',\n\t  'meta',\n\t  'param',\n\t  'source',\n\t  'track',\n\t  'wbr'\n\t]);\n\t\n\tvar plaintextParents = makeSet([\n\t  'style',\n\t  'script',\n\t  'xmp',\n\t  'iframe',\n\t  'noembed',\n\t  'noframes',\n\t  'plaintext',\n\t  'noscript'\n\t]);\n\t\n\tfunction getOuterHTML(node, parentNode, composed) {\n\t  switch (node.nodeType) {\n\t    case Node.ELEMENT_NODE: {\n\t      var tagName = node.localName;\n\t      var s = '<' + tagName;\n\t      var attrs = node.attributes;\n\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t      }\n\t      s += '>';\n\t      if (voidElements[tagName]) {\n\t        return s;\n\t      }\n\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t    }\n\t    case Node.TEXT_NODE: {\n\t      var data = node.data;\n\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t        return data;\n\t      }\n\t      return escapeData(data);\n\t    }\n\t    case Node.COMMENT_NODE: {\n\t      return '<!--' + node.data + '-->';\n\t    }\n\t    default: {\n\t      window.console.error(node);\n\t      throw new Error('not implemented');\n\t    }\n\t  }\n\t}\n\t\n\tfunction getInnerHTML(node, composed) {\n\t  if (node.localName === 'template') {\n\t    node = node.content;\n\t  }\n\t  var s = '';\n\t  var c$ = composed ? composed(node) : node.childNodes;\n\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t    s += getOuterHTML(child, node, composed);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar mixinImpl = {\n\t\n\t  // Try to add node. Record logical info, track insertion points, perform\n\t  // distribution iff needed. Return true if the add is handled.\n\t  addNode: function addNode(container, node, ref_node) {\n\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t    if (ownerRoot) {\n\t      // optimization: special insertion point tracking\n\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t      }\n\t      // note: we always need to see if an insertion point is added\n\t      // since this saves logical tree info; however, invalidation state\n\t      // needs\n\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t      // invalidate insertion points IFF not already invalid!\n\t      if (ipAdded) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t      }\n\t    }\n\t    if (tree.Logical.hasChildNodes(container)) {\n\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t    }\n\t    // if not distributing and not adding to host, do a fast path addition\n\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t      container.shadyRoot;\n\t    return handled;\n\t  },\n\t\n\t  // Try to remove node: update logical info and perform distribution iff\n\t  // needed. Return true if the removal has been handled.\n\t  // note that it's possible for both the node's host and its parent\n\t  // to require distribution... both cases are handled here.\n\t  removeNode: function removeNode(node) {\n\t    // important that we want to do this only if the node has a logical parent\n\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t      tree.Logical.getParentNode(node);\n\t    var distributed;\n\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t    if (logicalParent) {\n\t      // distribute node's parent iff needed\n\t      distributed = this.maybeDistributeParent(node);\n\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t      // remove node from root and distribute it iff needed\n\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    this._removeOwnerShadyRoot(node);\n\t    return distributed;\n\t  },\n\t\n\t\n\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t    var observer = node.__dom && node.__dom.observer;\n\t    if (observer) {\n\t      if (addedNode) {\n\t        observer.addedNodes.push(addedNode);\n\t      }\n\t      if (removedNode) {\n\t        observer.removedNodes.push(removedNode);\n\t      }\n\t      observer.schedule();\n\t    }\n\t  },\n\t\n\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t    if (parent) {\n\t      this._scheduleObserver(parent, null, node);\n\t      this.removeNode(node);\n\t    } else {\n\t      this._removeOwnerShadyRoot(node);\n\t    }\n\t  },\n\t\n\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t  },\n\t\n\t  getRootNode: function getRootNode$1(node) {\n\t    if (!node || !node.nodeType) {\n\t      return;\n\t    }\n\t    var root = node.__ownerShadyRoot;\n\t    if (root === undefined) {\n\t      if (isShadyRoot(node)) {\n\t        root = node;\n\t      } else {\n\t        var parent = tree.Logical.getParentNode(node);\n\t        root = parent ? this.getRootNode(parent) : node;\n\t      }\n\t      // memo-ize result for performance but only memo-ize\n\t      // result if node is in the document. This avoids a problem where a root\n\t      // can be cached while an element is inside a fragment.\n\t      // If this happens and we cache the result, the value can become stale\n\t      // because for perf we avoid processing the subtree of added fragments.\n\t      if (document.documentElement.contains(node)) {\n\t        node.__ownerShadyRoot = root;\n\t      }\n\t    }\n\t    return root;\n\t  },\n\t\n\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t    var root = this.getRootNode(node);\n\t    if (isShadyRoot(root)) {\n\t      return root;\n\t    }\n\t  },\n\t\n\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t    // <content> children but since this case is assumed to be exceedingly\n\t    // rare, we avoid the cost and will address with some specific api\n\t    // when the need arises.  For now, the user must call\n\t    // distributeContent(true), which updates insertion points manually\n\t    // and forces distribution.\n\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t      !node.__noInsertionPoint &&\n\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t    var wrappedContent = fragContent &&\n\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t    // There are 3 possible cases where a distribution may need to occur:\n\t    // 1. <content> being inserted (the host of the shady root where\n\t    //    content is inserted needs distribution)\n\t    // 2. children being inserted into parent with a shady root (parent\n\t    //    needs distribution)\n\t    // 3. container is an insertionPoint\n\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t      if (ownerRoot) {\n\t        // note, insertion point list update is handled after node\n\t        // mutations are complete\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    var needsDist = this._nodeNeedsDistribution(container);\n\t    if (needsDist) {\n\t      container.shadyRoot.update();\n\t    }\n\t    // Return true when distribution will fully handle the composition\n\t    // Note that if a content was being inserted that was wrapped by a node,\n\t    // and the parent does not need distribution, return false to allow\n\t    // the nodes to be added directly, after which children may be\n\t    // distributed and composed into the wrapping node(s)\n\t    return needsDist || (hasContent && !wrappedContent);\n\t  },\n\t\n\t  /* note: parent argument is required since node may have an out\n\t  of date parent at this point; returns true if a <content> is being added */\n\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t    var this$1 = this;\n\t\n\t    var added;\n\t    var insertionPointTag = root.getInsertionPointTag();\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t      !node.__noInsertionPoint) {\n\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t        np = tree.Logical.getParentNode(n);\n\t        // don't allow node's parent to be fragment itself\n\t        if (np === node) {\n\t          np = parent;\n\t        }\n\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t        added = added || na;\n\t      }\n\t    } else if (node.localName === insertionPointTag) {\n\t      tree.Logical.saveChildNodes(parent);\n\t      tree.Logical.saveChildNodes(node);\n\t      added = true;\n\t    }\n\t    return added;\n\t  },\n\t\n\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t    return node && node.shadyRoot &&\n\t      node.shadyRoot.hasInsertionPoint();\n\t  },\n\t\n\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t    var this$1 = this;\n\t\n\t    var hostNeedsDist;\n\t    var ip$ = root._insertionPoints;\n\t    for (var i=0; i<ip$.length; i++) {\n\t      var insertionPoint = ip$[i];\n\t      if (this$1._contains(container, insertionPoint)) {\n\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t        for (var j=0; j<dc$.length; j++) {\n\t          hostNeedsDist = true;\n\t          var node = dc$[j];\n\t          var parent = tree.Composed.getParentNode(node);\n\t          if (parent) {\n\t            tree.Composed.removeChild(parent, node);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return hostNeedsDist;\n\t  },\n\t\n\t  _contains: function _contains(container, node) {\n\t    while (node) {\n\t      if (node == container) {\n\t        return true;\n\t      }\n\t      node = tree.Logical.getParentNode(node);\n\t    }\n\t  },\n\t\n\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t    var this$1 = this;\n\t\n\t    // optimization: only reset the tree if node is actually in a root\n\t    if (this._hasCachedOwnerRoot(node)) {\n\t      var c$ = tree.Logical.getChildNodes(node);\n\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t        this$1._removeOwnerShadyRoot(n);\n\t      }\n\t    }\n\t    node.__ownerShadyRoot = undefined;\n\t  },\n\t\n\t  // TODO(sorvell): This will fail if distribution that affects this\n\t  // question is pending; this is expected to be exceedingly rare, but if\n\t  // the issue comes up, we can force a flush in this case.\n\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t    var root = this.getRootNode(insertionPoint);\n\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t      // means that we're composed to this spot.\n\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t        return n;\n\t      }\n\t    }\n\t  },\n\t\n\t  clearNode: function clearNode(node) {\n\t    while (node.firstChild) {\n\t      node.removeChild(node.firstChild);\n\t    }\n\t  },\n\t\n\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t    var parent = tree.Logical.getParentNode(node);\n\t    if (this._nodeNeedsDistribution(parent)) {\n\t      parent.shadyRoot.update();\n\t      return true;\n\t    }\n\t  },\n\t\n\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t    if (name === 'slot') {\n\t      this.maybeDistributeParent(node);\n\t    } else if (node.localName === 'slot' && name === 'name') {\n\t      var root = this.ownerShadyRootForNode(node);\n\t      if (root) {\n\t        root.update();\n\t      }\n\t    }\n\t  },\n\t\n\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t  // but it's also generally useful to recurse through the element tree\n\t  // and is used by Polymer's styling system.\n\t  query: function query(node, matcher, halter) {\n\t    var list = [];\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t    return list;\n\t  },\n\t\n\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t    var this$1 = this;\n\t\n\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t          this$1._queryElement(c, matcher, halter, list)) {\n\t        return true;\n\t      }\n\t    }\n\t  },\n\t\n\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t    var result = matcher(node);\n\t    if (result) {\n\t      list.push(node);\n\t    }\n\t    if (halter && halter(result)) {\n\t      return result;\n\t    }\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t  },\n\t\n\t  activeElementForNode: function activeElementForNode(node) {\n\t    var this$1 = this;\n\t\n\t    var active = document.activeElement;\n\t    if (!active) {\n\t      return null;\n\t    }\n\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t    if (node !== document) {\n\t      // If this node isn't a document or shady root, then it doesn't have\n\t      // an active element.\n\t      if (!isShadyRoot$$1) {\n\t        return null;\n\t      }\n\t      // If this shady root's host is the active element or the active\n\t      // element is not a descendant of the host (in the composed tree),\n\t      // then it doesn't have an active element.\n\t      if (node.host === active ||\n\t          !node.host.contains(active)) {\n\t        return null;\n\t      }\n\t    }\n\t    // This node is either the document or a shady root of which the active\n\t    // element is a (composed) descendant of its host; iterate upwards to\n\t    // find the active element's most shallow host within it.\n\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t    while (activeRoot && activeRoot !== node) {\n\t      active = activeRoot.host;\n\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t    }\n\t    if (node === document) {\n\t      // This node is the document, so activeRoot should be null.\n\t      return activeRoot ? null : active;\n\t    } else {\n\t      // This node is a non-document shady root, and it should be\n\t      // activeRoot.\n\t      return activeRoot === node ? active : null;\n\t    }\n\t  }\n\t\n\t};\n\t\n\tvar nativeCloneNode = Element.prototype.cloneNode;\n\tvar nativeImportNode = Document.prototype.importNode;\n\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\n\tvar setAttribute = function(attr, value) {\n\t  if (window.ShadyCSS && attr === 'class') {\n\t    window.ShadyCSS.setElementClass(this, value);\n\t  } else {\n\t    nativeSetAttribute.call(this, attr, value);\n\t  }\n\t}\n\t\n\tvar NodeMixin = {};\n\t\n\tObject.defineProperties(NodeMixin, {\n\t\n\t  parentElement: {\n\t    get: function get() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  parentNode: {\n\t    get: function get$1() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextSibling: {\n\t    get: function get$2() {\n\t      return tree.Logical.getNextSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousSibling: {\n\t    get: function get$3() {\n\t      return tree.Logical.getPreviousSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextElementSibling: {\n\t    get: function get$4() {\n\t      return tree.Logical.getNextElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousElementSibling: {\n\t    get: function get$5() {\n\t      return tree.Logical.getPreviousElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  assignedSlot: {\n\t    get: function get$6() {\n\t      return this._assignedSlot;\n\t    },\n\t    configurable: true\n\t  }\n\t});\n\t\n\tvar FragmentMixin = {\n\t\n\t  appendChild: function appendChild(node) {\n\t    return this.insertBefore(node);\n\t  },\n\t\n\t  // cases in which we may not be able to just do standard native call\n\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t  // has an insertion point)\n\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t  // container to container.host.\n\t  // 3. node is <content> (host of container needs distribution)\n\t  insertBefore: function insertBefore(node, ref_node) {\n\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t        'of this node');\n\t    }\n\t    // remove node from its current position iff it's in a tree.\n\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var parent = tree.Logical.getParentNode(node);\n\t      mixinImpl.removeNodeFromParent(node, parent);\n\t    }\n\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t      if (ref_node) {\n\t        // if ref_node is an insertion point replace with first distributed node\n\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t        if (root) {\n\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t        }\n\t      }\n\t      // if adding to a shadyRoot, add to host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host : this;\n\t      if (ref_node) {\n\t        tree.Composed.insertBefore(container, node, ref_node);\n\t      } else {\n\t        tree.Composed.appendChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, node);\n\t    return node;\n\t  },\n\t\n\t  /**\n\t    Removes the given `node` from the element's `lightChildren`.\n\t    This method also performs dom composition.\n\t  */\n\t  removeChild: function removeChild(node) {\n\t    if (tree.Logical.getParentNode(node) !== this) {\n\t      throw Error('The node to be removed is not a child of this node: ' +\n\t        node);\n\t    }\n\t    if (!mixinImpl.removeNode(node)) {\n\t      // if removing from a shadyRoot, remove form host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host :\n\t        this;\n\t      // not guaranteed to physically be in container; e.g.\n\t      // undistributed nodes.\n\t      var parent = tree.Composed.getParentNode(node);\n\t      if (container === parent) {\n\t        tree.Composed.removeChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, null, node);\n\t    return node;\n\t  },\n\t\n\t  replaceChild: function replaceChild(node, ref_node) {\n\t    this.insertBefore(node, ref_node);\n\t    this.removeChild(ref_node);\n\t    return node;\n\t  },\n\t\n\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t  querySelector: function querySelector(selector) {\n\t    // match selector and halt on first result.\n\t    var result = mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    }, function(n) {\n\t      return Boolean(n);\n\t    })[0];\n\t    return result || null;\n\t  },\n\t\n\t  querySelectorAll: function querySelectorAll(selector) {\n\t    return mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    });\n\t  },\n\t\n\t  cloneNode: function cloneNode(deep) {\n\t    if (this.localName == 'template') {\n\t      return nativeCloneNode.call(this, deep);\n\t    } else {\n\t      var n = nativeCloneNode.call(this, false);\n\t      if (deep) {\n\t        var c$ = this.childNodes;\n\t        for (var i=0, nc; i < c$.length; i++) {\n\t          nc = c$[i].cloneNode(true);\n\t          n.appendChild(nc);\n\t        }\n\t      }\n\t      return n;\n\t    }\n\t  },\n\t\n\t  importNode: function importNode(externalNode, deep) {\n\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t    var doc = this instanceof Document ? this :\n\t      this.ownerDocument;\n\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t    if (deep) {\n\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t      common.patchNode(n);\n\t      for (var i=0, nc; i < c$.length; i++) {\n\t        nc = doc.importNode(c$[i], true);\n\t        n.appendChild(nc);\n\t      }\n\t    }\n\t    return n;\n\t  }\n\t};\n\t\n\tObject.defineProperties(FragmentMixin, {\n\t\n\t  childNodes: {\n\t    get: function get$7() {\n\t      var c$ = tree.Logical.getChildNodes(this);\n\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  children: {\n\t    get: function get$8() {\n\t      if (tree.Logical.hasChildNodes(this)) {\n\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t        });\n\t      } else {\n\t        return tree.arrayCopyChildren(this);\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstChild: {\n\t    get: function get$9() {\n\t      return tree.Logical.getFirstChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastChild: {\n\t    get: function get$10() {\n\t      return tree.Logical.getLastChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstElementChild: {\n\t    get: function get$11() {\n\t      return tree.Logical.getFirstElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastElementChild: {\n\t    get: function get$12() {\n\t      return tree.Logical.getLastElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t  // textContent / innerHTML\n\t  textContent: {\n\t    get: function get$13() {\n\t      if (this.childNodes) {\n\t        var tc = [];\n\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t            tc.push(c.textContent);\n\t          }\n\t        }\n\t        return tc.join('');\n\t      }\n\t      return '';\n\t    },\n\t    set: function set(text) {\n\t      mixinImpl.clearNode(this);\n\t      if (text) {\n\t        this.appendChild(document.createTextNode(text));\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  innerHTML: {\n\t    get: function get$14() {\n\t      return getInnerHTML(this);\n\t    },\n\t    set: function set$1(text) {\n\t      var this$1 = this;\n\t\n\t      mixinImpl.clearNode(this);\n\t      var d = document.createElement('div');\n\t      d.innerHTML = text;\n\t      // here, appendChild may move nodes async so we cannot rely\n\t      // on node position when copying\n\t      var c$ = tree.arrayCopyChildNodes(d);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1.appendChild(c$[i]);\n\t      }\n\t    },\n\t    configurable: true\n\t  }\n\t\n\t});\n\t\n\tvar ElementMixin = {\n\t\n\t  // TODO(sorvell): should only exist on <slot>\n\t  assignedNodes: function assignedNodes(options) {\n\t    return (options && options.flatten ? this._distributedNodes :\n\t      this._assignedNodes) || [];\n\t  },\n\t\n\t\n\t  setAttribute: function setAttribute$1(name, value) {\n\t    setAttribute.call(this, name, value);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  },\n\t\n\t  removeAttribute: function removeAttribute(name) {\n\t    nativeRemoveAttribute.call(this, name);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  }\n\t\n\t};\n\t\n\tObject.defineProperties(ElementMixin, {\n\t\n\t  shadowRoot: {\n\t    get: function get$15() {\n\t      return this.shadyRoot;\n\t    }\n\t  },\n\t\n\t  slot: {\n\t    get: function get$16() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set$2(value) {\n\t      this.setAttribute('slot', value);\n\t    }\n\t  }\n\t\n\t});\n\t\n\tvar activeElementDescriptor = {\n\t  get: function get$17() {\n\t    return mixinImpl.activeElementForNode(this);\n\t  }\n\t}\n\t\n\tvar ActiveElementMixin = {};\n\tObject.defineProperties(ActiveElementMixin, {\n\t  activeElement: activeElementDescriptor\n\t});\n\t\n\tvar UnderActiveElementMixin = {};\n\tObject.defineProperties(UnderActiveElementMixin, {\n\t  _activeElement: activeElementDescriptor\n\t});\n\t\n\tvar Mixins = {\n\t\n\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\n\t  Fragment: extendAll({__patched: 'Fragment'},\n\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\n\t  Element: extendAll({__patched: 'Element'},\n\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\n\t  // Note: activeElement cannot be patched on document!\n\t  Document: extendAll({__patched: 'Document'},\n\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\n\t};\n\t\n\tvar getRootNode = function(node) {\n\t  return mixinImpl.getRootNode(node);\n\t}\n\t\n\tfunction filterMutations(mutations, target) {\n\t  var targetRootNode = getRootNode(target);\n\t  return mutations.filter(function(mutation) {\n\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t    if (mutationInScope && mutation.addedNodes) {\n\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t        return (targetRootNode === getRootNode(n));\n\t      });\n\t      Object.defineProperty(mutation, 'addedNodes', {\n\t        value: nodes,\n\t        configurable: true\n\t      });\n\t    }\n\t    return mutationInScope &&\n\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t  });\n\t}\n\t\n\t// const promise = Promise.resolve();\n\t\n\tvar AsyncObserver = function AsyncObserver() {\n\t  this._scheduled = false;\n\t  this.addedNodes = [];\n\t  this.removedNodes = [];\n\t  this.callbacks = new Set();\n\t};\n\t\n\tAsyncObserver.prototype.schedule = function schedule () {\n\t    var this$1 = this;\n\t\n\t  if (!this._scheduled) {\n\t    this._scheduled = true;\n\t    promish.then(function () {\n\t      this$1.flush();\n\t    });\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.flush = function flush () {\n\t  if (this._scheduled) {\n\t    this._scheduled = false;\n\t    var mutations = this.takeRecords();\n\t    if (mutations.length) {\n\t      this.callbacks.forEach(function(cb) {\n\t        cb(mutations);\n\t      });\n\t    }\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t    var mutations = [{\n\t      addedNodes: this.addedNodes,\n\t      removedNodes: this.removedNodes\n\t    }];\n\t    this.addedNodes = [];\n\t    this.removedNodes = [];\n\t    return mutations;\n\t  }\n\t  return [];\n\t};\n\t\n\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t// directly so that users do not have to fork their code.\n\t// Supporting the entire api may be challenging: e.g. filtering out\n\t// removed nodes in the wrong scope and seeing non-distributing\n\t// subtree child mutations.\n\tvar observeChildren = function(node, callback) {\n\t  common.patchNode(node);\n\t  if (!node.__dom.observer) {\n\t    node.__dom.observer = new AsyncObserver();\n\t  }\n\t  node.__dom.observer.callbacks.add(callback);\n\t  var observer = node.__dom.observer;\n\t  return {\n\t    _callback: callback,\n\t    _observer: observer,\n\t    _node: node,\n\t    takeRecords: function takeRecords() {\n\t      return observer.takeRecords()\n\t    }\n\t  };\n\t}\n\t\n\tvar unobserveChildren = function(handle) {\n\t  var observer = handle && handle._observer;\n\t  if (observer) {\n\t    observer.callbacks.delete(handle._callback);\n\t    if (!observer.callbacks.size) {\n\t      handle._node.__dom.observer = null;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tvar patchedCount = 0;\n\t\n\tvar log = false;\n\t\n\tvar patchImpl = {\n\t\n\t  canPatchNode: function(node) {\n\t    switch (node) {\n\t      case document.head:\n\t      case document.documentElement:\n\t        return false;\n\t      default:\n\t        return true;\n\t    }\n\t  },\n\t\n\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t    window.Node.prototype, 'textContent')),\n\t\n\t  patch: function(node) {\n\t    patchedCount++;\n\t    log && window.console.warn('patch node', node);\n\t    if (this.hasPrototypeDescriptors) {\n\t      patchPrototype(node, this.mixinForObject(node));\n\t    } else {\n\t      window.console.warn('Patching instance rather than prototype', node);\n\t      extend(node, this.mixinForNode(node));\n\t    }\n\t  },\n\t\n\t  mixinForObject: function(obj) {\n\t    switch (obj.nodeType) {\n\t      case Node.ELEMENT_NODE:\n\t        return Mixins.Element;\n\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t        return Mixins.Fragment;\n\t      case Node.DOCUMENT_NODE:\n\t        return Mixins.Document;\n\t      case Node.TEXT_NODE:\n\t      case Node.COMMENT_NODE:\n\t        return Mixins.Node;\n\t    }\n\t  },\n\t\n\t  unpatch: function(obj) {\n\t    if (obj.__sourceProto) {\n\t      obj.__proto__ = obj.__sourceProto;\n\t\n\t    }\n\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t  }\n\t\n\t};\n\t\n\tfunction patchNode(node) {\n\t  if (!settings.inUse) {\n\t    return;\n\t  }\n\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t    tree.saveChildNodes(node);\n\t    patchImpl.patch(node);\n\t  }\n\t}\n\t\n\tfunction unpatchNode(node) {\n\t  patchImpl.unpatch(node);\n\t}\n\t\n\tfunction isNodePatched(node) {\n\t  return Boolean(node.__patched);\n\t}\n\t\n\t// TODO(sorvell): fake export\n\tcommon.patchNode = patchNode;\n\tcommon.isNodePatched = isNodePatched;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar origAddEventListener = Element.prototype.addEventListener;\n\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\n\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\tvar alwaysComposed = {\n\t  blur: true,\n\t  focus: true,\n\t  focusin: true,\n\t  focusout: true,\n\t  click: true,\n\t  dblclick: true,\n\t  mousedown: true,\n\t  mouseenter: true,\n\t  mouseleave: true,\n\t  mousemove: true,\n\t  mouseout: true,\n\t  mouseover: true,\n\t  mouseup: true,\n\t  wheel: true,\n\t  beforeinput: true,\n\t  input: true,\n\t  keydown: true,\n\t  keyup: true,\n\t  compositionstart: true,\n\t  compositionupdate: true,\n\t  compositionend: true,\n\t  touchstart: true,\n\t  touchend: true,\n\t  touchmove: true,\n\t  touchcancel: true,\n\t  pointerover: true,\n\t  pointerenter: true,\n\t  pointerdown: true,\n\t  pointermove: true,\n\t  pointerup: true,\n\t  pointercancel: true,\n\t  pointerout: true,\n\t  pointerleave: true,\n\t  gotpointercapture: true,\n\t  lostpointercapture: true,\n\t  dragstart: true,\n\t  drag: true,\n\t  dragenter: true,\n\t  dragleave: true,\n\t  dragover: true,\n\t  drop: true,\n\t  dragend: true,\n\t  DOMActivate: true,\n\t  DOMFocusIn: true,\n\t  DOMFocusOut: true,\n\t  keypress: true\n\t};\n\t\n\tfunction pathComposer(startNode, composed) {\n\t  var composedPath = [];\n\t  var current = startNode;\n\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t  while (current) {\n\t    composedPath.push(current);\n\t    if (current.assignedSlot) {\n\t      current = current.assignedSlot;\n\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t      current = current.host;\n\t    } else {\n\t      current = current.parentNode;\n\t    }\n\t  }\n\t  // event composedPath includes window when startNode's ownerRoot is document\n\t  if (composedPath[composedPath.length - 1] === document) {\n\t    composedPath.push(window);\n\t  }\n\t  return composedPath;\n\t}\n\t\n\tfunction retarget(refNode, path) {\n\t  if (!isShadyRoot) {\n\t    return refNode;\n\t  }\n\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t  var refNodePath = pathComposer(refNode, true);\n\t  var p$ = path;\n\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t    ancestor = p$[i];\n\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t    if (root !== lastRoot) {\n\t      rootIdx = refNodePath.indexOf(root);\n\t      lastRoot = root;\n\t    }\n\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t      return ancestor;\n\t    }\n\t  }\n\t}\n\t\n\tvar EventMixin = {\n\t\n\t  __patched: 'Event',\n\t\n\t  get composed() {\n\t    if (this.isTrusted && this.__composed === undefined) {\n\t      this.__composed = alwaysComposed[this.type];\n\t    }\n\t    return this.__composed || false;\n\t  },\n\t\n\t  composedPath: function composedPath() {\n\t    if (!this.__composedPath) {\n\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t    }\n\t    return this.__composedPath;\n\t  },\n\t\n\t  get target() {\n\t    return retarget(this.currentTarget, this.composedPath());\n\t  },\n\t\n\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t  get relatedTarget() {\n\t    if (!this.__relatedTarget) {\n\t      return null;\n\t    }\n\t    if (!this.__relatedTargetComposedPath) {\n\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t    }\n\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t  },\n\t  stopPropagation: function stopPropagation() {\n\t    Event.prototype.stopPropagation.call(this);\n\t    this.__propagationStopped = true;\n\t  },\n\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t    Event.prototype.stopImmediatePropagation.call(this);\n\t    this.__immediatePropagationStopped = true;\n\t    this.__propagationStopped = true;\n\t  }\n\t\n\t};\n\t\n\tfunction mixinComposedFlag(Base) {\n\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t  // try to do `Base.call` with a dom construtor.\n\t  var klazz = function(type, options) {\n\t    var event = new Base(type, options);\n\t    event.__composed = options && Boolean(options.composed);\n\t    return event;\n\t  }\n\t  // put constructor properties on subclass\n\t  mixin(klazz, Base);\n\t  klazz.prototype = Base.prototype;\n\t  return klazz;\n\t}\n\t\n\tvar nonBubblingEventsToRetarget = {\n\t  focus: true,\n\t  blur: true\n\t};\n\t\n\tfunction fireHandlers(event, node, phase) {\n\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t    node.__handlers[event.type][phase];\n\t  if (hs) {\n\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t      fn.call(node, event);\n\t      if (event.__immediatePropagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction retargetNonBubblingEvent(e) {\n\t  var path = e.composedPath();\n\t  var node;\n\t  // override `currentTarget` to let patched `target` calculate correctly\n\t  Object.defineProperty(e, 'currentTarget', {\n\t    get: function() {\n\t      return node;\n\t    },\n\t    configurable: true\n\t  });\n\t  for (var i = path.length - 1; i >= 0; i--) {\n\t    node = path[i];\n\t    // capture phase fires all capture handlers\n\t    fireHandlers(e, node, 'capture');\n\t    if (e.__propagationStopped) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  // set the event phase to `AT_TARGET` as in spec\n\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\n\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t  // keep track of the last seen owner root\n\t  var lastFiredRoot;\n\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t    node = path[i$1];\n\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t      fireHandlers(e, node, 'bubble');\n\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t      if (node !== window) {\n\t        lastFiredRoot = node.getRootNode();\n\t      }\n\t      if (e.__propagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t  // It's more efficient to store the node/type/options information as Array in\n\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  if (fn.__eventWrappers) {\n\t    // Stop if the wrapper function has already been created.\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        return;\n\t      }\n\t    }\n\t  } else {\n\t    fn.__eventWrappers = [];\n\t  }\n\t\n\t  var wrapperFn = function(e) {\n\t    // Support `once` option.\n\t    if (once) {\n\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t    }\n\t    if (!e.__target) {\n\t      e.__target = e.target;\n\t      e.__relatedTarget = e.relatedTarget;\n\t      patchPrototype(e, EventMixin);\n\t    }\n\t    // There are two critera that should stop events from firing on this node\n\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t        if (e.target === e.relatedTarget) {\n\t          e.stopImmediatePropagation();\n\t          return;\n\t        }\n\t      }\n\t      return fn(e);\n\t    }\n\t  };\n\t  // Store the wrapper information.\n\t  fn.__eventWrappers.push({\n\t    node: this,\n\t    type: type,\n\t    capture: capture,\n\t    once: once,\n\t    passive: passive,\n\t    wrapperFn: wrapperFn\n\t  });\n\t\n\t  if (nonBubblingEventsToRetarget[type]) {\n\t    this.__handlers = this.__handlers || {};\n\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t  } else {\n\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  // Search the wrapped function.\n\t  var wrapperFn = undefined;\n\t  if (fn.__eventWrappers) {\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t        // Cleanup.\n\t        if (!fn.__eventWrappers.length) {\n\t          fn.__eventWrappers = undefined;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t      this.__handlers && this.__handlers[type]) {\n\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t    var idx = arr.indexOf(wrapperFn);\n\t    if (idx > -1) {\n\t      arr.splice(idx, 1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction activateFocusEventOverrides() {\n\t  for (var ev in nonBubblingEventsToRetarget) {\n\t    window.addEventListener(ev, function(e) {\n\t      if (!e.__target) {\n\t        e.__target = e.target;\n\t        e.__relatedTarget = e.relatedTarget;\n\t        patchPrototype(e, EventMixin);\n\t        retargetNonBubblingEvent(e);\n\t        e.stopImmediatePropagation();\n\t      }\n\t    }, true);\n\t  }\n\t}\n\t\n\t\n\tvar PatchedEvent = mixinComposedFlag(Event);\n\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tif (settings.inUse) {\n\t\n\t  window.ShadyDOM = {\n\t    tree: tree,\n\t    getNativeProperty: getNativeProperty,\n\t    patch: patchNode,\n\t    isPatched: isNodePatched,\n\t    unpatch: unpatchNode,\n\t    isShadyRoot: isShadyRoot,\n\t    enqueue: enqueue,\n\t    flush: flush$1,\n\t    inUse: settings.inUse,\n\t    filterMutations: filterMutations,\n\t    observeChildren: observeChildren,\n\t    unobserveChildren: unobserveChildren\n\t  };\n\t\n\t  var createRootAndEnsurePatched = function(node) {\n\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t    // a timing problem with gathering composed children.\n\t    // (1) currently the child list is crawled and patched when patching occurs\n\t    // (this needs to change)\n\t    // (2) we can only patch when an element has received its parsed children\n\t    // because we cannot detect them when inserted by parser.\n\t    // let ancestor = node;\n\t    // while (ancestor) {\n\t    //   patchNode(ancestor);\n\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t    // }\n\t    patchNode(node);\n\t    var root = new ShadyRoot(node);\n\t    patchNode(root);\n\t    return root;\n\t  }\n\t\n\t  Element.prototype.attachShadow = function() {\n\t    return createRootAndEnsurePatched(this);\n\t  }\n\t\n\t  Node.prototype.addEventListener = addEventListener;\n\t  Node.prototype.removeEventListener = removeEventListener;\n\t  Event = PatchedEvent;\n\t  CustomEvent = PatchedCustomEvent;\n\t  MouseEvent = PatchedMouseEvent;\n\t  activateFocusEventOverrides();\n\t\n\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t    get: function get() {\n\t      return document.documentElement.contains(this);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Node.prototype.getRootNode = function(options) {\n\t    return getRootNode(this, options);\n\t  }\n\t\n\t  Object.defineProperty(Element.prototype, 'slot', {\n\t    get: function get$1() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set(value) {\n\t      this.setAttribute('slot', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t    get: function get$2() {\n\t      return this._assignedSlot || null;\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Element.prototype.setAttribute = setAttribute;\n\t\n\t  Object.defineProperty(Element.prototype, 'className', {\n\t    get: function get$3() {\n\t      return this.getAttribute('class');\n\t    },\n\t    set: function set$1(value) {\n\t      this.setAttribute('class', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t  // via appendChild. This either needs to be expanded or contracted.\n\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t  //   patchNode(this);\n\t  //   return this.appendChild(node);\n\t  // }\n\t\n\t}\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadydom.min.js.map\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tExtremely simple css parser. Intended to be not more than what we need\n\tand definitely not necessarily correct =).\n\t*/\n\t\n\t// given a string of css, return a simple rule tree\n\t\n\tfunction parse(text) {\n\t  text = clean(text);\n\t  return parseCss(lex(text), text);\n\t}\n\t\n\t// remove stuff we don't care about that may hinder parsing\n\tfunction clean(cssText) {\n\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t}\n\t\n\t// super simple {...} lexer that returns a node tree\n\tfunction lex(text) {\n\t  var root = {\n\t    start: 0,\n\t    end: text.length\n\t  };\n\t  var n = root;\n\t  for (var i = 0, l = text.length; i < l; i++) {\n\t    if (text[i] === OPEN_BRACE) {\n\t      if (!n.rules) {\n\t        n.rules = [];\n\t      }\n\t      var p = n;\n\t      var previous = p.rules[p.rules.length - 1];\n\t      n = {\n\t        start: i + 1,\n\t        parent: p,\n\t        previous: previous\n\t      };\n\t      p.rules.push(n);\n\t    } else if (text[i] === CLOSE_BRACE) {\n\t      n.end = i + 1;\n\t      n = n.parent || root;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// add selectors/cssText to node tree\n\tfunction parseCss(node, text) {\n\t  var t = text.substring(node.start, node.end - 1);\n\t  node.parsedCssText = node.cssText = t.trim();\n\t  if (node.parent) {\n\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t    t = text.substring(ss, node.start - 1);\n\t    t = _expandUnicodeEscapes(t);\n\t    t = t.replace(RX.multipleSpaces, ' ');\n\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t    // helps with mixin syntax\n\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t    var s = node.parsedSelector = node.selector = t.trim();\n\t    node.atRule = s.indexOf(AT_START) === 0;\n\t    // note, support a subset of rule types...\n\t    if (node.atRule) {\n\t      if (s.indexOf(MEDIA_START) === 0) {\n\t        node.type = types.MEDIA_RULE;\n\t      } else if (s.match(RX.keyframesRule)) {\n\t        node.type = types.KEYFRAMES_RULE;\n\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t      }\n\t    } else {\n\t      if (s.indexOf(VAR_START) === 0) {\n\t        node.type = types.MIXIN_RULE;\n\t      } else {\n\t        node.type = types.STYLE_RULE;\n\t      }\n\t    }\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      parseCss(r, text);\n\t    }\n\t  }\n\t  return node;\n\t}\n\t\n\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t// expanded form that doesn't require trailing space `\\000033`\n\tfunction _expandUnicodeEscapes(s) {\n\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t    var code = arguments[1],\n\t        repeat = 6 - code.length;\n\t    while (repeat--) {\n\t      code = '0' + code;\n\t    }\n\t    return '\\\\' + code;\n\t  });\n\t}\n\t\n\t// stringify parsed css.\n\tfunction stringify(node, preserveProperties, text) {\n\t  text = text || '';\n\t  // calc rule cssText\n\t  var cssText = '';\n\t  if (node.cssText || node.rules) {\n\t    var r$ = node.rules;\n\t    if (r$ && !_hasMixinRules(r$)) {\n\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t        cssText = stringify(r, preserveProperties, cssText);\n\t      }\n\t    } else {\n\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t      cssText = cssText.trim();\n\t      if (cssText) {\n\t        cssText = '  ' + cssText + '\\n';\n\t      }\n\t    }\n\t  }\n\t  // emit rule if there is cssText\n\t  if (cssText) {\n\t    if (node.selector) {\n\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t    }\n\t    text += cssText;\n\t    if (node.selector) {\n\t      text += CLOSE_BRACE + '\\n\\n';\n\t    }\n\t  }\n\t  return text;\n\t}\n\t\n\tfunction _hasMixinRules(rules) {\n\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t}\n\t\n\tfunction removeCustomProps(cssText) {\n\t  cssText = removeCustomPropAssignment(cssText);\n\t  return removeCustomPropApply(cssText);\n\t}\n\t\n\tfunction removeCustomPropAssignment(cssText) {\n\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t}\n\t\n\tfunction removeCustomPropApply(cssText) {\n\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t}\n\t\n\tvar types = {\n\t  STYLE_RULE: 1,\n\t  KEYFRAMES_RULE: 7,\n\t  MEDIA_RULE: 4,\n\t  MIXIN_RULE: 1000\n\t};\n\t\n\tvar OPEN_BRACE = '{';\n\tvar CLOSE_BRACE = '}';\n\t\n\t// helper regexp's\n\tvar RX = {\n\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t  port: /@import[^;]*;/gim,\n\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t  multipleSpaces: /\\s+/g\n\t};\n\t\n\tvar VAR_START = '--';\n\tvar MEDIA_START = '@media';\n\tvar AT_START = '@';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\n\t// experimental support for native @apply\n\tfunction detectNativeApply() {\n\t  var style = document.createElement('style');\n\t  style.textContent = '.foo { @apply --foo }';\n\t  document.head.appendChild(style);\n\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t  document.head.removeChild(style);\n\t  return nativeCssApply;\n\t}\n\t\n\tvar nativeCssApply = false && detectNativeApply();\n\t\n\tfunction parseSettings(settings) {\n\t  if (settings) {\n\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t  }\n\t}\n\t\n\tif (window.ShadyCSS) {\n\t  parseSettings(window.ShadyCSS);\n\t} else if (window.WebComponents) {\n\t  parseSettings(window.WebComponents.flags);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction toCssText(rules, callback) {\n\t  if (typeof rules === 'string') {\n\t    rules = parse(rules);\n\t  }\n\t  if (callback) {\n\t    forEachRule(rules, callback);\n\t  }\n\t  return stringify(rules, nativeCssVariables);\n\t}\n\t\n\tfunction rulesForStyle(style) {\n\t  if (!style.__cssRules && style.textContent) {\n\t    style.__cssRules = parse(style.textContent);\n\t  }\n\t  return style.__cssRules;\n\t}\n\t\n\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t// like a normal selector but is not (it has nothing to do with scoping\n\t// for example).\n\tfunction isKeyframesSelector(rule) {\n\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t}\n\t\n\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t  if (!node) {\n\t    return;\n\t  }\n\t  var skipRules = false;\n\t  if (onlyActiveRules) {\n\t    if (node.type === types.MEDIA_RULE) {\n\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t      if (matchMedia) {\n\t        // if rule is a non matching @media rule, skip subrules\n\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t          skipRules = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  if (node.type === types.STYLE_RULE) {\n\t    styleRuleCallback(node);\n\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t    keyframesRuleCallback(node);\n\t  } else if (node.type === types.MIXIN_RULE) {\n\t    skipRules = true;\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$ && !skipRules) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t    }\n\t  }\n\t}\n\t\n\t// add a string of cssText to the document.\n\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t  var style = createScopeStyle(cssText, moniker);\n\t  return applyStyle$1(style, target, contextNode);\n\t}\n\t\n\tfunction applyStyle$1(style, target, contextNode) {\n\t  target = target || document.head;\n\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t  lastHeadApplyNode = style;\n\t  return target.insertBefore(style, after);\n\t}\n\t\n\tfunction createScopeStyle(cssText, moniker) {\n\t  var style = document.createElement('style');\n\t  if (moniker) {\n\t    style.setAttribute('scope', moniker);\n\t  }\n\t  style.textContent = cssText;\n\t  return style;\n\t}\n\t\n\tvar lastHeadApplyNode = null;\n\t\n\t// insert a comment node as a styling position placeholder.\n\tfunction applyStylePlaceHolder(moniker) {\n\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t  var scope = document.head;\n\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t  lastHeadApplyNode = placeHolder;\n\t  return placeHolder;\n\t}\n\t\n\t\n\t\n\t// cssBuildTypeForModule: function (module) {\n\t//   let dm = Polymer.DomModule.import(module);\n\t//   if (dm) {\n\t//     return getCssBuildType(dm);\n\t//   }\n\t// },\n\t//\n\t\n\t\n\t// Walk from text[start] matching parens\n\t// returns position of the outer end paren\n\tfunction findMatchingParen(text, start) {\n\t  var level = 0;\n\t  for (var i = start, l = text.length; i < l; i++) {\n\t    if (text[i] === '(') {\n\t      level++;\n\t    } else if (text[i] === ')') {\n\t      if (--level === 0) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tfunction processVariableAndFallback(str, callback) {\n\t  // find 'var('\n\t  var start = str.indexOf('var(');\n\t  if (start === -1) {\n\t    // no var?, everything is prefix\n\t    return callback(str, '', '', '');\n\t  }\n\t  //${prefix}var(${inner})${suffix}\n\t  var end = findMatchingParen(str, start + 3);\n\t  var inner = str.substring(start + 4, end);\n\t  var prefix = str.substring(0, start);\n\t  // suffix may have other variables\n\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t  var comma = inner.indexOf(',');\n\t  // value and fallback args should be trimmed to match in property lookup\n\t  if (comma === -1) {\n\t    // variable, no fallback\n\t    return callback(prefix, inner.trim(), '', suffix);\n\t  }\n\t  // var(${value},${fallback})\n\t  var value = inner.substring(0, comma).trim();\n\t  var fallback = inner.substring(comma + 1).trim();\n\t  return callback(prefix, value, fallback, suffix);\n\t}\n\t\n\tvar rx = {\n\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t  IS_VAR: /^--/,\n\t  BRACKETED: /\\{[^}]*\\}/g,\n\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\n\t* scoping:\n\t\n\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t  * selectors re-written as follows:\n\t\n\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\n\t* :host -> scopeName\n\t\n\t* :host(...) -> scopeName...\n\t\n\t* ::slotted(...) -> scopeName > ...\n\t\n\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\n\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\n\t*/\n\tvar SCOPE_NAME = 'style-scope';\n\t\n\tvar StyleTransformer = {\n\t\n\t  // Given a node and scope name, add a scoping class to each node\n\t  // in the tree. This facilitates transforming css into scoped rules.\n\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t    // one time optimization to skip scoping...\n\t    if (node.__styleScoped) {\n\t      node.__styleScoped = null;\n\t    } else {\n\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t    }\n\t  },\n\t\n\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t    if (node.classList) {\n\t      this.element(node, selector, shouldRemoveScope);\n\t    }\n\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t    if (c$) {\n\t      for (var i = 0; i < c$.length; i++) {\n\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t      }\n\t    }\n\t  },\n\t\n\t  element: function element(_element, scope, shouldRemoveScope) {\n\t    // note: if using classes, we add both the general 'style-scope' class\n\t    // as well as the specific scope. This enables easy filtering of all\n\t    // `style-scope` elements\n\t    if (scope) {\n\t      // note: svg on IE does not have classList so fallback to class\n\t      if (_element.classList) {\n\t        if (shouldRemoveScope) {\n\t          _element.classList.remove(SCOPE_NAME);\n\t          _element.classList.remove(scope);\n\t        } else {\n\t          _element.classList.add(SCOPE_NAME);\n\t          _element.classList.add(scope);\n\t        }\n\t      } else if (_element.getAttribute) {\n\t        var c = _element.getAttribute(CLASS);\n\t        if (shouldRemoveScope) {\n\t          if (c) {\n\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t          }\n\t        } else {\n\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t    var cssBuildType = element.__cssBuild;\n\t    // no need to shim selectors if settings.useNativeShadow, also\n\t    // a shady css build will already have transformed selectors\n\t    // NOTE: This method may be called as part of static or property shimming.\n\t    // When there is a targeted build it will not be called for static shimming,\n\t    // but when the property shim is used it is called and should opt out of\n\t    // static shimming work when a proper build exists.\n\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t    return cssText.trim();\n\t  },\n\t\n\t  // Given a string of cssText and a scoping string (scope), returns\n\t  // a string of scoped css where each selector is transformed to include\n\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t  // (e.g. :host) to use the scoping selector.\n\t  css: function css(rules, scope, ext, callback) {\n\t    var hostScope = this._calcHostScope(scope, ext);\n\t    scope = this._calcElementScope(scope);\n\t    var self = this;\n\t    return toCssText(rules, function (rule) {\n\t      if (!rule.isScoped) {\n\t        self.rule(rule, scope, hostScope);\n\t        rule.isScoped = true;\n\t      }\n\t      if (callback) {\n\t        callback(rule, scope, hostScope);\n\t      }\n\t    });\n\t  },\n\t\n\t  _calcElementScope: function _calcElementScope(scope) {\n\t    if (scope) {\n\t      return CSS_CLASS_PREFIX + scope;\n\t    } else {\n\t      return '';\n\t    }\n\t  },\n\t\n\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t    return ext ? '[is=' + scope + ']' : scope;\n\t  },\n\t\n\t  rule: function rule(_rule, scope, hostScope) {\n\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t  },\n\t\n\t  // transforms a css rule to a scoped rule.\n\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t    // against selectors (e.g. when calculating style properties)\n\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t  },\n\t\n\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t    // we want to skip transformation of rules that appear in keyframes,\n\t    // because they are keyframe selectors, not element selectors.\n\t    if (!isKeyframesSelector(rule)) {\n\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t      }\n\t    }\n\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t  },\n\t\n\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t    var _this = this;\n\t\n\t    var stop = false;\n\t    selector = selector.trim();\n\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t    });\n\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t      if (!stop) {\n\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t        stop = stop || info.stop;\n\t        c = info.combinator;\n\t        s = info.value;\n\t      }\n\t      return c + s;\n\t    });\n\t    return selector;\n\t  },\n\t\n\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t    // replace :host with host scoping class\n\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t    if (selector.indexOf(HOST) >= 0) {\n\t      selector = this._transformHostSelector(selector, hostScope);\n\t      // replace other selectors with scoping class\n\t    } else if (slottedIndex !== 0) {\n\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t    }\n\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t    // also ignore left-side combinator\n\t    var slotted = false;\n\t    if (slottedIndex >= 0) {\n\t      combinator = '';\n\t      slotted = true;\n\t    }\n\t    // process scope jumping selectors up to the scope jump and then stop\n\t    var stop = void 0;\n\t    if (slotted) {\n\t      stop = true;\n\t      if (slotted) {\n\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t          return ' > ' + paren;\n\t        });\n\t      }\n\t    }\n\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t    });\n\t    return { value: selector, combinator: combinator, stop: stop };\n\t  },\n\t\n\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t    p$[0] += scope;\n\t    return p$.join(PSEUDO_PREFIX);\n\t  },\n\t\n\t  // :host(...) -> scopeName...\n\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t    var m = selector.match(HOST_PAREN);\n\t    var paren = m && m[2].trim() || '';\n\t    if (paren) {\n\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t        // paren starts with a type selector\n\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t        // if the type selector is our hostScope then avoid pre-pending it\n\t        if (typeSelector === hostScope) {\n\t          return paren;\n\t          // otherwise, this selector should not match in this scope so\n\t          // output a bogus selector.\n\t        } else {\n\t          return SELECTOR_NO_MATCH;\n\t        }\n\t      } else {\n\t        // make sure to do a replace here to catch selectors like:\n\t        // `:host(.foo)::before`\n\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t          return hostScope + paren;\n\t        });\n\t      }\n\t      // if no paren, do a straight :host replacement.\n\t      // TODO(sorvell): this should not strictly be necessary but\n\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t      // which have been improperly used under Shady DOM. This should be\n\t      // deprecated.\n\t    } else {\n\t      return selector.replace(HOST, hostScope);\n\t    }\n\t  },\n\t\n\t  documentRule: function documentRule(rule) {\n\t    // reset selector in case this is redone.\n\t    rule.selector = rule.parsedSelector;\n\t    this.normalizeRootSelector(rule);\n\t    this._transformRule(rule, this._transformDocumentSelector);\n\t  },\n\t\n\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t    if (rule.selector === ROOT) {\n\t      rule.selector = 'html';\n\t    }\n\t  },\n\t\n\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t  },\n\t  SCOPE_NAME: SCOPE_NAME\n\t};\n\t\n\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\tvar COMPLEX_SELECTOR_SEP = ',';\n\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\tvar HOST = ':host';\n\tvar ROOT = ':root';\n\tvar SLOTTED = '::slotted';\n\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t// NOTE: this supports 1 nested () pair for things like\n\t// :host(:not([selected]), more general support requires\n\t// parsing which seems like overkill\n\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t// similar to HOST_PAREN\n\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\tvar CSS_CLASS_PREFIX = '.';\n\tvar PSEUDO_PREFIX = ':';\n\tvar CLASS = 'class';\n\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar StyleInfo = function () {\n\t  createClass(StyleInfo, null, [{\n\t    key: 'get',\n\t    value: function get(node) {\n\t      return node.__styleInfo;\n\t    }\n\t  }, {\n\t    key: 'set',\n\t    value: function set(node, styleInfo) {\n\t      node.__styleInfo = styleInfo;\n\t      return styleInfo;\n\t    }\n\t  }]);\n\t\n\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t    classCallCheck(this, StyleInfo);\n\t\n\t    this.styleRules = ast || null;\n\t    this.placeholder = placeholder || null;\n\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t    this.overrideStyleProperties = {};\n\t    this.elementName = elementName || '';\n\t    this.cssBuild = cssBuild || '';\n\t    this.typeExtension = typeExtension || '';\n\t    this.styleProperties = null;\n\t    this.scopeSelector = null;\n\t    this.customStyle = null;\n\t  }\n\t\n\t  return StyleInfo;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO: dedupe with shady\n\tvar p = window.Element.prototype;\n\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\n\tvar StyleProperties = {\n\t\n\t  // decorates styles with rule info and returns an array of used style\n\t  // property names\n\t  decorateStyles: function decorateStyles(rules) {\n\t    var self = this,\n\t        props = {},\n\t        keyframes = [],\n\t        ruleIndex = 0;\n\t    forEachRule(rules, function (rule) {\n\t      self.decorateRule(rule);\n\t      // mark in-order position of ast rule in styles block, used for cache key\n\t      rule.index = ruleIndex++;\n\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t    }, function onKeyframesRule(rule) {\n\t      keyframes.push(rule);\n\t    });\n\t    // Cache all found keyframes rules for later reference:\n\t    rules._keyframes = keyframes;\n\t    // return this list of property names *consumes* in these styles.\n\t    var names = [];\n\t    for (var i in props) {\n\t      names.push(i);\n\t    }\n\t    return names;\n\t  },\n\t\n\t  // decorate a single rule with property info\n\t  decorateRule: function decorateRule(rule) {\n\t    if (rule.propertyInfo) {\n\t      return rule.propertyInfo;\n\t    }\n\t    var info = {},\n\t        properties = {};\n\t    var hasProperties = this.collectProperties(rule, properties);\n\t    if (hasProperties) {\n\t      info.properties = properties;\n\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t      rule.rules = null;\n\t    }\n\t    info.cssText = this.collectCssText(rule);\n\t    rule.propertyInfo = info;\n\t    return info;\n\t  },\n\t\n\t  // collects the custom properties from a rule's cssText\n\t  collectProperties: function collectProperties(rule, properties) {\n\t    var info = rule.propertyInfo;\n\t    if (info) {\n\t      if (info.properties) {\n\t        Object.assign(properties, info.properties);\n\t        return true;\n\t      }\n\t    } else {\n\t      var m = void 0,\n\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t      var cssText = rule.parsedCssText;\n\t      var value = void 0;\n\t      var any = void 0;\n\t      while (m = rx$$1.exec(cssText)) {\n\t        // note: group 2 is var, 3 is mixin\n\t        value = (m[2] || m[3]).trim();\n\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t        if (value !== 'inherit' || value !== 'unset') {\n\t          properties[m[1].trim()] = value;\n\t        }\n\t        any = true;\n\t      }\n\t      return any;\n\t    }\n\t  },\n\t\n\t  // returns cssText of properties that consume variables/mixins\n\t  collectCssText: function collectCssText(rule) {\n\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t  },\n\t\n\t  // NOTE: we support consumption inside mixin assignment\n\t  // but not production, so strip out {...}\n\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t  },\n\t\n\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t    var m = void 0;\n\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t      var name = m[1];\n\t      // This regex catches all variable names, and following non-whitespace char\n\t      // If next char is not ':', then variable is a consumer\n\t      if (m[2] !== ':') {\n\t        props[name] = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  // turns custom properties into realized values.\n\t  reify: function reify(props) {\n\t    // big perf optimization here: reify only *own* properties\n\t    // since this object has __proto__ of the element's scope properties\n\t    var names = Object.getOwnPropertyNames(props);\n\t    for (var i = 0, n; i < names.length; i++) {\n\t      n = names[i];\n\t      props[n] = this.valueForProperty(props[n], props);\n\t    }\n\t  },\n\t\n\t  // given a property value, returns the reified value\n\t  // a property value may be:\n\t  // (1) a literal value like: red or 5px;\n\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t  // var(--a, var(--b));\n\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t  valueForProperty: function valueForProperty(property, props) {\n\t    var _this = this;\n\t\n\t    // case (1) default\n\t    // case (3) defines a mixin and we have to reify the internals\n\t    if (property) {\n\t      if (property.indexOf(';') >= 0) {\n\t        property = this.valueForProperties(property, props);\n\t      } else {\n\t        (function () {\n\t          // case (2) variable\n\t          var self = _this;\n\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t            if (!value) {\n\t              return prefix + suffix;\n\t            }\n\t            var propertyValue = self.valueForProperty(props[value], props);\n\t            // if value is \"initial\", then the variable should be treated as unset\n\t            if (!propertyValue || propertyValue === 'initial') {\n\t              // fallback may be --a or var(--a) or literal\n\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t              // for use with native css variables.\n\t              // Since we have full control, we can use `inherit` directly.\n\t              propertyValue = 'inherit';\n\t            }\n\t            return prefix + (propertyValue || '') + suffix;\n\t          };\n\t          property = processVariableAndFallback(property, fn);\n\t        })();\n\t      }\n\t    }\n\t    return property && property.trim() || '';\n\t  },\n\t\n\t  // note: we do not yet support mixin within mixin\n\t  valueForProperties: function valueForProperties(property, props) {\n\t    var parts = property.split(';');\n\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t      if (_p = parts[i]) {\n\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t        if (m) {\n\t          _p = this.valueForProperty(props[m[1]], props);\n\t        } else {\n\t          var colon = _p.indexOf(':');\n\t          if (colon !== -1) {\n\t            var pp = _p.substring(colon);\n\t            pp = pp.trim();\n\t            pp = this.valueForProperty(pp, props) || pp;\n\t            _p = _p.substring(0, colon) + pp;\n\t          }\n\t        }\n\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t        // strip trailing ;\n\t        _p.slice(0, -1) : _p || '';\n\t      }\n\t    }\n\t    return parts.join(';');\n\t  },\n\t\n\t  applyProperties: function applyProperties(rule, props) {\n\t    var output = '';\n\t    // dynamically added sheets may not be decorated so ensure they are.\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (rule.propertyInfo.cssText) {\n\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t  // functions which take in cssText and spit out transformed cssText.\n\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t    var input = rule.cssText;\n\t    var output = rule.cssText;\n\t    if (rule.hasAnimations == null) {\n\t      // Cache whether or not the rule has any animations to begin with:\n\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t    }\n\t    // If there are no animations referenced, we can skip transforms:\n\t    if (rule.hasAnimations) {\n\t      var transform = void 0;\n\t      // If we haven't transformed this rule before, we iterate over all\n\t      // transforms:\n\t      if (rule.keyframeNamesToTransform == null) {\n\t        rule.keyframeNamesToTransform = [];\n\t        for (var keyframe in keyframeTransforms) {\n\t          transform = keyframeTransforms[keyframe];\n\t          output = transform(input);\n\t          // If the transform actually changed the CSS text, we cache the\n\t          // transform name for future use:\n\t          if (input !== output) {\n\t            input = output;\n\t            rule.keyframeNamesToTransform.push(keyframe);\n\t          }\n\t        }\n\t      } else {\n\t        // If we already have a list of keyframe names that apply to this\n\t        // rule, we apply only those keyframe name transforms:\n\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t          input = transform(input);\n\t        }\n\t        output = input;\n\t      }\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Test if the rules in these styles matches the given `element` and if so,\n\t  // collect any custom properties into `props`.\n\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t    var props = {},\n\t        self = this;\n\t    // generates a unique key for these matches\n\t    var o = [];\n\t    // note: active rules excludes non-matching @media rules\n\t    forEachRule(rules, function (rule) {\n\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t      // time to only include ones that have properties\n\t      if (!rule.propertyInfo) {\n\t        self.decorateRule(rule);\n\t      }\n\t      // match element against transformedSelector: selector may contain\n\t      // unwanted uniquification and parsedSelector does not directly match\n\t      // for :host selectors.\n\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t          self.collectProperties(rule, props);\n\t          // produce numeric key for these matches for lookup\n\t          addToBitMask(rule.index, o);\n\t        }\n\t      }\n\t    }, null, true);\n\t    return { properties: props, key: o };\n\t  },\n\t\n\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (!rule.propertyInfo.properties) {\n\t      return;\n\t    }\n\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t    var parsedSelector = rule.parsedSelector;\n\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t    // build info is either in scope (when scope is an element) or in the style\n\t    // when scope is the default scope; note: this allows default scope to have\n\t    // mixed mode built and unbuilt styles.\n\t    if (cssBuild === 'shady') {\n\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t    }\n\t    if (cssBuild === 'shadow') {\n\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t      isHost = isHost && !isRoot;\n\t    }\n\t    if (!isRoot && !isHost) {\n\t      return;\n\t    }\n\t    var selectorToMatch = hostScope;\n\t    if (isHost) {\n\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t      if (nativeShadow && !rule.transformedSelector) {\n\t        // transform :host into a matchable selector\n\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t      }\n\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t    }\n\t    callback({\n\t      selector: selectorToMatch,\n\t      isHost: isHost,\n\t      isRoot: isRoot\n\t    });\n\t  },\n\t\n\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t    var hostProps = {},\n\t        rootProps = {},\n\t        self = this;\n\t    // note: active rules excludes non-matching @media rules\n\t    var cssBuild = rules && rules.__cssBuild;\n\t    forEachRule(rules, function (rule) {\n\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t        var element = scope._element || scope;\n\t        if (matchesSelector.call(element, info.selector)) {\n\t          if (info.isHost) {\n\t            self.collectProperties(rule, hostProps);\n\t          } else {\n\t            self.collectProperties(rule, rootProps);\n\t          }\n\t        }\n\t      });\n\t    }, null, true);\n\t    return { rootProps: rootProps, hostProps: hostProps };\n\t  },\n\t\n\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t    var self = this;\n\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t    var rules = StyleInfo.get(element).styleRules;\n\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t      self.applyProperties(rule, properties);\n\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t        // is not necessary to apply them in ShadowDOM.\n\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t      }\n\t    });\n\t  },\n\t\n\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t    var keyframesRules = rules._keyframes;\n\t    var keyframeTransforms = {};\n\t    if (!nativeShadow && keyframesRules) {\n\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t      // advance for the current scope. This allows us to catch keyframes\n\t      // rules that appear anywhere in the stylesheet:\n\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t      }\n\t    }\n\t    return keyframeTransforms;\n\t  },\n\t\n\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t  // particular scoped keyframes rule.\n\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t    return function (cssText) {\n\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t    };\n\t  },\n\t\n\t  // Transforms `@keyframes` names to be unique for the current host.\n\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t  },\n\t\n\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t  // have low specificity. They are overrideable by class selectors but,\n\t  // unfortunately, not by type selectors (e.g. overriding via\n\t  // `.special` is ok, but not by `x-foo`).\n\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    var selector = rule.transformedSelector;\n\t    var scope = '.' + scopeId;\n\t    var parts = selector.split(',');\n\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t    }\n\t    rule.selector = parts.join(',');\n\t  },\n\t\n\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t    var c = element.getAttribute('class') || '';\n\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t    if (c !== v) {\n\t      element.setAttribute('class', v);\n\t    }\n\t  },\n\t\n\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t    // calculate cssText to apply\n\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t    // if shady and we have a cached style that is not style, decrement\n\t    var styleInfo = StyleInfo.get(element);\n\t    var s = styleInfo.customStyle;\n\t    if (s && !nativeShadow && s !== style) {\n\t      s._useCount--;\n\t      if (s._useCount <= 0 && s.parentNode) {\n\t        s.parentNode.removeChild(s);\n\t      }\n\t    }\n\t    // apply styling always under native or if we generated style\n\t    // or the cached style is not in document(!)\n\t    if (nativeShadow) {\n\t      // update existing style only under native\n\t      if (styleInfo.customStyle) {\n\t        styleInfo.customStyle.textContent = cssText;\n\t        style = styleInfo.customStyle;\n\t        // otherwise, if we have css to apply, do so\n\t      } else if (cssText) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t      }\n\t    } else {\n\t      // shady and no cache hit\n\t      if (!style) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        if (cssText) {\n\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t        }\n\t        // shady and cache hit but not in document\n\t      } else if (!style.parentNode) {\n\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t      }\n\t    }\n\t    // ensure this style is our custom style and increment its use count.\n\t    if (style) {\n\t      style._useCount = style._useCount || 0;\n\t      // increment use count if we changed styles\n\t      if (styleInfo.customStyle != style) {\n\t        style._useCount++;\n\t      }\n\t      styleInfo.customStyle = style;\n\t    }\n\t    // @media rules may be stale in IE 10 and 11\n\t    if (IS_IE) {\n\t      style.textContent = style.textContent;\n\t    }\n\t    return style;\n\t  },\n\t\n\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t    var rules = rulesForStyle(style);\n\t    var self = this;\n\t    style.textContent = toCssText(rules, function (rule) {\n\t      var css = rule.cssText = rule.parsedCssText;\n\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t        // remove property assignments\n\t        // so next function isn't confused\n\t        // NOTE: we have 3 categories of css:\n\t        // (1) normal properties,\n\t        // (2) custom property assignments (--foo: red;),\n\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t        // are not and this makes this case unique.\n\t        css = removeCustomPropAssignment(css);\n\t        // replace with reified properties, scenario is same as mixin\n\t        rule.cssText = self.valueForProperties(css, properties);\n\t      }\n\t    });\n\t  },\n\t\n\t  rx: rx,\n\t  XSCOPE_NAME: 'x-scope'\n\t};\n\t\n\tfunction addToBitMask(n, bits) {\n\t  var o = parseInt(n / 32);\n\t  var v = 1 << n % 32;\n\t  bits[o] = (bits[o] || 0) | v;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar templateMap = {};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar placeholderMap = {};\n\t\n\tvar ce = window.customElements;\n\tif (ce && !nativeShadow) {\n\t  (function () {\n\t    var origDefine = ce.define;\n\t    ce.define = function (name, clazz, options) {\n\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t      return origDefine.call(ce, name, clazz, options);\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\tvar StyleCache = function () {\n\t  function StyleCache() {\n\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t    classCallCheck(this, StyleCache);\n\t\n\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t    this.cache = {};\n\t    this.typeMax = typeMax;\n\t  }\n\t\n\t  createClass(StyleCache, [{\n\t    key: '_validate',\n\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t        var pn = ownPropertyNames[idx];\n\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'store',\n\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t      var list = this.cache[tagname] || [];\n\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t      if (list.length > this.typeMax) {\n\t        list.shift();\n\t      }\n\t      this.cache[tagname] = list;\n\t    }\n\t  }, {\n\t    key: 'fetch',\n\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t      var list = this.cache[tagname];\n\t      if (!list) {\n\t        return;\n\t      }\n\t      // reverse list for most-recent lookups\n\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t        var entry = list[idx];\n\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t          return entry;\n\t        }\n\t      }\n\t    }\n\t  }]);\n\t  return StyleCache;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/**\n\t * The apply shim simulates the behavior of `@apply` proposed at\n\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t * The approach is to convert a property like this:\n\t *\n\t *    --foo: {color: red; background: blue;}\n\t *\n\t * to this:\n\t *\n\t *    --foo_-_color: red;\n\t *    --foo_-_background: blue;\n\t *\n\t * Then where `@apply --foo` is used, that is converted to:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background);\n\t *\n\t * This approach generally works but there are some issues and limitations.\n\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t * another element sets it to:\n\t *\n\t *    --foo: { border: 2px solid red; }\n\t *\n\t * We must now ensure that the color and background from the previous setting\n\t * do not apply. This is accomplished by changing the property set to this:\n\t *\n\t *    --foo_-_border: 2px solid red;\n\t *    --foo_-_color: initial;\n\t *    --foo_-_background: initial;\n\t *\n\t * This works but introduces one new issue.\n\t * Consider this setup at the point where the `@apply` is used:\n\t *\n\t *    background: orange;\n\t *    @apply --foo;\n\t *\n\t * In this case the background will be unset (initial) rather than the desired\n\t * `orange`. We address this by altering the property set to use a fallback\n\t * value like this:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background, orange);\n\t *    border: var(--foo_-_border);\n\t *\n\t * Note that the default is retained in the property set and the `background` is\n\t * the desired `orange`. This leads us to a limitation.\n\t *\n\t * Limitation 1:\n\t\n\t * Only properties in the rule where the `@apply`\n\t * is used are considered as default values.\n\t * If another rule matches the element and sets `background` with\n\t * less specificity than the rule in which `@apply` appears,\n\t * the `background` will not be set.\n\t *\n\t * Limitation 2:\n\t *\n\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t * `@apply` properties.\n\t\n\t*/\n\t\n\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\n\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\n\t// separator used between mixin-name and mixin-property-name when producing properties\n\t// NOTE: plain '-' may cause collisions in user styles\n\tvar MIXIN_VAR_SEP = '_-_';\n\t\n\t// map of mixin to property names\n\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\n\tvar MixinMap = function () {\n\t  function MixinMap() {\n\t    classCallCheck(this, MixinMap);\n\t\n\t    this._map = {};\n\t  }\n\t\n\t  createClass(MixinMap, [{\n\t    key: 'set',\n\t    value: function set(name, props) {\n\t      name = name.trim();\n\t      this._map[name] = {\n\t        properties: props,\n\t        dependants: {}\n\t      };\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get(name) {\n\t      name = name.trim();\n\t      return this._map[name];\n\t    }\n\t  }]);\n\t  return MixinMap;\n\t}();\n\t\n\tvar ApplyShim = function () {\n\t  function ApplyShim() {\n\t    var _this = this;\n\t\n\t    classCallCheck(this, ApplyShim);\n\t\n\t    this._currentTemplate = null;\n\t    this._measureElement = null;\n\t    this._map = new MixinMap();\n\t    this._separator = MIXIN_VAR_SEP;\n\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t    };\n\t  }\n\t\n\t  createClass(ApplyShim, [{\n\t    key: 'transformStyle',\n\t    value: function transformStyle(style, elementName) {\n\t      var ast = rulesForStyle(style);\n\t      this.transformRules(ast, elementName);\n\t      return ast;\n\t    }\n\t  }, {\n\t    key: 'transformRules',\n\t    value: function transformRules(rules, elementName) {\n\t      var _this2 = this;\n\t\n\t      this._currentTemplate = templateMap[elementName];\n\t      forEachRule(rules, function (r) {\n\t        _this2.transformRule(r);\n\t      });\n\t      if (this._currentTemplate) {\n\t        this._currentTemplate.__applyShimInvalid = false;\n\t      }\n\t      this._currentTemplate = null;\n\t    }\n\t  }, {\n\t    key: 'transformRule',\n\t    value: function transformRule(rule) {\n\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t      // :root was only used for variable assignment in property shim,\n\t      // but generates invalid selectors with real properties.\n\t      // replace with `:host > *`, which serves the same effect\n\t      if (rule.selector === ':root') {\n\t        rule.selector = ':host > *';\n\t      }\n\t    }\n\t  }, {\n\t    key: 'transformCssText',\n\t    value: function transformCssText(cssText) {\n\t      // produce variables\n\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t      // consume mixins\n\t      return this._consumeCssProperties(cssText);\n\t    }\n\t  }, {\n\t    key: '_getInitialValueForProperty',\n\t    value: function _getInitialValueForProperty(property) {\n\t      if (!this._measureElement) {\n\t        this._measureElement = document.createElement('meta');\n\t        this._measureElement.style.all = 'initial';\n\t        document.head.appendChild(this._measureElement);\n\t      }\n\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t    }\n\t    // replace mixin consumption with variable consumption\n\t\n\t  }, {\n\t    key: '_consumeCssProperties',\n\t    value: function _consumeCssProperties(text) {\n\t      var m = void 0;\n\t      // loop over text until all mixins with defintions have been applied\n\t      while (m = MIXIN_MATCH.exec(text)) {\n\t        var matchText = m[0];\n\t        var mixinName = m[1];\n\t        var idx = m.index;\n\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t        var applyPos = idx + matchText.indexOf('@apply');\n\t        var afterApplyPos = idx + matchText.length;\n\t        // find props defined before this @apply\n\t        var textBeforeApply = text.slice(0, applyPos);\n\t        var textAfterApply = text.slice(afterApplyPos);\n\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t        // use regex match position to replace mixin, keep linear processing time\n\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t        // move regex search to _after_ replacement\n\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t      }\n\t      return text;\n\t    }\n\t    // produce variable consumption at the site of mixin consumption\n\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t    // Example:\n\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\n\t  }, {\n\t    key: '_atApplyToCssProperties',\n\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t      var vars = [];\n\t      var mixinEntry = this._map.get(mixinName);\n\t      // if we depend on a mixin before it is created\n\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t      if (!mixinEntry) {\n\t        this._map.set(mixinName, {});\n\t        mixinEntry = this._map.get(mixinName);\n\t      }\n\t      if (mixinEntry) {\n\t        if (this._currentTemplate) {\n\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t        }\n\t        var p = void 0,\n\t            parts = void 0,\n\t            f = void 0;\n\t        for (p in mixinEntry.properties) {\n\t          f = fallbacks && fallbacks[p];\n\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t          if (f) {\n\t            parts.push(',', f);\n\t          }\n\t          parts.push(')');\n\t          vars.push(parts.join(''));\n\t        }\n\t      }\n\t      return vars.join('; ');\n\t    }\n\t  }, {\n\t    key: '_replaceInitialOrInherit',\n\t    value: function _replaceInitialOrInherit(property, value) {\n\t      var match = INITIAL_INHERIT.exec(value);\n\t      if (match) {\n\t        if (match[1]) {\n\t          // initial\n\t          // replace `initial` with the concrete initial value for this property\n\t          value = ApplyShim._getInitialValueForProperty(property);\n\t        } else {\n\t          // inherit\n\t          // with this purposfully illegal value, the variable will be invalid at\n\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t          // and for inheriting values, will behave similarly\n\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t          value = 'apply-shim-inherit';\n\t        }\n\t      }\n\t      return value;\n\t    }\n\t\n\t    // \"parse\" a mixin definition into a map of properties and values\n\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\n\t  }, {\n\t    key: '_cssTextToMap',\n\t    value: function _cssTextToMap(text) {\n\t      var props = text.split(';');\n\t      var property = void 0,\n\t          value = void 0;\n\t      var out = {};\n\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t        p = props[i];\n\t        if (p) {\n\t          sp = p.split(':');\n\t          // ignore lines that aren't definitions like @media\n\t          if (sp.length > 1) {\n\t            property = sp[0].trim();\n\t            // some properties may have ':' in the value, like data urls\n\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t            out[property] = value;\n\t          }\n\t        }\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_invalidateMixinEntry',\n\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t      for (var elementName in mixinEntry.dependants) {\n\t        if (elementName !== this._currentTemplate) {\n\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_produceCssProperties',\n\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t      var _this3 = this;\n\t\n\t      // handle case where property value is a mixin\n\t      if (valueProperty) {\n\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t          if (value && _this3._map.get(value)) {\n\t            valueMixin = '@apply ' + value + ';';\n\t          }\n\t        });\n\t      }\n\t      if (!valueMixin) {\n\t        return matchText;\n\t      }\n\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t      var combinedProps = mixinValues;\n\t      var mixinEntry = this._map.get(propertyName);\n\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t      if (oldProps) {\n\t        // NOTE: since we use mixin, the map of properties is updated here\n\t        // and this is what we want.\n\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t      } else {\n\t        this._map.set(propertyName, combinedProps);\n\t      }\n\t      var out = [];\n\t      var p = void 0,\n\t          v = void 0;\n\t      // set variables defined by current mixin\n\t      var needToInvalidate = false;\n\t      for (p in combinedProps) {\n\t        v = mixinValues[p];\n\t        // if property not defined by current mixin, set initial\n\t        if (v === undefined) {\n\t          v = 'initial';\n\t        }\n\t        if (oldProps && !(p in oldProps)) {\n\t          needToInvalidate = true;\n\t        }\n\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t      }\n\t      if (needToInvalidate) {\n\t        this._invalidateMixinEntry(mixinEntry);\n\t      }\n\t      if (mixinEntry) {\n\t        mixinEntry.properties = combinedProps;\n\t      }\n\t      // because the mixinMap is global, the mixin might conflict with\n\t      // a different scope's simple variable definition:\n\t      // Example:\n\t      // some style somewhere:\n\t      // --mixin1:{ ... }\n\t      // --mixin2: var(--mixin1);\n\t      // some other element:\n\t      // --mixin1: 10px solid red;\n\t      // --foo: var(--mixin1);\n\t      // In this case, we leave the original variable definition in place.\n\t      if (valueProperty) {\n\t        prefix = matchText + ';' + prefix;\n\t      }\n\t      return prefix + out.join('; ') + ';';\n\t    }\n\t  }]);\n\t  return ApplyShim;\n\t}();\n\t\n\tvar applyShim = new ApplyShim();\n\twindow['ApplyShim'] = applyShim;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar flush = function flush() {};\n\t\n\tif (!nativeShadow) {\n\t  (function () {\n\t    var handler = function handler(mxns) {\n\t      for (var x = 0; x < mxns.length; x++) {\n\t        var mxn = mxns[x];\n\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t          var n = mxn.addedNodes[i];\n\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t            var root = n.getRootNode();\n\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t              // may no longer be in a shadowroot\n\t              var host = root.host;\n\t              if (host) {\n\t                var scope = host.is || host.localName;\n\t                StyleTransformer.dom(n, scope);\n\t              }\n\t            }\n\t          }\n\t        }\n\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t          var _n = mxn.removedNodes[_i];\n\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t            if (classIdx >= 0) {\n\t              // NOTE: relies on the scoping class always being adjacent to the\n\t              // SCOPE_NAME class.\n\t              var _scope = _n.classList[classIdx + 1];\n\t              if (_scope) {\n\t                StyleTransformer.dom(_n, _scope, true);\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var observer = new MutationObserver(handler);\n\t    var startState = 'interactive';\n\t\n\t    var start = function start() {\n\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t    };\n\t    if (window.HTMLImports) {\n\t      window.HTMLImports.whenReady(start);\n\t    } else if (document.readyState === startState) {\n\t      requestAnimationFrame(start);\n\t    } else {\n\t      document.addEventListener('readystatechange', function () {\n\t        if (document.readyState === startState) {\n\t          start();\n\t        }\n\t      });\n\t    }\n\t\n\t    flush = function flush() {\n\t      handler(observer.takeRecords());\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(dfreedm): consider spliting into separate global\n\tvar styleCache = new StyleCache();\n\t\n\tvar ShadyCSS = {\n\t  flush: flush,\n\t  scopeCounter: {},\n\t  nativeShadow: nativeShadow,\n\t  nativeCss: nativeCssVariables,\n\t  nativeCssApply: nativeCssApply,\n\t  _documentOwner: document.documentElement,\n\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t    return name + '-' + id;\n\t  },\n\t  getStyleAst: function getStyleAst(style) {\n\t    return rulesForStyle(style);\n\t  },\n\t  styleAstToString: function styleAstToString(ast) {\n\t    return toCssText(ast);\n\t  },\n\t  _gatherStyles: function _gatherStyles(template) {\n\t    var styles = template.content.querySelectorAll('style');\n\t    var cssText = [];\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var s = styles[i];\n\t      cssText.push(s.textContent);\n\t      s.parentNode.removeChild(s);\n\t    }\n\t    return cssText.join('').trim();\n\t  },\n\t  _getCssBuild: function _getCssBuild(template) {\n\t    var style = template.content.querySelector('style');\n\t    if (!style) {\n\t      return '';\n\t    }\n\t    return style.getAttribute('css-build') || '';\n\t  },\n\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t    if (template._prepared) {\n\t      return;\n\t    }\n\t    template._prepared = true;\n\t    template.name = elementName;\n\t    template.extends = typeExtension;\n\t    templateMap[elementName] = template;\n\t    var cssBuild = this._getCssBuild(template);\n\t    var cssText = this._gatherStyles(template);\n\t    var info = {\n\t      is: elementName,\n\t      extends: typeExtension,\n\t      __cssBuild: cssBuild\n\t    };\n\t    if (!this.nativeShadow) {\n\t      StyleTransformer.dom(template.content, elementName);\n\t    }\n\t    var ast = parse(cssText);\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      applyShim.transformRules(ast, elementName);\n\t    }\n\t    template._styleAst = ast;\n\t\n\t    var ownPropertyNames = [];\n\t    if (!this.nativeCss) {\n\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t    }\n\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t      var root = this.nativeShadow ? template.content : null;\n\t      var placeholder = placeholderMap[elementName];\n\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t      template._style = style;\n\t    }\n\t    template._ownPropertyNames = ownPropertyNames;\n\t  },\n\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t    if (cssText.length) {\n\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t    }\n\t  },\n\t  _prepareHost: function _prepareHost(host) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var typeExtension = void 0;\n\t    if (is !== host.localName) {\n\t      typeExtension = host.localName;\n\t    }\n\t    var placeholder = placeholderMap[is];\n\t    var template = templateMap[is];\n\t    var ast = void 0;\n\t    var ownStylePropertyNames = void 0;\n\t    var cssBuild = void 0;\n\t    if (template) {\n\t      ast = template._styleAst;\n\t      ownStylePropertyNames = template._ownPropertyNames;\n\t      cssBuild = template._cssBuild;\n\t    }\n\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t  },\n\t  applyStyle: function applyStyle(host, overrideProps) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    if (window.CustomStyle) {\n\t      var CS = window.CustomStyle;\n\t      if (CS._documentDirty) {\n\t        CS.findStyles();\n\t        if (!this.nativeCss) {\n\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t        } else if (!this.nativeCssApply) {\n\t          CS._revalidateApplyShim();\n\t        }\n\t        CS.applyStyles();\n\t        CS._documentDirty = false;\n\t      }\n\t    }\n\t    var styleInfo = StyleInfo.get(host);\n\t    if (!styleInfo) {\n\t      styleInfo = this._prepareHost(host);\n\t    }\n\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t    if (this.nativeCss) {\n\t      var template = templateMap[is];\n\t      if (template && template.__applyShimInvalid && template._style) {\n\t        // update template\n\t        applyShim.transformRules(template._styleAst, is);\n\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        // update instance if native shadowdom\n\t        if (this.nativeShadow) {\n\t          var style = host.shadowRoot.querySelector('style');\n\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        }\n\t        styleInfo.styleRules = template._styleAst;\n\t      }\n\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t    } else {\n\t      this._updateProperties(host, styleInfo);\n\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t        // TODO: use caching\n\t        this._applyStyleProperties(host, styleInfo);\n\t      }\n\t    }\n\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t    // note: some elements may not have a root!\n\t    if (root) {\n\t      this._applyToDescendants(root);\n\t    }\n\t  },\n\t  _applyToDescendants: function _applyToDescendants(root) {\n\t    var c$ = root.children;\n\t    for (var i = 0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (c.shadowRoot) {\n\t        this.applyStyle(c);\n\t      }\n\t      this._applyToDescendants(c);\n\t    }\n\t  },\n\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t    var root = node.getRootNode();\n\t    var host = root.host;\n\t    if (host) {\n\t      if (StyleInfo.get(host)) {\n\t        return host;\n\t      } else {\n\t        return this._styleOwnerForNode(host);\n\t      }\n\t    }\n\t    return this._documentOwner;\n\t  },\n\t  _isRootOwner: function _isRootOwner(node) {\n\t    return node === this._documentOwner;\n\t  },\n\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t    // only generate new scope if cached style is not found\n\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t    if (!this.nativeShadow) {\n\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t    }\n\t    if (!cacheEntry) {\n\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t    }\n\t    return style;\n\t  },\n\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t    var owner = this._styleOwnerForNode(host);\n\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t    var props = Object.create(ownerProperties || null);\n\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t    var propertiesMatchingHost = propertyData.properties;\n\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t    StyleProperties.reify(props);\n\t    styleInfo.styleProperties = props;\n\t  },\n\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t    for (var p in overrides) {\n\t      var v = overrides[p];\n\t      // skip override props if they are not truthy or 0\n\t      // in order to fall back to inherited values\n\t      if (v || v === 0) {\n\t        props[p] = v;\n\t      }\n\t    }\n\t  },\n\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t    // remove previous properties\n\t    for (var p in properties) {\n\t      // NOTE: for bc with shim, don't apply null values.\n\t      if (p === null) {\n\t        element.style.removeProperty(p);\n\t      } else {\n\t        element.style.setProperty(p, properties[p]);\n\t      }\n\t    }\n\t  },\n\t  updateStyles: function updateStyles(properties) {\n\t    if (window.CustomStyle) {\n\t      window.CustomStyle._documentDirty = true;\n\t    }\n\t    this.applyStyle(this._documentOwner, properties);\n\t  },\n\t\n\t  /* Custom Style operations */\n\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t    var _this = this;\n\t\n\t    var ast = rulesForStyle(style);\n\t    forEachRule(ast, function (rule) {\n\t      if (nativeShadow) {\n\t        StyleTransformer.normalizeRootSelector(rule);\n\t      } else {\n\t        StyleTransformer.documentRule(rule);\n\t      }\n\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t        applyShim.transformRule(rule);\n\t      }\n\t    });\n\t    if (this.nativeCss) {\n\t      style.textContent = toCssText(ast);\n\t    } else {\n\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t    }\n\t  },\n\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      var ast = rulesForStyle(style);\n\t      applyShim.transformRules(ast);\n\t      style.textContent = toCssText(ast);\n\t    }\n\t  },\n\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t    if (!this.nativeCss) {\n\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t    }\n\t  },\n\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t    var value = void 0;\n\t    if (!this.nativeCss) {\n\t      // element is either a style host, or an ancestor of a style host\n\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t      value = styleInfo.styleProperties[property];\n\t    }\n\t    // fall back to the property value from the computed styling\n\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t    // trim whitespace that can come after the `:` in css\n\t    // example: padding: 2px -> \" 2px\"\n\t    return value.trim();\n\t  },\n\t\n\t  // given an element and a classString, replaces\n\t  // the element's class with the provided classString and adds\n\t  // any necessary ShadyCSS static and property based scoping selectors\n\t  // NOTE: this method is suitable to be called in an environment in which\n\t  // setAttribute('class', ...) and className setter have been overridden so\n\t  // it cannot rely on those methods.\n\t  setElementClass: function setElementClass(element, classString) {\n\t    var _element$classList;\n\t\n\t    // use classList to clear existing classes\n\t    while (element.classList.length) {\n\t      element.classList.remove(element.classList[0]);\n\t    }\n\t    // add user classString\n\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t    // add static scoping: scope by shadyRoot\n\t    var root = element.getRootNode();\n\t    if (root.host) {\n\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t    }\n\t    // add property scoping: scope by special selector\n\t    if (!this.nativeCss) {\n\t      var styleInfo = StyleInfo.get(element);\n\t      if (styleInfo && styleInfo.scopeSelector) {\n\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t      }\n\t    }\n\t  },\n\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t    return StyleInfo.get(node);\n\t  }\n\t};\n\t\n\twindow['ShadyCSS'] = ShadyCSS;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\n\tExample:\n\t<shady-style>\n\t  <style>\n\t  ...\n\t  </style>\n\t</shady-style>\n\t*/\n\t\n\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\n\tvar enqueued = false;\n\t\n\tvar customStyles = [];\n\t\n\tvar hookFn = null;\n\t\n\t/*\n\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\tas all the instances will boot asynchronously after page load.\n\t\n\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t*/\n\tfunction enqueueDocumentValidation() {\n\t  if (enqueued) {\n\t    return;\n\t  }\n\t  enqueued = true;\n\t  if (window.HTMLImports) {\n\t    window.HTMLImports.whenReady(validateDocument);\n\t  } else if (document.readyState === 'complete') {\n\t    requestAnimationFrame(validateDocument);\n\t  } else {\n\t    document.addEventListener('readystatechange', function () {\n\t      if (document.readyState === 'complete') {\n\t        validateDocument();\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t// helps ensure that the first run of validateDocument will actually\n\t// have access to all the custom-style's created via loading imports.\n\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t// then the enqueue immediately calls validateDocument and work that could be\n\t// batched is not.\n\tenqueueDocumentValidation();\n\t\n\tfunction validateDocument() {\n\t  if (enqueued) {\n\t    ShadyCSS$1.updateStyles();\n\t    enqueued = false;\n\t  }\n\t}\n\t\n\tfunction CustomStyle() {\n\t  /*\n\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t  CustomElement polyfill replacement that can be `.call`ed\n\t  */\n\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t  customStyles.push(self);\n\t  enqueueDocumentValidation();\n\t  return self;\n\t}\n\t\n\tObject.defineProperties(CustomStyle, {\n\t  /*\n\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t   The function must take a <style> element as input, and return nothing.\n\t  */\n\t  processHook: {\n\t    get: function get() {\n\t      return hookFn;\n\t    },\n\t    set: function set(fn) {\n\t      hookFn = fn;\n\t      return fn;\n\t    }\n\t  },\n\t  _customStyles: {\n\t    get: function get() {\n\t      return customStyles;\n\t    }\n\t  },\n\t  _documentDirty: {\n\t    get: function get() {\n\t      return enqueued;\n\t    },\n\t    set: function set(value) {\n\t      enqueued = value;\n\t      return value;\n\t    }\n\t  }\n\t});\n\t\n\tCustomStyle.findStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._findStyle();\n\t  }\n\t};\n\t\n\tCustomStyle._revalidateApplyShim = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    var s = customStyles[i];\n\t    if (s._style) {\n\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t    }\n\t  }\n\t};\n\t\n\tCustomStyle.applyStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._applyStyle();\n\t  }\n\t};\n\t\n\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t  'constructor': {\n\t    value: CustomStyle,\n\t    configurable: true,\n\t    writable: true\n\t  }\n\t});\n\t\n\tCustomStyle.prototype._findStyle = function () {\n\t  if (!this._style) {\n\t    var style = this.querySelector('style');\n\t    if (!style) {\n\t      return;\n\t    }\n\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t    // which is referenced with __appliedElement.\n\t    // Also, we must copy over the attributes.\n\t    if (style.__appliedElement) {\n\t      for (var i = 0; i < style.attributes.length; i++) {\n\t        var attr = style.attributes[i];\n\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t      }\n\t    }\n\t    this._style = style.__appliedElement || style;\n\t    if (hookFn) {\n\t      hookFn(this._style);\n\t    }\n\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t  }\n\t};\n\t\n\tCustomStyle.prototype._applyStyle = function () {\n\t  if (this._style) {\n\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t  }\n\t};\n\t\n\twindow.customElements.define('custom-style', CustomStyle);\n\twindow['CustomStyle'] = CustomStyle;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/*\n\tSmall module to load ShadyCSS and CustomStyle together\n\t*/\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadycss.min.js.map\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs-web-components/dist/index.js\n// module id = 1\n// module chunks = 0 1","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('incremental-dom'), require('window-or-global')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n}(this, (function (exports,incrementalDom,root) {\n\nroot = 'default' in root ? root['default'] : root;\n\nfunction keys() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref$enumOnly = _ref.enumOnly;\n  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\n  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n}\n\n// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\nvar assign = (function (obj) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  args.forEach(function (arg) {\n    return keys(arg).forEach(function (name) {\n      return obj[name] = arg[name];\n    });\n  }); // eslint-disable-line no-return-assign\n  return obj;\n});\n\nvar empty = function (val) {\n  return typeof val === 'undefined' || val === null;\n};\n\nvar alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {\n  return isNaN(val) ? undefined : Number(val);\n};\nvar alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n  return empty(val) ? undefined : String(val);\n};\n\nfunction create(def) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.unshift({}, def);\n    return assign.apply(undefined, args);\n  };\n}\n\nvar array = create({\n  coerce: function coerce(val) {\n    return Array.isArray(val) ? val : [val];\n  },\n  default: function _default() {\n    return [];\n  },\n  deserialize: JSON.parse,\n  serialize: JSON.stringify\n});\n\nvar boolean = create({\n  coerce: function coerce(value) {\n    return !!value;\n  },\n  default: false,\n  deserialize: function deserialize(value) {\n    return !(value === null);\n  },\n  serialize: function serialize(value) {\n    return value ? '' : undefined;\n  }\n});\n\nvar number = create({\n  default: 0,\n  coerce: alwaysUndefinedIfNotANumberOrNumber,\n  deserialize: alwaysUndefinedIfNotANumberOrNumber,\n  serialize: alwaysUndefinedIfNotANumberOrNumber\n});\n\nvar string = create({\n  default: '',\n  coerce: alwaysUndefinedIfEmptyOrString,\n  deserialize: alwaysUndefinedIfEmptyOrString,\n  serialize: alwaysUndefinedIfEmptyOrString\n});\n\nvar prop = Object.freeze({\n\tcreate: create,\n\tarray: array,\n\tboolean: boolean,\n\tnumber: number,\n\tstring: string\n});\n\nvar connected = '____skate_connected';\nvar created$1 = '____skate_created';\n\n// DEPRECATED\n//\n// This is the only \"symbol\" that must stay a string. This is because it is\n// relied upon across several versions. We should remove it, but ensure that\n// it's considered a breaking change that whatever version removes it cannot\n// be passed to vdom functions as tag names.\nvar name = '____skate_name';\n\n// Used on the Constructor\nvar ctorCreateInitProps = '____skate_ctor_createInitProps';\nvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\nvar ctorProps = '____skate_ctor_props';\nvar ctorPropsMap = '____skate_ctor_propsMap';\n\n// Used on the Element\nvar props = '____skate_props';\nvar ref$1 = '____skate_ref';\nvar renderer$1 = '____skate_renderer';\nvar rendering = '____skate_rendering';\nvar rendererDebounced = '____skate_rendererDebounced';\nvar updated$1 = '____skate_updated';\n\n// DEPRECTAED\n//\n// We should not be relying on internals for symbols as this creates version\n// coupling. We will move forward with platform agnostic ways of doing this.\n\n\nvar symbols$1 = Object.freeze({\n\tname: name\n});\n\nfunction enter(object, props) {\n  var saved = {};\n  Object.keys(props).forEach(function (key) {\n    saved[key] = object[key];\n    object[key] = props[key];\n  });\n  return saved;\n}\n\nfunction exit(object, saved) {\n  assign(object, saved);\n}\n\n// Decorates a function with a side effect that changes the properties of an\n// object during its execution, and restores them after. There is no error\n// handling here, if the wrapped function throws an error, properties are not\n// restored and all bets are off.\nvar propContext = function (object, props) {\n  return function (func) {\n    return function () {\n      var saved = enter(object, props);\n      var result = func.apply(undefined, arguments);\n      exit(object, saved);\n      return result;\n    };\n  };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/* eslint no-plusplus: 0 */\n\nvar customElements = root.customElements;\nvar HTMLElement = root.HTMLElement;\n\nvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\n// A stack of children that corresponds to the current function helper being\n// executed.\nvar stackChren = [];\n\nvar $skip = '__skip';\nvar $currentEventHandlers = '__events';\nvar $stackCurrentHelperProps = '__props';\n\n// The current function helper in the stack.\nvar stackCurrentHelper = void 0;\n\n// This is used for the Incremental DOM overrides to keep track of what args\n// to pass the main elementOpen() function.\nvar overrideArgs = void 0;\n\n// The number of levels deep after skipping a tree.\nvar skips = 0;\n\nvar noop = function noop() {};\n\n// Adds or removes an event listener for an element.\nfunction applyEvent(elem, ename, newFunc) {\n  var events = elem[$currentEventHandlers];\n\n  if (!events) {\n    events = elem[$currentEventHandlers] = {};\n  }\n\n  // Undefined indicates that there is no listener yet.\n  if (typeof events[ename] === 'undefined') {\n    // We only add a single listener once. Originally this was a workaround for\n    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n    // also a simpler model for binding / unbinding events because you only\n    // have a single handler you need to worry about and a single place where\n    // you only store one event handler\n    elem.addEventListener(ename, function (e) {\n      if (events[ename]) {\n        events[ename].call(this, e);\n      }\n    });\n  }\n\n  // Not undefined indicates that we have set a listener, so default to null.\n  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n}\n\nvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n  // Attributes that shouldn't be applied to the DOM.\n  key: noop,\n  statics: noop,\n\n  // Attributes that *must* be set via a property on all elements.\n  checked: incrementalDom.applyProp,\n  className: incrementalDom.applyProp,\n  disabled: incrementalDom.applyProp,\n  value: incrementalDom.applyProp,\n\n  // Ref handler.\n  ref: function ref(elem, name$$1, value) {\n    elem[ref$1] = value;\n  },\n\n\n  // Skip handler.\n  skip: function skip(elem, name$$1, value) {\n    if (value) {\n      elem[$skip] = true;\n    } else {\n      delete elem[$skip];\n    }\n  }\n}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n  var _ref = customElements.get(elem.localName) || {\n    props: {},\n    prototype: {}\n  };\n\n  var props$$1 = _ref.props;\n  var prototype = _ref.prototype;\n\n  // TODO when refactoring properties to not have to workaround the old\n  // WebKit bug we can remove the \"name in props\" check below.\n  //\n  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n  // elements that set a property that isn't explicitly specified in \"props\"\n  // or \"prototype\" unless it is added to the element explicitly as a\n  // property prior to passing the prop to the vdom function. For example, if\n  // it were added in a lifecycle callback because it wouldn't have been\n  // upgraded yet.\n  //\n  // We prefer setting props, so we do this if there's a property matching\n  // name that was passed. However, certain props on SVG elements are\n  // readonly and error when you try to set them.\n\n  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n    incrementalDom.applyProp(elem, name$$1, value);\n    return;\n  }\n\n  // Explicit false removes the attribute.\n  if (value === false) {\n    applyDefault(elem, name$$1);\n    return;\n  }\n\n  // Handle built-in and custom events.\n  if (name$$1.indexOf('on') === 0) {\n    var firstChar = name$$1[2];\n    var eventName = void 0;\n\n    if (firstChar === '-') {\n      eventName = name$$1.substring(3);\n    } else if (firstChar === firstChar.toUpperCase()) {\n      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n    }\n\n    if (eventName) {\n      applyEvent(elem, eventName, value);\n      return;\n    }\n  }\n\n  applyDefault(elem, name$$1, value);\n}));\n\nfunction resolveTagName(name$$1) {\n  // We return falsy values as some wrapped IDOM functions allow empty values.\n  if (!name$$1) {\n    return name$$1;\n  }\n\n  // We try and return the cached tag name, if one exists.\n  if (name$$1[name]) {\n    return name$$1[name];\n  }\n\n  // If it's a custom element, we get the tag name by constructing it and\n  // caching it.\n  if (name$$1.prototype instanceof HTMLElement) {\n    // eslint-disable-next-line\n    var elem = new name$$1();\n    return name$$1[name] = elem.localName;\n  }\n\n  // Pass all other values through so IDOM gets what it's expecting.\n  return name$$1;\n}\n\n// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n// so it's the only function we need to execute in the context of our attributes.\nvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\nfunction elementOpenStart(tag) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  overrideArgs = [tag, key, statics];\n}\n\nfunction elementOpenEnd() {\n  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n  overrideArgs = null;\n  return node;\n}\n\nfunction wrapIdomFunc(func) {\n  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n  return function wrap() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args[0] = resolveTagName(args[0]);\n    stackCurrentHelper = null;\n    if (typeof args[0] === 'function') {\n      // If we've encountered a function, handle it according to the type of\n      // function that is being wrapped.\n      stackCurrentHelper = args[0];\n      return tnameFuncHandler.apply(undefined, args);\n    } else if (stackChren.length) {\n      // We pass the wrap() function in here so that when it's called as\n      // children, it will queue up for the next stack, if there is one.\n      stackChren[stackChren.length - 1].push([wrap, args]);\n    } else {\n      if (func === elementOpen$1) {\n        if (skips) {\n          return ++skips;\n        }\n\n        var elem = func.apply(undefined, args);\n\n        if (elem[$skip]) {\n          ++skips;\n        }\n\n        return elem;\n      }\n\n      if (func === incrementalDom.elementClose) {\n        if (skips === 1) {\n          incrementalDom.skip();\n        }\n\n        // We only want to skip closing if it's not the last closing tag in the\n        // skipped tree because we keep the element that initiated the skpping.\n        if (skips && --skips) {\n          return;\n        }\n\n        var _elem = func.apply(undefined, args);\n        var ref$$1 = _elem[ref$1];\n\n        // We delete so that it isn't called again for the same element. If the\n        // ref changes, or the element changes, this will be defined again.\n        delete _elem[ref$1];\n\n        // Execute the saved ref after esuring we've cleand up after it.\n        if (typeof ref$$1 === 'function') {\n          ref$$1(_elem);\n        }\n\n        return _elem;\n      }\n\n      // We must call elementOpenStart and elementOpenEnd even if we are\n      // skipping because they queue up attributes and then call elementClose.\n      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n        return func.apply(undefined, args);\n      }\n    }\n  };\n}\n\nfunction newAttr() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (stackCurrentHelper) {\n    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n  } else if (stackChren.length) {\n    stackChren[stackChren.length - 1].push([newAttr, args]);\n  } else {\n    overrideArgs.push(args[0]);\n    overrideArgs.push(args[1]);\n  }\n}\n\nfunction stackOpen(tname, key, statics) {\n  var props$$1 = { key: key, statics: statics };\n\n  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n    attrs[_key3 - 3] = arguments[_key3];\n  }\n\n  for (var a = 0; a < attrs.length; a += 2) {\n    props$$1[attrs[a]] = attrs[a + 1];\n  }\n  tname[$stackCurrentHelperProps] = props$$1;\n  stackChren.push([]);\n}\n\nfunction stackClose(tname) {\n  var chren = stackChren.pop();\n  var props$$1 = tname[$stackCurrentHelperProps];\n  delete tname[$stackCurrentHelperProps];\n  var elemOrFn = tname(props$$1, function () {\n    return chren.forEach(function (args) {\n      return args[0].apply(args, toConsumableArray(args[1]));\n    });\n  });\n  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n}\n\n// Incremental DOM overrides\n// -------------------------\n\n// We must override internal functions that call internal Incremental DOM\n// functions because we can't override the internal references. This means\n// we must roughly re-implement their behaviour. Luckily, they're fairly\n// simple.\nvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\nvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\n// Standard open / closed overrides don't need to reproduce internal behaviour\n// because they are the ones referenced from *End and *Start.\nvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\nvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\n// Ensure we call our overridden functions instead of the internal ones.\nfunction newElementVoid(tag) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  newElementOpen.apply(undefined, [tag].concat(args));\n  return newElementClose(tag);\n}\n\n// Text override ensures their calls can queue if using function helpers.\nvar newText = wrapIdomFunc(incrementalDom.text);\n\n// Convenience function for declaring an Incremental DOM element using\n// hyperscript-style syntax.\nfunction element(tname, attrs) {\n  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\n  // If attributes are a function, then they should be treated as children.\n\n  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n    chren[_key5 - 2] = arguments[_key5];\n  }\n\n  if (atype === 'function' || atype === 'string' || atype === 'number') {\n    chren.unshift(attrs);\n  }\n\n  // Ensure the attributes are an object. Null is considered an object so we\n  // have to test for this explicitly.\n  if (attrs === null || atype !== 'object') {\n    attrs = {};\n  }\n\n  // We open the element so we can set attrs after.\n  newElementOpenStart(tname, attrs.key, attrs.statics);\n\n  // Delete so special attrs don't actually get set.\n  delete attrs.key;\n  delete attrs.statics;\n\n  // Set attributes.\n  Object.keys(attrs).forEach(function (name$$1) {\n    return newAttr(name$$1, attrs[name$$1]);\n  });\n\n  // Close before we render the descendant tree.\n  newElementOpenEnd(tname);\n\n  chren.forEach(function (ch) {\n    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n    if (ctype === 'function') {\n      ch();\n    } else if (ctype === 'string' || ctype === 'number') {\n      newText(ch);\n    } else if (Array.isArray(ch)) {\n      ch.forEach(function (sch) {\n        return sch();\n      });\n    }\n  });\n\n  return newElementClose(tname);\n}\n\n// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n// transpiles for JSX (React.createElement() / h).\nfunction builder() {\n  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    tags[_key6] = arguments[_key6];\n  }\n\n  if (tags.length === 0) {\n    return function () {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return element.bind.apply(element, [null].concat(args));\n    };\n  }\n  return tags.map(function (tag) {\n    return function () {\n      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      return element.bind.apply(element, [null, tag].concat(args));\n    };\n  });\n}\n\n\n\nvar vdom = Object.freeze({\n\telement: element,\n\tbuilder: builder,\n\tattr: newAttr,\n\telementClose: newElementClose,\n\telementOpen: newElementOpen,\n\telementOpenEnd: newElementOpenEnd,\n\telementOpenStart: newElementOpenStart,\n\telementVoid: newElementVoid,\n\ttext: newText\n});\n\nfunction createSymbol(description) {\n  return typeof Symbol === 'function' ? Symbol(description) : description;\n}\n\nvar data = function (element) {\n  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n};\n\nvar dashCase = function (str) {\n  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    return '' + one + dash + two.toLowerCase();\n  });\n};\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\nvar native = (function (fn) {\n  return nativeHints.map(function (hint) {\n    return (fn || '').toString().indexOf([hint]) > -1;\n  }).reduce(function (a, b) {\n    return a || b;\n  });\n});\n\nvar MutationObserver = root.MutationObserver;\n\n\nfunction microtaskDebounce(cbFunc) {\n  var scheduled = false;\n  var i = 0;\n  var cbArgs = [];\n  var elem = document.createElement('span');\n  var observer = new MutationObserver(function () {\n    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n    scheduled = false;\n    cbArgs = null;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = '' + i;\n      i += 1;\n    }\n  };\n}\n\n// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n// polyfill requires that the element be in the document to trigger Mutation\n// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n//\n// The soonest we can set the timeout for in IE is 1 as they have issues when\n// setting to 0.\nfunction taskDebounce(cbFunc) {\n  var scheduled = false;\n  var cbArgs = [];\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n      }, 1);\n    }\n  };\n}\nvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\nvar getOwnPropertyDescriptors = function () {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return keys(obj).reduce(function (prev, curr) {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n};\n\n/**\n * This is needed to avoid IE11 \"stack size errors\" when creating\n * a new property on the constructor of an HTMLElement\n */\nfunction setCtorNativeProperty(Ctor, propName, value) {\n  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n}\n\n/**\n * Returns a cached map of property options for the given component class.\n * Keys in the map are the properties name which can a string or a symbol.\n *\n * The map is created by caching the result of: static get props\n */\nfunction getPropsMap(Ctor) {\n  // Must be defined on constructor and not from a superclass\n  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n    (function () {\n      var props$$1 = Ctor.props || {};\n\n      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n        result[propNameOrSymbol] = props$$1[propNameOrSymbol];\n        return result;\n      }, {});\n      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n    })();\n  }\n\n  return Ctor[ctorPropsMap];\n}\n\nfunction get$2(elem) {\n  var props$$1 = {};\n  keys(getPropsMap(elem.constructor)).forEach(function (key) {\n    props$$1[key] = elem[key];\n  });\n\n  return props$$1;\n}\n\nfunction set$2(elem, newProps) {\n  assign(elem, newProps);\n  if (elem[renderer$1]) {\n    elem[renderer$1]();\n  }\n}\n\nvar props$1 = function (elem, newProps) {\n  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n};\n\nfunction getDefaultValue(elem, name, opts) {\n  return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n}\n\nfunction getInitialValue(elem, name, opts) {\n  return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n}\n\nfunction getPropData(elem, name) {\n  var elemData = data(elem, 'props');\n  return elemData[name] || (elemData[name] = {});\n}\n\nfunction syncFirstTimeProp(elem, prop, propName, attributeName, propData) {\n  var syncAttrValue = propData.lastAssignedValue;\n  if (empty(syncAttrValue)) {\n    if ('initial' in prop) {\n      syncAttrValue = getInitialValue(elem, propName, prop);\n    } else if ('default' in prop) {\n      syncAttrValue = getDefaultValue(elem, propName, prop);\n    }\n  }\n  if (!empty(syncAttrValue) && prop.serialize) {\n    syncAttrValue = prop.serialize(syncAttrValue);\n  }\n  if (!empty(syncAttrValue)) {\n    propData.syncingAttribute = true;\n    elem.setAttribute(attributeName, syncAttrValue);\n  }\n}\n\nfunction syncExistingProp(elem, prop, propName, attributeName, propData) {\n  if (attributeName && !propData.settingAttribute) {\n    var internalValue = propData.internalValue;\n\n    var serializedValue = prop.serialize(internalValue);\n    var currentAttrValue = elem.getAttribute(attributeName);\n    var serializedIsEmpty = empty(serializedValue);\n    var attributeChanged = !(serializedIsEmpty && empty(currentAttrValue) || serializedValue === currentAttrValue);\n\n    propData.syncingAttribute = true;\n\n    var shouldRemoveAttribute = empty(propData.lastAssignedValue);\n    if (shouldRemoveAttribute || serializedIsEmpty) {\n      elem.removeAttribute(attributeName);\n    } else {\n      elem.setAttribute(attributeName, serializedValue);\n    }\n\n    if (!attributeChanged && propData.syncingAttribute) {\n      propData.syncingAttribute = false;\n    }\n  }\n\n  // Allow the attribute to be linked again.\n  propData.settingAttribute = false;\n}\n\nfunction syncPropToAttr(elem, prop, propName, isFirstSync) {\n  var attributeName = data(elem, 'propertyLinks')[propName];\n  var propData = getPropData(elem, propName);\n\n  if (attributeName) {\n    if (isFirstSync) {\n      syncFirstTimeProp(elem, prop, propName, attributeName, propData);\n    } else {\n      syncExistingProp(elem, prop, propName, attributeName, propData);\n    }\n  }\n}\n\nfunction createNativePropertyDefinition(name$$1, opts) {\n  var prop = {\n    configurable: true,\n    enumerable: true\n  };\n\n  prop.created = function created(elem) {\n    var propData = getPropData(elem, name$$1);\n    var attributeName = opts.attribute === true ? dashCase(name$$1) : opts.attribute;\n    var initialValue = elem[name$$1];\n\n    // Store property to attribute link information.\n    data(elem, 'attributeLinks')[attributeName] = name$$1;\n    data(elem, 'propertyLinks')[name$$1] = attributeName;\n\n    // Set up initial value if it wasn't specified.\n    if (empty(initialValue)) {\n      if (attributeName && elem.hasAttribute(attributeName)) {\n        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n      } else if ('initial' in opts) {\n        initialValue = getInitialValue(elem, name$$1, opts);\n      } else if ('default' in opts) {\n        initialValue = getDefaultValue(elem, name$$1, opts);\n      }\n    }\n\n    propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n  };\n\n  prop.get = function get() {\n    var propData = getPropData(this, name$$1);\n    var internalValue = propData.internalValue;\n\n    return typeof opts.get === 'function' ? opts.get(this, { name: name$$1, internalValue: internalValue }) : internalValue;\n  };\n\n  prop.set = function set(newValue) {\n    var propData = getPropData(this, name$$1);\n    propData.lastAssignedValue = newValue;\n    var oldValue = propData.oldValue;\n\n\n    if (empty(oldValue)) {\n      oldValue = null;\n    }\n\n    if (empty(newValue)) {\n      newValue = getDefaultValue(this, name$$1, opts);\n    }\n\n    if (typeof opts.coerce === 'function') {\n      newValue = opts.coerce(newValue);\n    }\n\n    var changeData = { name: name$$1, newValue: newValue, oldValue: oldValue };\n\n    if (typeof opts.set === 'function') {\n      opts.set(this, changeData);\n    }\n\n    // Queue a re-render.\n    this[rendererDebounced](this);\n\n    // Update prop data so we can use it next time.\n    propData.internalValue = propData.oldValue = newValue;\n\n    // Link up the attribute.\n    if (this[connected]) {\n      syncPropToAttr(this, opts, name$$1, false);\n    }\n  };\n\n  return prop;\n}\n\nvar initProps = function (opts) {\n  opts = opts || {};\n\n  if (typeof opts === 'function') {\n    opts = { coerce: opts };\n  }\n\n  return function (name$$1) {\n    return createNativePropertyDefinition(name$$1, assign({\n      default: null,\n      deserialize: function deserialize(value) {\n        return value;\n      },\n      serialize: function serialize(value) {\n        return value;\n      }\n    }, opts));\n  };\n};\n\nvar HTMLElement$1 = root.HTMLElement || function () {\n  function _class() {\n    classCallCheck(this, _class);\n  }\n\n  return _class;\n}();\nvar _prevName = createSymbol('prevName');\nvar _prevOldValue = createSymbol('prevOldValue');\nvar _prevNewValue = createSymbol('prevNewValue');\n\nfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n}\n\nfunction syncPropsToAttrs(elem) {\n  var props$$1 = getPropsMap(elem.constructor);\n  Object.keys(props$$1).forEach(function (propName) {\n    var prop = props$$1[propName];\n    syncPropToAttr(elem, prop, propName, true);\n  });\n}\n\n// TODO remove when not catering to Safari < 10.\n//\n// Ensures that definitions passed as part of the constructor are functions\n// that return property definitions used on the element.\nfunction ensurePropertyFunctions(Ctor) {\n  var props$$1 = getPropsMap(Ctor);\n  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = props$$1[descriptorName];\n    if (typeof descriptors[descriptorName] !== 'function') {\n      descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n    }\n    return descriptors;\n  }, {});\n}\n\n// TODO remove when not catering to Safari < 10.\n//\n// This can probably be simplified into createInitProps().\nfunction ensurePropertyDefinitions(Ctor) {\n  var props$$1 = ensurePropertyFunctions(Ctor);\n  return keys(props$$1).reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = props$$1[descriptorName](descriptorName);\n    return descriptors;\n  }, {});\n}\n\n// TODO refactor when not catering to Safari < 10.\n//\n// We should be able to simplify this where all we do is Object.defineProperty().\nfunction createInitProps(Ctor) {\n  var props$$1 = ensurePropertyDefinitions(Ctor);\n\n  return function (elem) {\n    if (!props$$1) {\n      return;\n    }\n\n    keys(props$$1).forEach(function (name$$1) {\n      var prop = props$$1[name$$1];\n      prop.created(elem);\n\n      // We check here before defining to see if the prop was specified prior\n      // to upgrading.\n      var hasPropBeforeUpgrading = name$$1 in elem;\n\n      // This is saved prior to defining so that we can set it after it it was\n      // defined prior to upgrading. We don't want to invoke the getter if we\n      // don't need to, so we only get the value if we need to re-sync.\n      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      //\n      // When Webkit fixes that bug so that native property accessors can be\n      // retrieved, we can move defining the property to the prototype and away\n      // from having to do if for every instance as all other browsers support\n      // this.\n      Object.defineProperty(elem, name$$1, prop);\n\n      // DEPRECATED\n      //\n      // We'll be removing get / set callbacks on properties. Use the\n      // updatedCallback() instead.\n      //\n      // We re-set the prop if it was specified prior to upgrading because we\n      // need to ensure set() is triggered both in polyfilled environments and\n      // in native where the definition may be registerd after elements it\n      // represents have already been created.\n      if (hasPropBeforeUpgrading) {\n        elem[name$$1] = valueBeforeUpgrading;\n      }\n    });\n  };\n}\n\nvar _class2 = function (_HTMLElement) {\n  inherits(_class2, _HTMLElement);\n  createClass(_class2, null, [{\n    key: 'observedAttributes',\n\n\n    /**\n     * Returns unique attribute names configured with props and\n     * those set on the Component constructor if any\n     */\n    get: function get() {\n      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n\n      var props$$1 = getPropsMap(this);\n      var attrsFromLinkedProps = Object.keys(props$$1).map(function (key) {\n        var attribute = props$$1[key].attribute;\n\n        return attribute === true ? dashCase(key) : attribute;\n      }).filter(Boolean);\n\n      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n\n      return all.filter(function (item, index) {\n        return all.indexOf(item) === index;\n      });\n    },\n    set: function set(value) {\n      value = Array.isArray(value) ? value : [];\n      setCtorNativeProperty(this, 'observedAttributes', value);\n    }\n\n    // Returns superclass props overwritten with this Component props\n\n  }, {\n    key: 'props',\n    get: function get() {\n      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n    },\n    set: function set(value) {\n      setCtorNativeProperty(this, ctorProps, value);\n    }\n  }]);\n\n  function _class2() {\n    classCallCheck(this, _class2);\n\n    var _this = possibleConstructorReturn(this, (_class2.__proto__ || Object.getPrototypeOf(_class2)).call(this));\n\n    var constructor = _this.constructor;\n\n    // Used for the ready() function so it knows when it can call its callback.\n\n    _this[created$1] = true;\n\n    // TODO refactor to not cater to Safari < 10. This means we can depend on\n    // built-in property descriptors.\n    // Must be defined on constructor and not from a superclass\n    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n    }\n\n    // Set up a renderer that is debounced for property sets to call directly.\n    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\n    // Set up property lifecycle.\n    var propConfigsCount = keys(getPropsMap(constructor)).length;\n    if (propConfigsCount && constructor[ctorCreateInitProps]) {\n      constructor[ctorCreateInitProps](_this);\n    }\n\n    // DEPRECATED\n    //\n    // static render()\n    if (!_this.renderCallback && constructor.render) {\n      _this.renderCallback = constructor.render.bind(constructor, _this);\n    }\n\n    // DEPRECATED\n    //\n    // static created()\n    //\n    // Props should be set up before calling this.\n    if (typeof constructor.created === 'function') {\n      constructor.created(_this);\n    }\n\n    // DEPRECATED\n    //\n    // Feature has rarely been used.\n    //\n    // Created should be set before invoking the ready listeners.\n    var elemData = data(_this);\n    var readyCallbacks = elemData.readyCallbacks;\n    if (readyCallbacks) {\n      readyCallbacks.forEach(function (cb) {\n        return cb(_this);\n      });\n      delete elemData.readyCallbacks;\n    }\n    return _this;\n  }\n\n  // Custom Elements v1\n\n\n  createClass(_class2, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var constructor = this.constructor;\n\n      // DEPRECATED\n      //\n      // No more reflecting back to attributes in favour of one-way reflection.\n\n      syncPropsToAttrs(this);\n\n      // Used to check whether or not the component can render.\n      this[connected] = true;\n\n      // Render!\n      this[rendererDebounced]();\n\n      // DEPRECATED\n      //\n      // static attached()\n      if (typeof constructor.attached === 'function') {\n        constructor.attached(this);\n      }\n\n      // DEPRECATED\n      //\n      // We can remove this once all browsers support :defined.\n      this.setAttribute('defined', '');\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      var constructor = this.constructor;\n\n      // Ensures the component can't be rendered while disconnected.\n\n      this[connected] = false;\n\n      // DEPRECATED\n      //\n      // static detached()\n      if (typeof constructor.detached === 'function') {\n        constructor.detached(this);\n      }\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n      // Polyfill calls this twice.\n      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n        return;\n      }\n\n      // Set data so we can prevent double calling if the polyfill.\n      this[_prevName] = name$$1;\n      this[_prevOldValue] = oldValue;\n      this[_prevNewValue] = newValue;\n\n      var attributeChanged = this.constructor.attributeChanged;\n\n      var propertyName = data(this, 'attributeLinks')[name$$1];\n\n      if (propertyName) {\n        var propData = data(this, 'props')[propertyName];\n\n        // This ensures a property set doesn't cause the attribute changed\n        // handler to run again once we set this flag. This only ever has a\n        // chance to run when you set an attribute, it then sets a property and\n        // then that causes the attribute to be set again.\n        if (propData.syncingAttribute) {\n          propData.syncingAttribute = false;\n        } else {\n          // Sync up the property.\n          var propOpts = getPropsMap(this.constructor)[propertyName];\n          propData.settingAttribute = true;\n          var newPropVal = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n          this[propertyName] = newPropVal;\n        }\n      }\n\n      if (attributeChanged) {\n        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n      }\n    }\n\n    // Skate\n    //\n    // Maps to the static updated() callback. That logic should be moved here\n    // when that is finally removed.\n\n  }, {\n    key: 'updatedCallback',\n    value: function updatedCallback(prev) {\n      return this.constructor.updated(this, prev);\n    }\n\n    // Skate\n    //\n    // Maps to the static rendered() callback. That logic should be moved here\n    // when that is finally removed.\n\n  }, {\n    key: 'renderedCallback',\n    value: function renderedCallback() {\n      return this.constructor.rendered(this);\n    }\n\n    // Skate\n    //\n    // Maps to the static renderer() callback. That logic should be moved here\n    // when that is finally removed.\n\n  }, {\n    key: 'rendererCallback',\n    value: function rendererCallback() {\n      return this.constructor.renderer(this);\n    }\n\n    // Skate\n    //\n    // Invokes the complete render lifecycle.\n\n  }, {\n    key: renderer$1,\n    value: function value() {\n      if (this[rendering] || !this[connected]) {\n        return;\n      }\n\n      // Flag as rendering. This prevents anything from trying to render - or\n      // queueing a render - while there is a pending render.\n      this[rendering] = true;\n\n      if (this[updated$1]() && typeof this.renderCallback === 'function') {\n        this.rendererCallback();\n        this.renderedCallback();\n      }\n\n      this[rendering] = false;\n    }\n\n    // Skate\n    //\n    // Calls the user-defined updated() lifecycle callback.\n\n  }, {\n    key: updated$1,\n    value: function value() {\n      var prev = this[props];\n      this[props] = props$1(this);\n      return this.updatedCallback(prev);\n    }\n\n    // Skate\n\n  }], [{\n    key: 'extend',\n    value: function extend() {\n      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n      // Create class for the user.\n      var Ctor = function (_Base) {\n        inherits(Ctor, _Base);\n\n        function Ctor() {\n          classCallCheck(this, Ctor);\n          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n        }\n\n        return Ctor;\n      }(Base);\n\n      // For inheriting from the object literal.\n\n\n      var opts = getOwnPropertyDescriptors(definition);\n      var prot = getOwnPropertyDescriptors(definition.prototype);\n\n      // Prototype is non configurable (but is writable).\n      delete opts.prototype;\n\n      // Pass on static and instance members from the definition.\n      Object.defineProperties(Ctor, opts);\n      Object.defineProperties(Ctor.prototype, prot);\n\n      return Ctor;\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'updated',\n    value: function updated(elem, prev) {\n      if (!prev) {\n        return true;\n      }\n\n      // use get all keys so that we check Symbols as well as regular props\n      // using a for loop so we can break early\n      var allKeys = keys(prev);\n      for (var i = 0; i < allKeys.length; i += 1) {\n        if (prev[allKeys[i]] !== elem[allKeys[i]]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'rendered',\n    value: function rendered() {}\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'renderer',\n    value: function renderer(elem) {\n      if (!elem.shadowRoot) {\n        elem.attachShadow({ mode: 'open' });\n      }\n      incrementalDom.patchInner(elem.shadowRoot, function () {\n        var possibleFn = elem.renderCallback();\n        if (typeof possibleFn === 'function') {\n          possibleFn();\n        } else if (Array.isArray(possibleFn)) {\n          possibleFn.forEach(function (fn) {\n            if (typeof fn === 'function') {\n              fn();\n            }\n          });\n        }\n      });\n    }\n  }]);\n  return _class2;\n}(HTMLElement$1);\n\nfunction uniqueId(prefix) {\n  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    // eslint-disable-next-line no-mixed-operators\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n  return (prefix || 'x') + '-' + rand;\n}\n\nvar define = function () {\n  var customElements = root.customElements;\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var name$$1 = args[0];\n  var Ctor = args[1];\n\n\n  if (!customElements) {\n    throw new Error('Skate requires native custom element support or a polyfill.');\n  }\n\n  // Support passing an anonymous definition.\n  if (args.length === 1) {\n    // We are checking string for now, but once we remove the ability to pass\n    // an object literal, we can change this to check \"function\" and invert the\n    // blocks of logic.\n    if (typeof name$$1 === 'string') {\n      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n    } else {\n      Ctor = name$$1;\n      name$$1 = uniqueId();\n    }\n  }\n\n  // Ensure there's no conflicts.\n  if (customElements.get(name$$1)) {\n    name$$1 = uniqueId(name$$1);\n  }\n\n  // DEPRECATED\n  //\n  // Object literals.\n  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n    Ctor = _class2.extend(Ctor);\n  }\n\n  // This allows us to check this before instantiating the custom element to\n  // find its name from the constructor in the vdom module, thus improving\n  // performance but still falling back to a robust method.\n  Ctor[name] = name$$1;\n\n  // Sipmle define. Not supporting customised built-ins yet.\n  customElements.define(name$$1, Ctor);\n\n  // The spec doesn't return but this allows for a simpler, more concise API.\n  return Ctor;\n};\n\nvar Event = function (TheEvent) {\n  if (TheEvent) {\n    try {\n      new TheEvent('emit-init'); // eslint-disable-line no-new\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return TheEvent;\n}(root.Event);\n\nfunction createCustomEvent(name) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var detail = opts.detail;\n\n  delete opts.detail;\n\n  var e = void 0;\n  if (Event) {\n    e = new Event(name, opts);\n    Object.defineProperty(e, 'detail', { value: detail });\n  } else {\n    e = document.createEvent('CustomEvent');\n    Object.defineProperty(e, 'composed', { value: opts.composed });\n    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n  }\n  return e;\n}\n\nvar emit = function (elem, name) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (opts.bubbles === undefined) {\n    opts.bubbles = true;\n  }\n  if (opts.cancelable === undefined) {\n    opts.cancelable = true;\n  }\n  if (opts.composed === undefined) {\n    opts.composed = true;\n  }\n  return elem.dispatchEvent(createCustomEvent(name, opts));\n};\n\nfunction getValue(elem) {\n  var type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nvar link = function (elem, target) {\n  return function (e) {\n    var value = getValue(e.target);\n    var localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      var parts = localTarget.split('.');\n      var firstPart = parts[0];\n      var propName = parts.pop();\n      var obj = parts.reduce(function (prev, curr) {\n        return prev && prev[curr];\n      }, elem);\n\n      obj[propName || e.target.name] = value;\n      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n    } else {\n      props$1(elem, defineProperty({}, localTarget, value));\n    }\n  };\n};\n\nvar ready = function (elem, done) {\n  var info = data(elem);\n  if (elem[created$1]) {\n    done(elem);\n  } else if (info.readyCallbacks) {\n    info.readyCallbacks.push(done);\n  } else {\n    info.readyCallbacks = [done];\n  }\n};\n\nvar h = builder();\n\nexports.Component = _class2;\nexports.define = define;\nexports.emit = emit;\nexports.h = h;\nexports.link = link;\nexports.prop = prop;\nexports.props = props$1;\nexports.ready = ready;\nexports.symbols = symbols$1;\nexports.vdom = vdom;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs/dist/index.js\n// module id = 2\n// module chunks = 0 1","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/incremental-dom/dist/incremental-dom-cjs.js\n// module id = 3\n// module chunks = 0 1","'use strict'\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n  (typeof global === 'object' && global.global === global && global) ||\n  this\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/window-or-global/lib/index.js\n// module id = 4\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/BehaviorSubject.js\n// module id = 5\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('./Observable');\nvar Subscriber_1 = require('./Subscriber');\nvar Subscription_1 = require('./Subscription');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subject.js\n// module id = 6\n// module chunks = 0 1","\"use strict\";\nvar root_1 = require('./util/root');\nvar toSubscriber_1 = require('./util/toSubscriber');\nvar observable_1 = require('./symbol/observable');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observable.js\n// module id = 7\n// module chunks = 0 1","\"use strict\";\n/**\n * window: browser in DOM main thread\n * self: browser in WebWorker\n * global: Node.js/other\n */\nexports.root = (typeof window == 'object' && window.window === window && window\n    || typeof self == 'object' && self.self === self && self\n    || typeof global == 'object' && global.global === global && global);\nif (!exports.root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n}\n//# sourceMappingURL=root.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/root.js\n// module id = 8\n// module chunks = 0 1","\"use strict\";\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nvar Observer_1 = require('../Observer');\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber(Observer_1.empty);\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/toSubscriber.js\n// module id = 9\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription_1 = require('./Subscription');\nvar Observer_1 = require('./Observer');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parent = _parent;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parent = this._parent;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parent = this._parent;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subscriber.js\n// module id = 10\n// module chunks = 0 1","\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isFunction.js\n// module id = 11\n// module chunks = 0 1","\"use strict\";\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject_1.errorObject.e);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.closed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subscription.js\n// module id = 12\n// module chunks = 0 1","\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isArray.js\n// module id = 13\n// module chunks = 0 1","\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isObject.js\n// module id = 14\n// module chunks = 0 1","\"use strict\";\nvar errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/tryCatch.js\n// module id = 15\n// module chunks = 0 1","\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/errorObject.js\n// module id = 16\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/UnsubscriptionError.js\n// module id = 17\n// module chunks = 0 1","\"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observer.js\n// module id = 18\n// module chunks = 0 1","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/rxSubscriber.js\n// module id = 19\n// module chunks = 0 1","\"use strict\";\nvar root_1 = require('../util/root');\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.$$observable = getSymbolObservable(root_1.root);\n//# sourceMappingURL=observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/observable.js\n// module id = 20\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/ObjectUnsubscribedError.js\n// module id = 21\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('./Subscription');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/SubjectSubscription.js\n// module id = 22\n// module chunks = 0 1","\"use strict\";\nvar AjaxObservable_1 = require('./AjaxObservable');\nexports.ajax = AjaxObservable_1.AjaxObservable.create;\n//# sourceMappingURL=ajax.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observable/dom/ajax.js\n// module id = 23\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../../util/root');\nvar tryCatch_1 = require('../../util/tryCatch');\nvar errorObject_1 = require('../../util/errorObject');\nvar Observable_1 = require('../../Observable');\nvar Subscriber_1 = require('../../Subscriber');\nvar map_1 = require('../../operator/map');\nfunction getCORSRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        var xhr = new root_1.root.XMLHttpRequest();\n        if ('withCredentials' in xhr) {\n            xhr.withCredentials = !!this.withCredentials;\n        }\n        return xhr;\n    }\n    else if (!!root_1.root.XDomainRequest) {\n        return new root_1.root.XDomainRequest();\n    }\n    else {\n        throw new Error('CORS is not supported by your browser');\n    }\n}\nfunction getXMLHttpRequest() {\n    if (root_1.root.XMLHttpRequest) {\n        return new root_1.root.XMLHttpRequest();\n    }\n    else {\n        var progId = void 0;\n        try {\n            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n            for (var i = 0; i < 3; i++) {\n                try {\n                    progId = progIds[i];\n                    if (new root_1.root.ActiveXObject(progId)) {\n                        break;\n                    }\n                }\n                catch (e) {\n                }\n            }\n            return new root_1.root.ActiveXObject(progId);\n        }\n        catch (e) {\n            throw new Error('XMLHttpRequest is not supported by your browser');\n        }\n    }\n}\nfunction ajaxGet(url, headers) {\n    if (headers === void 0) { headers = null; }\n    return new AjaxObservable({ method: 'GET', url: url, headers: headers });\n}\nexports.ajaxGet = ajaxGet;\n;\nfunction ajaxPost(url, body, headers) {\n    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });\n}\nexports.ajaxPost = ajaxPost;\n;\nfunction ajaxDelete(url, headers) {\n    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });\n}\nexports.ajaxDelete = ajaxDelete;\n;\nfunction ajaxPut(url, body, headers) {\n    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });\n}\nexports.ajaxPut = ajaxPut;\n;\nfunction ajaxGetJSON(url, headers) {\n    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })\n        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));\n}\nexports.ajaxGetJSON = ajaxGetJSON;\n;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar AjaxObservable = (function (_super) {\n    __extends(AjaxObservable, _super);\n    function AjaxObservable(urlOrRequest) {\n        _super.call(this);\n        var request = {\n            async: true,\n            createXHR: function () {\n                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n            },\n            crossDomain: false,\n            withCredentials: false,\n            headers: {},\n            method: 'GET',\n            responseType: 'json',\n            timeout: 0\n        };\n        if (typeof urlOrRequest === 'string') {\n            request.url = urlOrRequest;\n        }\n        else {\n            for (var prop in urlOrRequest) {\n                if (urlOrRequest.hasOwnProperty(prop)) {\n                    request[prop] = urlOrRequest[prop];\n                }\n            }\n        }\n        this.request = request;\n    }\n    AjaxObservable.prototype._subscribe = function (subscriber) {\n        return new AjaxSubscriber(subscriber, this.request);\n    };\n    /**\n     * Creates an observable for an Ajax request with either a request object with\n     * url, headers, etc or a string for a URL.\n     *\n     * @example\n     * source = Rx.Observable.ajax('/products');\n     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n     *\n     * @param {string|Object} request Can be one of the following:\n     *   A string of the URL to make the Ajax call.\n     *   An object with the following properties\n     *   - url: URL of the request\n     *   - body: The body of the request\n     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n     *   - async: Whether the request is async\n     *   - headers: Optional headers\n     *   - crossDomain: true if a cross domain request, else false\n     *   - createXHR: a function to override if you need to use an alternate\n     *   XMLHttpRequest implementation.\n     *   - resultSelector: a function to use to alter the output value type of\n     *   the Observable. Gets {@link AjaxResponse} as an argument.\n     * @return {Observable} An observable sequence containing the XMLHttpRequest.\n     * @static true\n     * @name ajax\n     * @owner Observable\n    */\n    AjaxObservable.create = (function () {\n        var create = function (urlOrRequest) {\n            return new AjaxObservable(urlOrRequest);\n        };\n        create.get = ajaxGet;\n        create.post = ajaxPost;\n        create.delete = ajaxDelete;\n        create.put = ajaxPut;\n        create.getJSON = ajaxGetJSON;\n        return create;\n    })();\n    return AjaxObservable;\n}(Observable_1.Observable));\nexports.AjaxObservable = AjaxObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AjaxSubscriber = (function (_super) {\n    __extends(AjaxSubscriber, _super);\n    function AjaxSubscriber(destination, request) {\n        _super.call(this, destination);\n        this.request = request;\n        this.done = false;\n        var headers = request.headers = request.headers || {};\n        // force CORS if requested\n        if (!request.crossDomain && !headers['X-Requested-With']) {\n            headers['X-Requested-With'] = 'XMLHttpRequest';\n        }\n        // ensure content type is set\n        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n        }\n        // properly serialize body\n        request.body = this.serializeBody(request.body, request.headers['Content-Type']);\n        this.send();\n    }\n    AjaxSubscriber.prototype.next = function (e) {\n        this.done = true;\n        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;\n        var response = new AjaxResponse(e, xhr, request);\n        destination.next(response);\n    };\n    AjaxSubscriber.prototype.send = function () {\n        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;\n        var createXHR = request.createXHR;\n        var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n        if (xhr === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            this.xhr = xhr;\n            // open XHR first\n            var result = void 0;\n            if (user) {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n            }\n            else {\n                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n            }\n            if (result === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n                return null;\n            }\n            // timeout and responseType can be set once the XHR is open\n            xhr.timeout = request.timeout;\n            xhr.responseType = request.responseType;\n            // set headers\n            this.setHeaders(xhr, headers);\n            // now set up the events\n            this.setupEvents(xhr, request);\n            // finally send the request\n            if (body) {\n                xhr.send(body);\n            }\n            else {\n                xhr.send();\n            }\n        }\n        return xhr;\n    };\n    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n        if (!body || typeof body === 'string') {\n            return body;\n        }\n        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n            return body;\n        }\n        if (contentType) {\n            var splitIndex = contentType.indexOf(';');\n            if (splitIndex !== -1) {\n                contentType = contentType.substring(0, splitIndex);\n            }\n        }\n        switch (contentType) {\n            case 'application/x-www-form-urlencoded':\n                return Object.keys(body).map(function (key) { return (encodeURI(key) + \"=\" + encodeURI(body[key])); }).join('&');\n            case 'application/json':\n                return JSON.stringify(body);\n            default:\n                return body;\n        }\n    };\n    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n        for (var key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                xhr.setRequestHeader(key, headers[key]);\n            }\n        }\n    };\n    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n        var progressSubscriber = request.progressSubscriber;\n        function xhrTimeout(e) {\n            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (progressSubscriber) {\n                progressSubscriber.error(e);\n            }\n            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n        }\n        ;\n        xhr.ontimeout = xhrTimeout;\n        xhrTimeout.request = request;\n        xhrTimeout.subscriber = this;\n        xhrTimeout.progressSubscriber = progressSubscriber;\n        if (xhr.upload && 'withCredentials' in xhr && root_1.root.XDomainRequest) {\n            if (progressSubscriber) {\n                var xhrProgress_1;\n                xhrProgress_1 = function (e) {\n                    var progressSubscriber = xhrProgress_1.progressSubscriber;\n                    progressSubscriber.next(e);\n                };\n                xhr.onprogress = xhrProgress_1;\n                xhrProgress_1.progressSubscriber = progressSubscriber;\n            }\n            var xhrError_1;\n            xhrError_1 = function (e) {\n                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                subscriber.error(new AjaxError('ajax error', this, request));\n            };\n            xhr.onerror = xhrError_1;\n            xhrError_1.request = request;\n            xhrError_1.subscriber = this;\n            xhrError_1.progressSubscriber = progressSubscriber;\n        }\n        function xhrReadyStateChange(e) {\n            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n            if (this.readyState === 4) {\n                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                var status_1 = this.status === 1223 ? 204 : this.status;\n                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                // fix status code when it is 0 (0 status is undocumented).\n                // Occurs when accessing file resources or on Android 4.1 stock browser\n                // while retrieving files from application cache.\n                if (status_1 === 0) {\n                    status_1 = response ? 200 : 0;\n                }\n                if (200 <= status_1 && status_1 < 300) {\n                    if (progressSubscriber) {\n                        progressSubscriber.complete();\n                    }\n                    subscriber.next(e);\n                    subscriber.complete();\n                }\n                else {\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n                }\n            }\n        }\n        ;\n        xhr.onreadystatechange = xhrReadyStateChange;\n        xhrReadyStateChange.subscriber = this;\n        xhrReadyStateChange.progressSubscriber = progressSubscriber;\n        xhrReadyStateChange.request = request;\n    };\n    AjaxSubscriber.prototype.unsubscribe = function () {\n        var _a = this, done = _a.done, xhr = _a.xhr;\n        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n            xhr.abort();\n        }\n        _super.prototype.unsubscribe.call(this);\n    };\n    return AjaxSubscriber;\n}(Subscriber_1.Subscriber));\nexports.AjaxSubscriber = AjaxSubscriber;\n/**\n * A normalized AJAX response.\n *\n * @see {@link ajax}\n *\n * @class AjaxResponse\n */\nvar AjaxResponse = (function () {\n    function AjaxResponse(originalEvent, xhr, request) {\n        this.originalEvent = originalEvent;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n        this.responseType = xhr.responseType || request.responseType;\n        switch (this.responseType) {\n            case 'json':\n                if ('response' in xhr) {\n                    //IE does not support json as responseType, parse it internally\n                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n                }\n                else {\n                    this.response = JSON.parse(xhr.responseText || 'null');\n                }\n                break;\n            case 'xml':\n                this.response = xhr.responseXML;\n                break;\n            case 'text':\n            default:\n                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;\n                break;\n        }\n    }\n    return AjaxResponse;\n}());\nexports.AjaxResponse = AjaxResponse;\n/**\n * A normalized AJAX error.\n *\n * @see {@link ajax}\n *\n * @class AjaxError\n */\nvar AjaxError = (function (_super) {\n    __extends(AjaxError, _super);\n    function AjaxError(message, xhr, request) {\n        _super.call(this, message);\n        this.message = message;\n        this.xhr = xhr;\n        this.request = request;\n        this.status = xhr.status;\n    }\n    return AjaxError;\n}(Error));\nexports.AjaxError = AjaxError;\n/**\n * @see {@link ajax}\n *\n * @class AjaxTimeoutError\n */\nvar AjaxTimeoutError = (function (_super) {\n    __extends(AjaxTimeoutError, _super);\n    function AjaxTimeoutError(xhr, request) {\n        _super.call(this, 'ajax timeout', xhr, request);\n    }\n    return AjaxTimeoutError;\n}(AjaxError));\nexports.AjaxTimeoutError = AjaxTimeoutError;\n//# sourceMappingURL=AjaxObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observable/dom/AjaxObservable.js\n// module id = 24\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/map.js\n// module id = 25\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar empty_1 = require('../../observable/empty');\nObservable_1.Observable.empty = empty_1.empty;\n//# sourceMappingURL=empty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/observable/empty.js\n// module id = 26\n// module chunks = 0 1","\"use strict\";\nvar EmptyObservable_1 = require('./EmptyObservable');\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/empty.js\n// module id = 27\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/observable/EmptyObservable.js\n// module id = 28\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar filter_1 = require('../../operator/filter');\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/filter.js\n// module id = 29\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:disable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctKey}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n        this.predicate = predicate;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/filter.js\n// module id = 30\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar map_1 = require('../../operator/map');\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/map.js\n// module id = 31\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar catch_1 = require('../../operator/catch');\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/catch.js\n// module id = 32\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} an observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    var operator = new CatchOperator(selector);\n    var caught = this.lift(operator);\n    return (operator.caught = caught);\n}\nexports._catch = _catch;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.unsubscribe();\n            this.destination.remove(this);\n            subscribeToResult_1.subscribeToResult(this, result);\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/catch.js\n// module id = 33\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/OuterSubscriber.js\n// module id = 34\n// module chunks = 0 1","\"use strict\";\nvar root_1 = require('./root');\nvar isArray_1 = require('./isArray');\nvar isPromise_1 = require('./isPromise');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\nvar InnerSubscriber_1 = require('../InnerSubscriber');\nvar observable_1 = require('../symbol/observable');\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    if (isArray_1.isArray(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (typeof result[iterator_1.$$iterator] === 'function') {\n        var iterator = result[iterator_1.$$iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (typeof result[observable_1.$$observable] === 'function') {\n        var obs = result[observable_1.$$observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new Error('invalid observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        destination.error(new TypeError('unknown type returned'));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/subscribeToResult.js\n// module id = 35\n// module chunks = 0 1","\"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isPromise.js\n// module id = 36\n// module chunks = 0 1","\"use strict\";\nvar root_1 = require('../util/root');\nfunction symbolIteratorPonyfill(root) {\n    var Symbol = root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (!Symbol.iterator) {\n            Symbol.iterator = Symbol('iterator polyfill');\n        }\n        return Symbol.iterator;\n    }\n    else {\n        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n        var Set_1 = root.Set;\n        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n            return '@@iterator';\n        }\n        var Map_1 = root.Map;\n        // required for compatability with es6-shim\n        if (Map_1) {\n            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                    return key;\n                }\n            }\n        }\n        return '@@iterator';\n    }\n}\nexports.symbolIteratorPonyfill = symbolIteratorPonyfill;\nexports.$$iterator = symbolIteratorPonyfill(root_1.root);\n//# sourceMappingURL=iterator.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/iterator.js\n// module id = 37\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/InnerSubscriber.js\n// module id = 38\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar switchMap_1 = require('../../operator/switchMap');\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/switchMap.js\n// module id = 39\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:disable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): Observable} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return this.lift(new SwitchMapOperator(project, resultSelector));\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/switchMap.js\n// module id = 40\n// module chunks = 0 1","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar distinct_1 = require('../../operator/distinct');\nObservable_1.Observable.prototype.distinct = distinct_1.distinct;\n//# sourceMappingURL=distinct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/distinct.js\n// module id = 41\n// module chunks = 0 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar Set_1 = require('../util/Set');\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n * @param {function} [keySelector] optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} an Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return this.lift(new DistinctOperator(keySelector, flushes));\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.values = new Set_1.Set();\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/distinct.js\n// module id = 42\n// module chunks = 0 1","\"use strict\";\nvar root_1 = require('./root');\nfunction minimalSetImpl() {\n    // THIS IS NOT a full impl of Set, this is just the minimum\n    // bits of functionality we need for this library.\n    return (function () {\n        function MinimalSet() {\n            this._values = [];\n        }\n        MinimalSet.prototype.add = function (value) {\n            if (!this.has(value)) {\n                this._values.push(value);\n            }\n        };\n        MinimalSet.prototype.has = function (value) {\n            return this._values.indexOf(value) !== -1;\n        };\n        Object.defineProperty(MinimalSet.prototype, \"size\", {\n            get: function () {\n                return this._values.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MinimalSet.prototype.clear = function () {\n            this._values.length = 0;\n        };\n        return MinimalSet;\n    }());\n}\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || minimalSetImpl();\n//# sourceMappingURL=Set.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/Set.js\n// module id = 43\n// module chunks = 0 1"],"sourceRoot":""}